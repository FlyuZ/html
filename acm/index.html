<!-- By: kkke -->
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>RoadTrip</title>
        <link rel="stylesheet" type="text/css" href="./src/github2-rightpart.css" media="all">
        <link rel="stylesheet" type="text/css" href="./src/github1-contents.css">
        <link rel="stylesheet" href="./src/zTreeStyle.css" type="text/css">
        <style>
		  div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
            .ztree li a.curSelectedNode {
                padding-top: 0px;
                background-color: #FFE6B0;
                color: black;
                height: 16px;
                border: 1px #FFB951 solid;
                opacity: 0.8;
            }
            .ztree{
                overflow: auto;
                height:100%;
                min-height: 200px;
                top: 0px;
            }
        </style>
  		<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
    </head>
    <body style="">
        <div>
            <div style="width:30%;">
                <ul id="tree" class="ztree" style="width: 260px; overflow: auto; position: fixed; z-index: 2147483647; border: 0px none; left: 0px; bottom: 0px;">
                <!-- 目录内容在网页另存为之后将插入到此处 -->
                </ul>
            </div>
            <div id="readme" style="width:70%;margin-left:25%;">
                <article class="markdown-body">

<h1 id="实用数据结构"><span class="header-section-number">1</span> 实用数据结构</h1>
<h2 id="加权并查集"><span class="header-section-number">1.1</span> 加权并查集</h2>
<p>解决集合问题中，集合内元素有关系并且关系具有传递性的问题<br />
从集合中删除节点的方法：消除该点对集合的影响(如集合中的点个数、和、最值)，然后给它分配一个新的编号(原来的编号不管)</p>
<h3 id="头文件宏全局变量"><span class="header-section-number">1.1.1</span> 头文件&amp;宏&amp;全局变量</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MAXN 100000</span><span class="co">//最大点数</span>
<span class="dt">int</span> p[MAXN];<span class="co">//父节点</span>
<span class="dt">int</span> v[MAXN];<span class="co">//到父节点边的权值(加权解决集合中点的相互关系的问题)</span></code></pre></div>
<h3 id="初始化"><span class="header-section-number">1.1.2</span> 初始化</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> union_init(<span class="dt">int</span> minn,<span class="dt">int</span> maxn)<span class="co">//编号最小值到最大值</span>
{
    <span class="kw">for</span>(<span class="dt">int</span> i=minn;i&lt;=maxn;i++)
    {
        p[i]=i;
        v[i]=<span class="dv">0</span>;
    }
}</code></pre></div>
<h3 id="查找"><span class="header-section-number">1.1.3</span> 查找</h3>
<p>执行后p[a]为a所在集合的根节点,v[a]为a到其集合的根节点的权值</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> union_find(<span class="dt">int</span> a)
{
    <span class="kw">if</span>(p[a]==a)<span class="kw">return</span>;
    union_find(p[a]);
    v[a]+=v[p[a]];
    p[a]=p[p[a]];
}</code></pre></div>
<h3 id="合并"><span class="header-section-number">1.1.4</span> 合并</h3>
<p>合并a,b所在集合,vab为 a到b的权值</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> union_merge(<span class="dt">int</span> a,<span class="dt">int</span> b,<span class="dt">int</span> vab)
{
    union_find(a);
    union_find(b);
    v[p[a]]=vab-v[a]+v[b];
    p[p[a]]=p[b];
}</code></pre></div>
<h2 id="树状数组"><span class="header-section-number">1.2</span> 树状数组</h2>
<p>要求所有数的和不能超出范围,也可修改为记录最值<br />
数组下标应从1开始</p>
<h3 id="头文件宏全局变量-1"><span class="header-section-number">1.2.1</span> 头文件&amp;宏&amp;全局变量</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MAXN 10000</span><span class="co">//数组大小 </span>
<span class="dt">int</span> tree[MAXN];<span class="co">//树状数组 </span></code></pre></div>
<h3 id="辅助函数"><span class="header-section-number">1.2.2</span> 辅助函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> lowbit(<span class="dt">int</span> a)
{
    <span class="kw">return</span> a&amp;-a;
}</code></pre></div>
<h3 id="初始化-1"><span class="header-section-number">1.2.3</span> 初始化</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">memset(tree,<span class="dv">0</span>,<span class="kw">sizeof</span>(tree));</code></pre></div>
<h3 id="单点修改"><span class="header-section-number">1.2.4</span> 单点修改</h3>
<p>把a处的值增加b（如果是修改，需要记录原始数组，转化为增加就行了）</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> tree_add(<span class="dt">int</span> a,<span class="dt">int</span> b)
{
    <span class="kw">for</span>(<span class="dt">int</span> i=a;i&lt;MAXN;i+=lowbit(i))tree[i]+=b;
}</code></pre></div>
<h3 id="区间查询"><span class="header-section-number">1.2.5</span> 区间查询</h3>
<p>查询1到a之间的值的和</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> tree_find(<span class="dt">int</span> a)
{
    <span class="dt">int</span> ans=<span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=a;i;i-=lowbit(i))ans+=tree[i];
    <span class="kw">return</span> ans;
}</code></pre></div>
<h2 id="线段树"><span class="header-section-number">1.3</span> 线段树</h2>
<h3 id="宏结构体全局变量"><span class="header-section-number">1.3.1</span> 宏&amp;结构体&amp;全局变量</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MAXN 10000</span>

<span class="kw">struct</span> Tree{
    <span class="dt">int</span> v;<span class="co">//此区间存的值 </span>
    <span class="dt">int</span> lazy_inc;<span class="co">//整个区间被增加的值 </span>
    <span class="dt">bool</span> lazy;<span class="co">//区间是否被整体修改过 </span>
    <span class="dt">int</span> lazy_chg;<span class="co">//区间被整体修改后的值(lazy==true时有效) </span>
}tree[MAXN*<span class="dv">4</span>];

<span class="dt">int</span> kkke[MAXN];<span class="co">//用于初始化的数组</span></code></pre></div>
<h3 id="辅助函数-1"><span class="header-section-number">1.3.2</span> 辅助函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> lson(<span class="dt">int</span> k){<span class="kw">return</span> k&lt;&lt;<span class="dv">1</span>;}
<span class="dt">int</span> rson(<span class="dt">int</span> k){<span class="kw">return</span> (k&lt;&lt;<span class="dv">1</span>)|<span class="dv">1</span>;}
<span class="dt">void</span> tree_update(<span class="dt">int</span> k)<span class="co">//更新此区间存的值 </span>
{
    tree[k].v=max(tree[lson(k)].v,tree[rson(k)].v)+tree[k].lazy_inc;
    <span class="co">/**可</span>更改(max/min/sum)**/
}
<span class="dt">void</span> tree_chg(<span class="dt">int</span> left,<span class="dt">int</span> right,<span class="dt">int</span> k,<span class="dt">int</span> v)<span class="co">//将编号k的区间全变为v </span>
{
    tree[k].v=v;<span class="co">/**可</span>更改(求和则为v*(right-left<span class="dv">+1</span>))**/
    tree[k].lazy=<span class="kw">true</span>;
    tree[k].lazy_chg=v;
    tree[k].lazy_inc=<span class="dv">0</span>;
}
<span class="dt">void</span> tree_pushdown(<span class="dt">int</span> left,<span class="dt">int</span> right,<span class="dt">int</span> k)<span class="co">//将整体修改的信息向下传递 </span>
{
    <span class="kw">if</span>(tree[k].lazy)
    {
        tree[k].lazy=<span class="kw">false</span>;
        <span class="dt">int</span> mid=(left+right)&gt;&gt;<span class="dv">1</span>;
        tree_chg(left,mid,lson(k),tree[k].lazy_chg);
        tree_chg(mid<span class="dv">+1</span>,right,rson(k),tree[k].lazy_chg);
    }
}</code></pre></div>
<h3 id="初始化-2"><span class="header-section-number">1.3.3</span> 初始化</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> tree_init()
{
    memset(tree,<span class="dv">0</span>,<span class="kw">sizeof</span>(tree));<span class="co">//清0 </span>
}
<span class="dt">void</span> tree_build(<span class="dt">int</span> left,<span class="dt">int</span> right,<span class="dt">int</span> k)<span class="co">//初始化维护某个数组 </span>
{
    tree[k].lazy=<span class="kw">false</span>;
    tree[k].lazy_inc=<span class="dv">0</span>;
    <span class="kw">if</span>(left==right)
    {
        tree[k].v=kkke[left];<span class="co">/**需</span>对应为原数组的名称**/
    }
    <span class="kw">else</span>
    {
        <span class="dt">int</span> mid=(left+right)&gt;&gt;<span class="dv">1</span>;
        tree_build(left,mid,lson(k));
        tree_build(mid<span class="dv">+1</span>,right,rson(k));
        tree_update(k);
    }
}</code></pre></div>
<h3 id="主要使用函数"><span class="header-section-number">1.3.4</span> 主要使用函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//区间增加</span>
<span class="co">//把l到r间的值都增加v </span>
<span class="dt">void</span> tree_add(<span class="dt">int</span> left,<span class="dt">int</span> right,<span class="dt">int</span> k,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> v)
{
    <span class="kw">if</span>(l&lt;=left&amp;&amp;right&lt;=r)
    {
        tree[k].v+=v;
        tree[k].lazy_inc+=v;
    }
    <span class="kw">else</span>
    {
        tree_pushdown(left,right,k);
        <span class="dt">int</span> mid=(left+right)&gt;&gt;<span class="dv">1</span>;
        <span class="kw">if</span>(l&lt;=mid)tree_add(left,mid,lson(k),l,r,v);
        <span class="kw">if</span>(r&gt;mid)tree_add(mid<span class="dv">+1</span>,right,rson(k),l,r,v);
        tree_update(k);
    }
}
<span class="co">//区间修改 </span>
<span class="co">//把l到r间的值都修改为v </span>
<span class="dt">void</span> tree_change(<span class="dt">int</span> left,<span class="dt">int</span> right,<span class="dt">int</span> k,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> v)
{
    <span class="kw">if</span>(l&lt;=left&amp;&amp;right&lt;=r)tree_chg(left,right,k,v);
    <span class="kw">else</span>
    {
        tree_pushdown(left,right,k);
        <span class="dt">int</span> mid=(left+right)&gt;&gt;<span class="dv">1</span>;
        <span class="kw">if</span>(l&lt;=mid)tree_change(left,mid,lson(k),l,r,v);
        <span class="kw">if</span>(r&gt;mid)tree_change(mid<span class="dv">+1</span>,right,rson(k),l,r,v);
        tree_update(k);
    }
}
<span class="co">//区间查询</span>
<span class="co">//查询区间[l,r]维护的值</span>
<span class="dt">int</span> tree_find(<span class="dt">int</span> left,<span class="dt">int</span> right,<span class="dt">int</span> k,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> v)
{
    <span class="kw">if</span>(l&lt;=left&amp;&amp;right&lt;=r)<span class="kw">return</span> tree[k].v;
    <span class="kw">else</span>
    {
        tree_pushdown(left,right,k);
        <span class="dt">int</span> mid=(left+right)&gt;&gt;<span class="dv">1</span>;
        <span class="kw">if</span>(l&lt;=mid&amp;&amp;r&gt;mid)
            <span class="kw">return</span> max(tree_find(left,mid,lson(k),l,r,v)
                      ,tree_find(mid<span class="dv">+1</span>,right,rson(k),l,r,v));
        <span class="co">/**可</span>更改(max/min/sum)**/
        <span class="kw">if</span>(l&lt;=mid)<span class="kw">return</span> tree_find(left,mid,lson(k),l,r,v);
        <span class="kw">return</span> tree_find(mid<span class="dv">+1</span>,right,rson(k),l,r,v);
    }
}</code></pre></div>
<h2 id="树的点分治"><span class="header-section-number">1.4</span> 树的点分治</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 求距离小于k的顶点对数</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> N = <span class="dv">10010</span>;
<span class="dt">int</span> n, k, MAX, root, cnt, answer;

<span class="co">//链式前向星</span>
<span class="dt">int</span> head[N], tot;
<span class="kw">struct</span> Edge{
    <span class="dt">int</span> next, to, w;
}edge[N&lt;&lt;<span class="dv">4</span>];

<span class="dt">void</span> add_edge(<span class="dt">int</span> u, <span class="dt">int</span> v, <span class="dt">int</span> w){
    edge[tot].w = w;
    edge[tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot++;
}

<span class="dt">int</span> size[N];<span class="co">//size[i]表示以i为根的子树的大小，包括i。</span>
<span class="dt">int</span> maxson[N];<span class="co">//maxson[i]表示以i为根的子树的最大儿子的大小。</span>
<span class="dt">int</span> dis[N];<span class="co">//dis[i]表示i到根的距离。</span>
<span class="dt">bool</span> vis[N];<span class="co">//vis[i]用来标记i点是否被删除。</span>

<span class="dt">void</span> init(<span class="dt">int</span> n){
    answer = <span class="dv">0</span>;
    tot = <span class="dv">0</span>;
    memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
    memset(head, <span class="dv">-1</span>, <span class="kw">sizeof</span>(head));
}

<span class="co">//计算出子树的大小</span>
<span class="dt">void</span> dfs_size(<span class="dt">int</span> u, <span class="dt">int</span> fa){
    size[u] = <span class="dv">1</span>;
    maxson[u] = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = head[u]; ~i; i = edge[i].next){
        <span class="dt">int</span> v = edge[i].to;
        <span class="kw">if</span>(vis[v] || v == fa)<span class="kw">continue</span>;
        dfs_size(v, u);
        size[u] += size[v];
        <span class="kw">if</span>(size[v] &gt; maxson[u])
              maxson[u] = size[v];
    }
}

<span class="co">//找子树的重心。最大子树最小的点即为树的重心。</span>
<span class="dt">void</span> dfs_root(<span class="dt">int</span> r, <span class="dt">int</span> u, <span class="dt">int</span> fa){
    <span class="kw">if</span>(size[r] - size[u] &gt; maxson[u])<span class="co">//size[r]-size[u]为u上面的树的尺寸</span>
          maxson[u] = size[r] - size[u];
    <span class="kw">if</span>(maxson[u] &lt; MAX){
        MAX = maxson[u];
        root = u;
    }
    <span class="kw">for</span>(<span class="dt">int</span> i = head[u]; ~i; i = edge[i].next){
        <span class="dt">int</span> v = edge[i].to;
        <span class="kw">if</span>(vis[v] || v == fa)<span class="kw">continue</span>;
        dfs_root(r, v, u);
    }
}

<span class="co">//计算出子树中每个点距离重心的距离</span>
<span class="dt">void</span> dfs_dis(<span class="dt">int</span> u, <span class="dt">int</span> d, <span class="dt">int</span> fa){
    dis[cnt++] = d;
    <span class="kw">for</span>(<span class="dt">int</span> i = head[u]; ~i; i = edge[i].next){
        <span class="dt">int</span> v = edge[i].to;
        <span class="kw">if</span>(vis[v] || v == fa)<span class="kw">continue</span>;
        dfs_dis(v, d+edge[i].w, u);
    }
}

<span class="co">//计算出以u为根的子树中距离和小于k的点对数</span>
<span class="dt">int</span> cal(<span class="dt">int</span> u, <span class="dt">int</span> d){
    <span class="dt">int</span> ans = <span class="dv">0</span>;
    cnt = <span class="dv">0</span>;
    dfs_dis(u, d, <span class="dv">0</span>);
    sort(dis, dis+cnt);
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>, j = cnt<span class="dv">-1</span>; i &lt; j; i++){
        <span class="kw">while</span>(dis[i]+dis[j] &gt; k &amp;&amp; i &lt; j)<span class="co">//双指针</span>
              j--;
        ans += j-i;
    }
    <span class="kw">return</span> ans;
}

<span class="co">//分治，找到树的重心，分为经过重心的点对和不经过重心的点对。</span>
<span class="dt">void</span> solve(<span class="dt">int</span> u){
    MAX = n;
    dfs_size(u, <span class="dv">0</span>);
    dfs_root(u, u, <span class="dv">0</span>);
    answer += cal(root, <span class="dv">0</span>);
    vis[root] = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = head[root]; ~i; i = edge[i].next){
        <span class="dt">int</span> v = edge[i].to;
        <span class="kw">if</span>(vis[v])<span class="kw">continue</span>;
        answer -= cal(v, edge[i].w);
        solve(v);
    }
}

<span class="dt">int</span> main()
{
    <span class="co">//freopen(&quot;dataIn.txt&quot;, &quot;r&quot;, stdin);</span>
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;k)!=EOF){
        <span class="kw">if</span>(!n &amp;&amp; !k)<span class="kw">break</span>;
        <span class="dt">int</span> u, v, w;
        init(n);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n<span class="dv">-1</span>; i++){
            scanf(<span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, &amp;u, &amp;v, &amp;w);
            add_edge(u, v, w);
            add_edge(v, u, w);
        }
        solve(<span class="dv">1</span>);
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, answer);
    }

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="树链剖分"><span class="header-section-number">1.5</span> 树链剖分</h2>
<h3 id="宏全局变量结构体"><span class="header-section-number">1.5.1</span> 宏&amp;全局变量&amp;结构体</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> n;<span class="co">//点数</span>

<span class="dt">int</span> size[MAXN];<span class="co">//子树大小</span>
<span class="dt">int</span> dep[MAXN];<span class="co">//节点深度</span>
<span class="dt">int</span> pa[MAXN];<span class="co">//直系父节点</span>
<span class="dt">int</span> PA[MAXN];<span class="co">//重链开始处</span>
<span class="dt">int</span> id[MAXN];<span class="co">//编号</span>
<span class="dt">int</span> ID;

<span class="kw">struct</span> Edge{
    <span class="dt">int</span> to;
    <span class="dt">int</span> v;
    <span class="dt">int</span> next;
}edge[MAXN*<span class="dv">2</span>];<span class="co">//大小至少为点的二倍</span>
<span class="dt">int</span> head[MAXN],top;
<span class="dt">int</span> kkke[MAXN];<span class="co">//储存点权</span></code></pre></div>
<h3 id="初始化加边函数"><span class="header-section-number">1.5.2</span> 初始化&amp;加边函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> init()
{
    kkke[<span class="dv">0</span>]=<span class="dv">0</span>;
    ID=<span class="dv">0</span>;
    top=<span class="dv">0</span>;
    memset(head,<span class="dv">-1</span>,<span class="kw">sizeof</span>(head));
}

<span class="dt">void</span> addEdge(<span class="dt">int</span> a,<span class="dt">int</span> b,<span class="dt">int</span> v)
{
    edge[top].to=a;
    edge[top].v=v;
    edge[top].next=head[b];
    head[b]=top++;

    edge[top].to=b;
    edge[top].v=v;
    edge[top].next=head[a];
    head[a]=top++;
}</code></pre></div>
<h3 id="主要函数"><span class="header-section-number">1.5.3</span> 主要函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> calcSize(<span class="dt">int</span> nown=<span class="dv">1</span>,<span class="dt">int</span> p=<span class="dv">-1</span>,<span class="dt">int</span> DEP=<span class="dv">0</span>)<span class="co">//计算每棵子树大小</span>
{
    pa[nown]=p;
    size[nown]=<span class="dv">1</span>;
    dep[nown]=DEP;
    <span class="kw">for</span>(<span class="dt">int</span> i=head[nown];i!=<span class="dv">-1</span>;i=edge[i].next)
    {
        <span class="kw">if</span>(edge[i].to==p)<span class="kw">continue</span>;
        calcSize(edge[i].to,nown,DEP<span class="dv">+1</span>);
        size[nown]+=size[edge[i].to];
    }
}

<span class="co">//树链剖分，id[PA[nown]]~id[nown]间都属于这条链</span>
<span class="dt">void</span> dfs(<span class="dt">int</span> nown=<span class="dv">1</span>,<span class="dt">int</span> p=<span class="dv">1</span>)
{
    id[nown]=ID++;
    PA[nown]=p;
    <span class="dt">int</span> maxi=<span class="dv">-1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=head[nown];i!=<span class="dv">-1</span>;i=edge[i].next)
    {
        <span class="kw">if</span>(edge[i].to==pa[nown])<span class="kw">continue</span>;
        <span class="kw">if</span>(maxi==<span class="dv">-1</span>||size[edge[i].to]&gt;size[maxi])
            maxi=edge[i].to;
    }
    <span class="kw">if</span>(maxi==<span class="dv">-1</span>)<span class="kw">return</span>;
    dfs(maxi,p);
    <span class="kw">for</span>(<span class="dt">int</span> i=head[nown];i!=<span class="dv">-1</span>;i=edge[i].next)
    {
        <span class="kw">if</span>(edge[i].to==pa[nown]||edge[i].to==maxi)<span class="kw">continue</span>;
        dfs(edge[i].to,edge[i].to);
    }
    <span class="kw">for</span>(<span class="dt">int</span> i=head[nown];i!=<span class="dv">-1</span>;i=edge[i].next)
    {
        <span class="kw">if</span>(edge[i].to==pa[nown])<span class="kw">continue</span>;
        kkke[id[edge[i].to]]=edge[i].v;<span class="co">//初始化点权</span>
    }
}</code></pre></div>
<h3 id="参考查找函数"><span class="header-section-number">1.5.4</span> 参考查找函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//线段树函数省略</span>
<span class="co">//a-&gt;b路径长度</span>
<span class="dt">int</span> findDist(<span class="dt">int</span> a,<span class="dt">int</span> b)
{
    <span class="dt">int</span> ans=<span class="dv">0</span>;
    <span class="kw">while</span>(PA[a]!=PA[b])
    {
        <span class="kw">if</span>(dep[PA[a]]&lt;dep[PA[b]])swap(a,b);
        ans+=treeFind(<span class="dv">0</span>,n<span class="dv">-1</span>,<span class="dv">1</span>,id[PA[a]],id[a]);
        a=pa[PA[a]];
    }
    <span class="kw">if</span>(dep[a]&lt;dep[b])ans+=treeFind(<span class="dv">0</span>,n<span class="dv">-1</span>,<span class="dv">1</span>,id[a]<span class="dv">+1</span>,id[b]);
    <span class="kw">else</span> <span class="kw">if</span>(dep[a]&gt;dep[b])ans+=treeFind(<span class="dv">0</span>,n<span class="dv">-1</span>,<span class="dv">1</span>,id[b]<span class="dv">+1</span>,id[a]);
    <span class="kw">return</span> ans;
}</code></pre></div>
<h3 id="使用方法"><span class="header-section-number">1.5.5</span> 使用方法</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">init()
<span class="kw">for</span>(each a-&gt;b)addEdge(a,b,v);
calcSize();
dfs();</code></pre></div>
<h2 id="splay"><span class="header-section-number">1.6</span> splay</h2>
<h3 id="头文件宏全局变量结构体"><span class="header-section-number">1.6.1</span> 头文件&amp;宏&amp;全局变量&amp;结构体</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MAXN 600010</span><span class="co">//MAXN是插入操作数量</span>

<span class="kw">struct</span> node{
    <span class="dt">int</span> num;
    node* p;
    node* son[<span class="dv">2</span>];
    <span class="dt">int</span> lazy;
    <span class="dt">bool</span> lazyr;
    <span class="dt">int</span> size;
    <span class="dt">int</span> maxnum;
}tree[MAXN],*nil,*root;
<span class="dt">int</span> top=<span class="dv">0</span>;
<span class="co">//用于伪内存分配</span></code></pre></div>
<h3 id="辅助函数-2"><span class="header-section-number">1.6.2</span> 辅助函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">node* new_node()<span class="co">//伪内存分配</span>
{
    <span class="kw">return</span> &amp;tree[top++];
}

<span class="dt">void</span> push_down(node* nown)<span class="co">//下移懒惰标记</span>
{
    <span class="kw">if</span>(nown-&gt;lazyr)
    {
        swap(nown-&gt;son[<span class="dv">0</span>],nown-&gt;son[<span class="dv">1</span>]);
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">2</span>;i++)nown-&gt;son[i]-&gt;lazyr=!nown-&gt;son[i]-&gt;lazyr;
        nown-&gt;lazyr=<span class="kw">false</span>;
    }
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">2</span>;i++)nown-&gt;son[i]-&gt;lazy+=nown-&gt;lazy;
    nown-&gt;num+=nown-&gt;lazy;
    nown-&gt;maxnum+=nown-&gt;lazy;
    nown-&gt;lazy=<span class="dv">0</span>;
}

<span class="dt">void</span> push_up(node* nown)<span class="co">//上移计算</span>
{
    node *left=nown-&gt;son[<span class="dv">0</span>],*right=nown-&gt;son[<span class="dv">1</span>];
    nown-&gt;maxnum=nown-&gt;num;
    <span class="kw">if</span>(left!=nil)
    {
        push_down(left);
        nown-&gt;maxnum=max(left-&gt;maxnum,nown-&gt;maxnum);
    }
    <span class="kw">if</span>(right!=nil)
    {
        push_down(right);
        nown-&gt;maxnum=max(right-&gt;maxnum,nown-&gt;maxnum);
    }
    nown-&gt;size=left-&gt;size+right-&gt;size<span class="dv">+1</span>;
}

<span class="dt">void</span> push_up_parents(node* nown)
{
    <span class="kw">while</span>(nown!=root)
    {
        nown=nown-&gt;p;
        push_up(nown);
    }
}

<span class="dt">void</span> plant(node *nown,node *p,<span class="dt">int</span> i)
{
    nown-&gt;p=p;
    p-&gt;son[i]=nown;
}

<span class="dt">void</span> rotate(node *nown)<span class="co">//旋转操作</span>
{
    node *p=nown-&gt;p;
    <span class="kw">if</span>(p==root)root=nown;
    <span class="kw">else</span> plant(nown,p-&gt;p,p==p-&gt;p-&gt;son[<span class="dv">0</span>]?<span class="dv">0</span>:<span class="dv">1</span>);
    <span class="dt">int</span> i=(nown==p-&gt;son[<span class="dv">0</span>])?<span class="dv">0</span>:<span class="dv">1</span>;
    plant(nown-&gt;son[i^<span class="dv">1</span>],p,i);
    plant(p,nown,i^<span class="dv">1</span>);
    push_up(p);
    push_up(nown);
}

<span class="dt">void</span> splay(node *nown,node* &amp;r)<span class="co">//splay操作，把nown伸展到根r</span>
{
    <span class="kw">while</span>(nown!=r)
    {
        <span class="kw">if</span>(nown-&gt;p==r)rotate(nown);
        <span class="kw">else</span>
        {
            <span class="dt">int</span> i=(nown-&gt;p==nown-&gt;p-&gt;p-&gt;son[<span class="dv">0</span>])?<span class="dv">0</span>:<span class="dv">1</span>;
            <span class="dt">int</span> j=(nown==nown-&gt;p-&gt;son[<span class="dv">0</span>])?<span class="dv">0</span>:<span class="dv">1</span>;
            <span class="kw">if</span>(i^j)rotate(nown);
            <span class="kw">else</span> rotate(nown-&gt;p);
            rotate(nown);
        }
    }
}

<span class="dt">void</span> insert(node *nown,<span class="dt">int</span> k)<span class="co">//把树nown插入到位置k</span>
{
    <span class="kw">if</span>(root==nil)
    {
        root=nown;
        <span class="kw">return</span>;
    }
    node* p=root;
    <span class="kw">while</span>(<span class="dv">1</span>)
    {
        push_down(p);
        <span class="dt">int</span> i=(k&lt;=p-&gt;son[<span class="dv">0</span>]-&gt;size)?<span class="dv">0</span>:<span class="dv">1</span>;
        <span class="kw">if</span>(p-&gt;son[i]==nil)
        {
            plant(nown,p,i);
            <span class="kw">break</span>;
        }
        <span class="kw">if</span>(i)k-=p-&gt;son[<span class="dv">0</span>]-&gt;size<span class="dv">+1</span>;
        p=p-&gt;son[i];
    }
    push_up_parents(nown);
    push_down(nown);
    splay(nown,root);
}

node *kth_node(<span class="dt">int</span> k)<span class="co">//返回第k个数的节点,并旋转至根</span>
{
    node *nown=root;
    <span class="kw">while</span>(nown!=nil)
    {
        push_down(nown);
        <span class="kw">if</span>(nown-&gt;son[<span class="dv">0</span>]-&gt;size==k)
        {
            splay(nown,root);
            <span class="kw">return</span> nown;
        }
        <span class="kw">else</span>
        {
            <span class="dt">int</span> i=(k&lt;nown-&gt;son[<span class="dv">0</span>]-&gt;size)?<span class="dv">0</span>:<span class="dv">1</span>;
            <span class="kw">if</span>(i)k-=nown-&gt;son[<span class="dv">0</span>]-&gt;size<span class="dv">+1</span>;
            nown=nown-&gt;son[i];
        }
    }
    <span class="kw">return</span> nil;
}

node *interval_find(<span class="dt">int</span> l,<span class="dt">int</span> r)<span class="co">//返回一棵splay树，包含区间[l,r]的节点</span>
{
    <span class="kw">if</span>(l==<span class="dv">0</span>&amp;&amp;r==root-&gt;size<span class="dv">-1</span>)<span class="kw">return</span> root;
    <span class="kw">else</span> <span class="kw">if</span>(l==<span class="dv">0</span>)
    {
        splay(kth_node(r<span class="dv">+1</span>),root);
        <span class="kw">return</span> root-&gt;son[<span class="dv">0</span>];
    }
    <span class="kw">else</span> <span class="kw">if</span>(r==root-&gt;size<span class="dv">-1</span>)
    {
        splay(kth_node(l<span class="dv">-1</span>),root);
        <span class="kw">return</span> root-&gt;son[<span class="dv">1</span>];
    }
    splay(kth_node(l<span class="dv">-1</span>),root);
    splay(kth_node(r<span class="dv">+1</span>),root-&gt;son[<span class="dv">1</span>]);
    <span class="kw">return</span> root-&gt;son[<span class="dv">1</span>]-&gt;son[<span class="dv">0</span>];
}</code></pre></div>
<h3 id="初始化-3"><span class="header-section-number">1.6.3</span> 初始化</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> init_tree()<span class="co">//初始化</span>
{
    top=<span class="dv">0</span>;
    nil=new_node();
    nil-&gt;size=<span class="dv">0</span>;
    root=nil;
}</code></pre></div>
<h3 id="可使用函数"><span class="header-section-number">1.6.4</span> 可使用函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> insert(<span class="dt">int</span> x,<span class="dt">int</span> k)<span class="co">//把x插入到位置k</span>
{
    node *nown=new_node();
    nown-&gt;num=x;
    nown-&gt;size=<span class="dv">1</span>;
    nown-&gt;lazy=<span class="dv">0</span>;
    nown-&gt;lazyr=<span class="kw">false</span>;
    nown-&gt;maxnum=x;
    nown-&gt;son[<span class="dv">0</span>]=nown-&gt;son[<span class="dv">1</span>]=nil;
    insert(nown,k);
}

<span class="dt">int</span> kth(<span class="dt">int</span> k)<span class="co">//返回第k个数的值</span>
{
    <span class="kw">return</span> kth_node(k)-&gt;num;
}

node* erase(<span class="dt">int</span> l,<span class="dt">int</span> r)<span class="co">//删除区间[l,r],并返回被删除的树的根</span>
{
    node *nown=interval_find(l,r);
    <span class="kw">if</span>(nown==root)root=nil;
    <span class="kw">else</span>
    {
        <span class="kw">if</span>(nown==nown-&gt;p-&gt;son[<span class="dv">0</span>])nown-&gt;p-&gt;son[<span class="dv">0</span>]=nil;
        <span class="kw">else</span> nown-&gt;p-&gt;son[<span class="dv">1</span>]=nil;
        push_up_parents(nown);
    }
    <span class="kw">return</span> nown;
}

<span class="dt">void</span> flip(<span class="dt">int</span> l,<span class="dt">int</span> r)<span class="co">//把区间[l,r]的数翻转</span>
{
    node *nown=interval_find(l,r);
    nown-&gt;lazyr=!nown-&gt;lazyr;
}

<span class="dt">void</span> add_num(<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> x)<span class="co">//把区间[l,r]的数都加x</span>
{
    node *nown=interval_find(l,r);
    nown-&gt;lazy+=x;
    push_up_parents(nown);
}

<span class="dt">void</span> cut(<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> k)<span class="co">//把区间[l,r]的数裁剪下来，并放到剩下树的第k个位置</span>
{
    node *nown=erase(l,r);
    insert(nown,k);
}

<span class="dt">int</span> max_num(<span class="dt">int</span> l,<span class="dt">int</span> r)
{
    node *nown=interval_find(l,r);
    push_down(nown);
    <span class="kw">return</span> nown-&gt;maxnum;
}</code></pre></div>
<h3 id="使用方法-1"><span class="header-section-number">1.6.5</span> 使用方法</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">insert(x,k);<span class="co">//把x插入到第k个位置，建树只用循环插入就行了O(n)!</span>
erase(l,r);<span class="co">//删除区间[l,r],如果想删第k个数，只用erase(k,k);</span>
kth(k);<span class="co">//返回第k个数的值</span>
flip(l,r);<span class="co">//翻转区间[l,r]</span>
add_num(l,r,x);<span class="co">//把区间[l,r]都加上x</span>
<span class="co">/*若想要把区间都赋成某个值或者都乘上一个数，添加对应懒惰标记,</span>
<span class="co">修改push_down,insert函数并创建对应的修改函数*/</span>
max_num(l,r);<span class="co">//查找区间[l,r]最大值</span>
<span class="co">/*若想维护区间和或最小值等，添加对应成员变量,修改push_down,</span>
<span class="co">push_up,insert函数并创建对应的修改函数*/</span></code></pre></div>
<h2 id="可持久化线段树"><span class="header-section-number">1.7</span> 可持久化线段树</h2>
<h3 id="全局变量"><span class="header-section-number">1.7.1</span> 全局变量</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MAXM 6666666</span><span class="co">//插入次数*log(表示范围)</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> Tree{
    <span class="dt">int</span> num;
    <span class="dt">int</span> lson;
    <span class="dt">int</span> rson;
}tree[MAXM];<span class="co">//线段树</span>
<span class="dt">int</span> top;</code></pre></div>
<h3 id="主要代码"><span class="header-section-number">1.7.2</span> 主要代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> treeInit()
{
    tree[<span class="dv">0</span>].num=tree[<span class="dv">0</span>].lson=tree[<span class="dv">0</span>].rson=<span class="dv">0</span>;<span class="co">//用0节点表示NULL,便于处理</span>
    top=<span class="dv">1</span>;
}

<span class="dt">int</span> treeAdd(<span class="dt">int</span> ori,<span class="dt">int</span> left,<span class="dt">int</span> right,<span class="dt">int</span> x,<span class="dt">int</span> a)
{<span class="co">//在ori[left,right]树上x位置加a,并返回新的根</span>
    <span class="dt">int</span> nown=top++;
    tree[nown]=tree[ori];
    tree[nown].num+=a;
    <span class="kw">if</span>(left&lt;right)
    {
        <span class="dt">int</span> mid=(left+right)&gt;&gt;<span class="dv">1</span>;
        <span class="kw">if</span>(x&lt;=mid)tree[nown].lson=treeAdd(tree[nown].lson,left,mid,x,a);
        <span class="kw">else</span> tree[nown].rson=treeAdd(tree[nown].rson,mid<span class="dv">+1</span>,right,x,a);
    }
    <span class="kw">return</span> nown;
}

<span class="dt">int</span> treeFind(<span class="dt">int</span> nown,<span class="dt">int</span> left,<span class="dt">int</span> right,<span class="dt">int</span> l,<span class="dt">int</span> r)<span class="co">//查询区间[l,r]</span>
{
    <span class="kw">if</span>(nown==<span class="dv">0</span>)<span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">if</span>(l&lt;=left&amp;&amp;right&lt;=r)<span class="kw">return</span> tree[nown].num;
    <span class="dt">int</span> mid=(left+right)&gt;&gt;<span class="dv">1</span>;
    <span class="dt">int</span> ans=<span class="dv">0</span>;
    <span class="kw">if</span>(l&lt;=mid)ans+=treeFind(tree[nown].lson,left,mid,l,r);
    <span class="kw">if</span>(r&gt;mid)ans+=treeFind(tree[nown].rson,mid<span class="dv">+1</span>,right,l,r);
    <span class="kw">return</span> ans;
}</code></pre></div>
<h3 id="用法"><span class="header-section-number">1.7.3</span> 用法</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//使用前先treeInit()初始化</span>
<span class="dt">int</span> treeAdd(<span class="dt">int</span> ori,<span class="dt">int</span> left,<span class="dt">int</span> right,<span class="dt">int</span> x,<span class="dt">int</span> a)<span class="co">//x位置加a并返回新的根</span>
<span class="dt">int</span> treeFind(<span class="dt">int</span> nown,<span class="dt">int</span> left,<span class="dt">int</span> right,<span class="dt">int</span> l,<span class="dt">int</span> r)<span class="co">//查询区间[l,r]</span>
<span class="co">//需要保证传入x,l,r∈[left,right],并且每次left与right应相同</span></code></pre></div>
<h2 id="舞蹈链"><span class="header-section-number">1.8</span> 舞蹈链</h2>
<p>行列下标皆从1开始</p>
<h3 id="头文件宏全局变量-2"><span class="header-section-number">1.8.1</span> 头文件&amp;宏&amp;全局变量</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> MN = <span class="dv">1005</span>; <span class="co">//最大行数</span>
<span class="dt">const</span> <span class="dt">int</span> MM = <span class="dv">1005</span>; <span class="co">//最大列数</span>
<span class="dt">const</span> <span class="dt">int</span> MNN = MN*MM; <span class="co">//最大点数</span></code></pre></div>
<h3 id="精准覆盖"><span class="header-section-number">1.8.2</span> 精准覆盖</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> DLX {
    <span class="dt">int</span> n, m, si; <span class="co">//n行数m列数si目前有的节点数</span>
    <span class="co">//十字链表组成部分</span>
    <span class="dt">int</span> U[MNN], D[MNN], L[MNN], R[MNN], Row[MNN], Col[MNN];
    <span class="co">//第i个结点的U向上指针D下L左R右，所在位置Row行Col列</span>
    <span class="dt">int</span> H[MN], S[MM]; <span class="co">//记录行的选择情况和列的覆盖情况</span>
    <span class="dt">int</span> ansd, ans[MN];
    <span class="dt">void</span> init(<span class="dt">int</span> _n, <span class="dt">int</span> _m) <span class="co">//初始化空表</span>
    {
        n = _n;
        m = _m;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= m; i++) <span class="co">//初始化第一横行（表头）</span>
        {
            S[i] = <span class="dv">0</span>;
            U[i] = D[i] = i; <span class="co">//目前纵向的链是空的</span>
            L[i] = i - <span class="dv">1</span>;
            R[i] = i + <span class="dv">1</span>; <span class="co">//横向的连起来</span>
        }
        R[m] = <span class="dv">0</span>;
        L[<span class="dv">0</span>] = m;
        si = m; <span class="co">//目前用了前0~m个结点</span>
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++)
            H[i] = <span class="dv">-1</span>;
    }
    <span class="dt">void</span> link(<span class="dt">int</span> r, <span class="dt">int</span> c) <span class="co">//插入点(r,c)</span>
    {
        ++S[Col[++si] = c]; <span class="co">//si++;Col[si]=c;S[c]++;</span>
        Row[si] = r;
        D[si] = D[c];
        U[D[c]] = si;
        U[si] = c;
        D[c] = si;
        <span class="kw">if</span> (H[r] &lt; <span class="dv">0</span>)
            H[r] = L[si] = R[si] = si;
        <span class="kw">else</span> {
            R[si] = R[H[r]];
            L[R[H[r]]] = si;
            L[si] = H[r];
            R[H[r]] = si;
        }
    }
    <span class="dt">void</span> remove(<span class="dt">int</span> c) <span class="co">//列表中删掉c列</span>
    {
        L[R[c]] = L[c]; <span class="co">//表头操作</span>
        R[L[c]] = R[c];
        <span class="kw">for</span> (<span class="dt">int</span> i = D[c]; i != c; i = D[i])
            <span class="kw">for</span> (<span class="dt">int</span> j = R[i]; j != i; j = R[j]) {
                U[D[j]] = U[j];
                D[U[j]] = D[j];
                --S[Col[j]];
            }
    }
    <span class="dt">void</span> resume(<span class="dt">int</span> c) <span class="co">//恢复c列</span>
    {
        <span class="kw">for</span> (<span class="dt">int</span> i = U[c]; i != c; i = U[i])
            <span class="kw">for</span> (<span class="dt">int</span> j = L[i]; j != i; j = L[j])
                ++S[Col[U[D[j]] = D[U[j]] = j]];
        L[R[c]] = R[L[c]] = c;
    }

    <span class="co">// HUST-1017</span>
    <span class="co">//仅仅判断有无解</span>
    <span class="dt">bool</span> dance(<span class="dt">int</span> d) <span class="co">//选取了d行</span>
    {
        <span class="kw">if</span> (R[<span class="dv">0</span>] == <span class="dv">0</span>) <span class="co">//全部覆盖了</span>
        {
            <span class="co">//全覆盖了之后的操作</span>
            ansd = d;
            <span class="kw">return</span> <span class="dv">1</span>;
        }
        <span class="dt">int</span> c = R[<span class="dv">0</span>];
        <span class="kw">for</span> (<span class="dt">int</span> i = R[<span class="dv">0</span>]; i != <span class="dv">0</span>; i = R[i])
            <span class="kw">if</span> (S[i] &lt; S[c])
                c = i;
        remove(c);
        <span class="kw">for</span> (<span class="dt">int</span> i = D[c]; i != c; i = D[i]) {
            ans[d] = Row[i];
            <span class="kw">for</span> (<span class="dt">int</span> j = R[i]; j != i; j = R[j])
                remove(Col[j]);
            <span class="kw">if</span> (dance(d + <span class="dv">1</span>))
                <span class="kw">return</span> <span class="dv">1</span>;
            <span class="kw">for</span> (<span class="dt">int</span> j = L[i]; j != i; j = L[j])
                resume(Col[j]);
        }
        resume(c);
        <span class="kw">return</span> <span class="dv">0</span>;
    }
    
    <span class="co">//ZOJ 3209</span>
    <span class="co">//求最小解</span>
    <span class="dt">void</span> danceLeast(<span class="dt">int</span> d) <span class="co">//选取了d行</span>
    {
        <span class="kw">if</span> (ansd != <span class="dv">-1</span> &amp;&amp; ansd &lt;= d) <span class="kw">return</span>;
        <span class="kw">if</span> (R[<span class="dv">0</span>] == <span class="dv">0</span>) <span class="co">//全部覆盖了</span>
        {
            <span class="co">//全覆盖了之后的操作</span>
            <span class="kw">if</span> (ansd == <span class="dv">-1</span>)
                ansd = d;
            <span class="kw">else</span> <span class="kw">if</span> (d &lt; ansd)
                ansd = d;
            <span class="kw">return</span>;
        }
        <span class="dt">int</span> c = R[<span class="dv">0</span>];
        <span class="kw">for</span> (<span class="dt">int</span> i = R[<span class="dv">0</span>]; i != <span class="dv">0</span>; i = R[i])
            <span class="kw">if</span> (S[i] &lt; S[c])
                c = i;
        remove(c);
        <span class="kw">for</span> (<span class="dt">int</span> i = D[c]; i != c; i = D[i]) {
            ans[d] = Row[i];
            <span class="kw">for</span> (<span class="dt">int</span> j = R[i]; j != i; j = R[j])
                remove(Col[j]);
            danceLeast(d + <span class="dv">1</span>);
            <span class="kw">for</span> (<span class="dt">int</span> j = L[i]; j != i; j = L[j])
                resume(Col[j]);
        }
        resume(c);
    }
} dlx; </code></pre></div>
<h3 id="重复覆盖"><span class="header-section-number">1.8.3</span> 重复覆盖</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> DLX {<span class="co">//成员变量，init(),link()同上</span>
    <span class="dt">void</span> remove(<span class="dt">int</span> c) <span class="co">//列表中删掉c列</span>
    {
        <span class="kw">for</span>(<span class="dt">int</span> i = D[c];i != c;i = D[i])
             L[R[i]] = L[i], R[L[i]] = R[i];
    }
    <span class="dt">void</span> resume(<span class="dt">int</span> c) <span class="co">//恢复c列</span>
    {
        <span class="kw">for</span>(<span class="dt">int</span> i = U[c];i != c;i = U[i])
             L[R[i]]=R[L[i]]=i;
    }
    
    <span class="dt">bool</span> v[MNN];
    <span class="dt">int</span> f()
    {
        <span class="dt">int</span> ret = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> c = R[<span class="dv">0</span>];c != <span class="dv">0</span>;c = R[c])v[c] = <span class="kw">true</span>;
        <span class="kw">for</span>(<span class="dt">int</span> c = R[<span class="dv">0</span>];c != <span class="dv">0</span>;c = R[c])
            <span class="kw">if</span>(v[c])
            {
                ret++;
                v[c] = <span class="kw">false</span>;
                <span class="kw">for</span>(<span class="dt">int</span> i = D[c];i != c;i = D[i])
                    <span class="kw">for</span>(<span class="dt">int</span> j = R[i];j != i;j = R[j])
                        v[Col[j]] = <span class="kw">false</span>;
            }
        <span class="kw">return</span> ret;

    }

    <span class="co">//HDU 2295</span>
    <span class="co">//是否有解</span>
    <span class="dt">bool</span> dance(<span class="dt">int</span> d)
    {
        <span class="kw">if</span>(d + f() &gt; K)<span class="kw">return</span> <span class="kw">false</span>; <span class="co">//此处K为题目要求最多能选择的数量</span>
        <span class="kw">if</span>(R[<span class="dv">0</span>] == <span class="dv">0</span>)<span class="kw">return</span> d &lt;= K;
        <span class="dt">int</span> c = R[<span class="dv">0</span>];
        <span class="kw">for</span>(<span class="dt">int</span> i = R[<span class="dv">0</span>];i != <span class="dv">0</span>;i = R[i])
            <span class="kw">if</span>(S[i] &lt; S[c])
                c = i;
        <span class="kw">for</span>(<span class="dt">int</span> i = D[c];i != c;i = D[i])
        {
            remove(i);
            <span class="kw">for</span>(<span class="dt">int</span> j = R[i];j != i;j = R[j])remove(j);
            <span class="kw">if</span>(Dance(d<span class="dv">+1</span>))<span class="kw">return</span> <span class="kw">true</span>;
            <span class="kw">for</span>(<span class="dt">int</span> j = L[i];j != i;j = L[j])resume(j);
            resume(i);
        }
        <span class="kw">return</span> <span class="kw">false</span>;
    }

    <span class="co">//FZU 1686</span>
    <span class="co">//求最小解</span>
    <span class="dt">void</span> danceLeast(<span class="dt">int</span> d) {
        <span class="kw">if</span> (d + f() &gt;= ansd) <span class="kw">return</span>;
        <span class="kw">if</span> (R[<span class="dv">0</span>] == <span class="dv">0</span>) <span class="co">//全部覆盖了</span>
        {
            <span class="co">//全覆盖了之后的操作</span>
            <span class="kw">if</span> (d &lt; ansd)
                ansd = d;
            <span class="kw">return</span>;
        }
        <span class="dt">int</span> c = R[<span class="dv">0</span>];
        <span class="kw">for</span> (<span class="dt">int</span> i = R[<span class="dv">0</span>]; i != <span class="dv">0</span>; i = R[i])
            <span class="kw">if</span> (S[i] &lt; S[c])
                c = i;
        <span class="kw">for</span> (<span class="dt">int</span> i = D[c]; i != c; i = D[i]) {
            remove(i);
            <span class="kw">for</span> (<span class="dt">int</span> j = R[i]; j != i; j = R[j])
                remove(j);
            danceLeast(d + <span class="dv">1</span>);
            <span class="kw">for</span> (<span class="dt">int</span> j = L[i]; j != i; j = L[j])
                resume(j);
            resume(i);
        }
    }
} dlx;</code></pre></div>
<h1 id="字符串"><span class="header-section-number">2</span> 字符串</h1>
<h2 id="最小循环表示"><span class="header-section-number">2.1</span> 最小循环表示</h2>
<h3 id="代码"><span class="header-section-number">2.1.1</span> 代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//最小循环表示</span>
<span class="co">//input: str[2*len] 原串扩展了一倍的串。如原串为“abc”， str为“abcabc”。</span>
<span class="co">//         len 原串的长度。</span>
<span class="co">//output：ptr 最小循环表示法的起始下标。</span>
<span class="dt">int</span> min_representation(<span class="dt">int</span> len){
    <span class="dt">int</span> i = <span class="dv">0</span>, j = <span class="dv">1</span>, k = <span class="dv">0</span>;
    <span class="kw">while</span>(i &lt; len &amp;&amp; j &lt; len &amp;&amp; k &lt; len){
        <span class="kw">if</span>(str[i+k] == str[j+k])k++;
        <span class="kw">else</span>{
            <span class="kw">if</span>(str[i+k] &lt; str[j+k]) j += k<span class="dv">+1</span>;
            <span class="kw">else</span> i += k<span class="dv">+1</span>;
            k = <span class="dv">0</span>;
            <span class="kw">if</span>(i == j)j++;
        }
    }
    <span class="kw">return</span> min(i, j);
}</code></pre></div>
<h2 id="最长回文manacher"><span class="header-section-number">2.2</span> 最长回文Manacher</h2>
<h3 id="代码-1"><span class="header-section-number">2.2.1</span> 代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> MAXN = <span class="dv">111234</span>;

<span class="dt">char</span> orign[MAXN], str[<span class="dv">2</span> * MAXN]; <span class="co">//字符串</span>
<span class="dt">int</span> radius[<span class="dv">2</span> * MAXN];            <span class="co">//对称轴为i的最长回文半径</span>

<span class="co">//orign:初始字符串、str:插入间隔符的字符串（长度为orign的两倍加一）</span>
<span class="co">//raidus:对称轴为i的最长回文半径、mark:间隔符</span>
<span class="dt">int</span> Manacher(<span class="dt">char</span> *orign, <span class="dt">char</span> *str, <span class="dt">int</span> *radius, <span class="dt">char</span> mark) {
    <span class="co">//------------插入间隔符------------</span>
    <span class="dt">int</span> len = strlen(orign);
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len; i++) {
        str[<span class="dv">2</span> * i + <span class="dv">1</span>] = orign[i];
        str[<span class="dv">2</span> * i] = mark;
    }
    str[<span class="dv">2</span> * len] = mark;
    str[<span class="dv">2</span> * len + <span class="dv">1</span>] = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>;
    len = <span class="dv">2</span> * len + <span class="dv">1</span>;
    <span class="co">//------------插入间隔符------------</span>

    <span class="dt">int</span> ans = <span class="dv">2</span>; <span class="co">//答案至少为2，即至少为 #a# 形式</span>
    <span class="dt">int</span> max_right = <span class="dv">0</span>, pos = <span class="dv">0</span>;
    <span class="co">// max_right表示当前已知所有回文串右端点最大值，pos表示该回文的对称轴</span>
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len; i++) {
        <span class="kw">if</span> (i &lt; max_right)
            radius[i] = min(radius[<span class="dv">2</span> * pos - i], max_right - i);
        <span class="kw">else</span>
            radius[i] = <span class="dv">1</span>;
        <span class="co">//判断边界、对应字符是否相等</span>
        <span class="kw">while</span>(i-radius[i] &gt;= <span class="dv">0</span> &amp;&amp; i+radius[i] &lt; len 
                &amp;&amp; str[i-radius[i]] == str[i+radius[i]]){
            radius[i]++;
        }
        ans = max(ans, radius[i]);
        <span class="co">//更新max_right、pos</span>
        <span class="kw">if</span> (i + radius[i] - <span class="dv">1</span> &gt; max_right) {
            max_right = i + radius[i] - <span class="dv">1</span>;
            pos = i;
        }
    }
    <span class="kw">return</span> ans - <span class="dv">1</span>;
}</code></pre></div>
<h2 id="kmp"><span class="header-section-number">2.3</span> KMP</h2>
<h3 id="宏全局变量"><span class="header-section-number">2.3.1</span> 宏&amp;全局变量</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MAXN 6666666</span>

<span class="dt">int</span> nextn[MAXN];</code></pre></div>
<h3 id="核心代码"><span class="header-section-number">2.3.2</span> 核心代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> initNext(<span class="dt">const</span> <span class="dt">char</span> *pattern)
{
    nextn[<span class="dv">0</span>]=<span class="dv">-1</span>;
    <span class="dt">int</span> i=<span class="dv">0</span>,j=<span class="dv">-1</span>;
    <span class="kw">while</span>(pattern[i])
    {
        <span class="kw">while</span>(j!=<span class="dv">-1</span>&amp;&amp;pattern[i]!=pattern[j])j=nextn[j];
        i++;
        j++;
        nextn[i]=j;
    }
}

<span class="dt">int</span> kmp(<span class="dt">const</span> <span class="dt">char</span> *s,<span class="dt">const</span> <span class="dt">char</span> *pattern,<span class="dt">bool</span> flag=<span class="kw">true</span>)
{
    <span class="kw">if</span>(flag)initNext(pattern);
    <span class="dt">int</span> i=<span class="dv">0</span>,j=<span class="dv">0</span>,cnt=<span class="dv">0</span>;
    <span class="kw">while</span>(s[i])
    {
        <span class="kw">while</span>(j!=<span class="dv">-1</span>&amp;&amp;s[i]!=pattern[j])j=nextn[j];
        i++;
        j++;
        <span class="kw">if</span>(!pattern[j])cnt++;
    } 
    <span class="kw">return</span> cnt;
}</code></pre></div>
<h2 id="ac自动机"><span class="header-section-number">2.4</span> AC自动机</h2>
<h3 id="头文件宏全局变量-3"><span class="header-section-number">2.4.1</span> 头文件&amp;宏&amp;全局变量</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;queue&gt;</span>

<span class="ot">#define MAXN 666666</span>
<span class="ot">#define MAXK 26</span><span class="co">//字符数量</span>

<span class="kw">struct</span> Node{
    Node *son[MAXK];
    Node *fail;
    <span class="dt">int</span> num;<span class="co">//以此节点为末尾的模式串数量</span>
    <span class="dt">bool</span> flag;<span class="co">//去重用,可选</span>
}node[MAXN],*root,*top;
queue&lt;Node*&gt;q;<span class="co">//建立自动机时使用</span></code></pre></div>
<h3 id="辅助函数-3"><span class="header-section-number">2.4.2</span> 辅助函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> mapToK(<span class="dt">char</span> c)<span class="co">//把字符隐射到0~MAXK-1</span>
{
    <span class="kw">return</span> c-<span class="st">&#39;a&#39;</span>;
}

Node *newNode()
{
    memset(top-&gt;son,<span class="dv">0</span>,<span class="kw">sizeof</span>(top-&gt;son));
    top-&gt;num=<span class="dv">0</span>;
    <span class="kw">return</span> top++;
}

<span class="dt">void</span> initNode()<span class="co">//初始化节点分配</span>
{
    top=node;
    root=newNode();
}</code></pre></div>
<h3 id="主要函数-1"><span class="header-section-number">2.4.3</span> 主要函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> addPattern(<span class="dt">char</span> *s)<span class="co">//添加模式串</span>
{
    Node *nown=root;
    <span class="kw">while</span>(*s)
    {
        <span class="dt">int</span> k=mapToK(*s);
        <span class="kw">if</span>(!nown-&gt;son[k])nown-&gt;son[k]=newNode();
        nown=nown-&gt;son[k];
        s++;
    }
    nown-&gt;num++;
}

<span class="dt">void</span> buildACAutoMaton()<span class="co">//计算fail</span>
{
    root-&gt;fail=<span class="kw">nullptr</span>;
    q.push(root);
    <span class="kw">while</span>(!q.empty())
    {
        Node *nown=q.front();q.pop();
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;MAXK;i++)
        {
            <span class="kw">if</span>(nown-&gt;son[i])
            {
                Node *p=nown-&gt;fail;
                <span class="kw">while</span>(p&amp;&amp;!p-&gt;son[i])p=p-&gt;fail;
                nown-&gt;son[i]-&gt;fail=p?p-&gt;son[i]:root;
                q.push(nown-&gt;son[i]);
            }
        }
    }
}</code></pre></div>
<h3 id="可选参考函数"><span class="header-section-number">2.4.4</span> 可选参考函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> initFlag()<span class="co">//初始化去重标记</span>
{
    root-&gt;flag=<span class="kw">false</span>;
    <span class="kw">for</span>(Node *i=root<span class="dv">+1</span>;i&lt;top;i++)
        i-&gt;flag=<span class="kw">true</span>;
}

<span class="dt">int</span> match(<span class="dt">char</span> *s)<span class="co">//返回匹配次数</span>
{
    initFlag();
    Node *nown=root;
    <span class="dt">int</span> ans=<span class="dv">0</span>;
    <span class="kw">while</span>(*s)
    {
        <span class="dt">int</span> k=mapToK(*s);
        <span class="kw">while</span>(nown&amp;&amp;!nown-&gt;son[k])nown=nown-&gt;fail;
        nown=nown?nown-&gt;son[k]:root;
        <span class="kw">for</span>(Node *i=nown;i-&gt;flag;i=i-&gt;fail)
        {
            ans+=i-&gt;num;
            i-&gt;flag=<span class="kw">false</span>;
        }
        s++;
    }
    <span class="kw">return</span> ans;
}</code></pre></div>
<h3 id="用法-1"><span class="header-section-number">2.4.5</span> 用法</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//先initNode();初始化</span>
<span class="co">//然后addPattern添加模式串</span>
<span class="co">//最后buildACAutoMaton</span></code></pre></div>
<h2 id="后缀数组"><span class="header-section-number">2.5</span> 后缀数组</h2>
<h3 id="宏全局变量-1"><span class="header-section-number">2.5.1</span> 宏&amp;全局变量</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MAXN 666666</span><span class="co">//大于字符串长度二倍</span>

<span class="dt">int</span> krank[MAXN];<span class="co">//第i个元素是第几大 1~n</span>
<span class="dt">int</span> SA[MAXN];<span class="co">//第i大的元素在原数组中位置 1~n</span>
<span class="dt">int</span> height[MAXN];
<span class="dt">int</span> *<span class="dt">const</span> tmp=height;<span class="co">//一开始height没用,使用它当tmp</span>
<span class="dt">int</span> cnt[MAXN];<span class="co">//用于基数排序,统计</span>
<span class="dt">int</span> st[MAXN][<span class="dv">30</span>];<span class="co">//st表</span>
<span class="dt">int</span> LOG[MAXN];<span class="co">//log表</span></code></pre></div>
<h3 id="辅助函数-4"><span class="header-section-number">2.5.2</span> 辅助函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> initHeight(<span class="dt">char</span> *s,<span class="dt">int</span> n)<span class="co">//计算height数组</span>
{
    <span class="dt">int</span> j,k=<span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;height[krank[i++]]=k)
        <span class="kw">for</span>(k=max(k<span class="dv">-1</span>,<span class="dv">0</span>),j=SA[krank[i]<span class="dv">-1</span>];krank[i]&gt;<span class="dv">1</span>&amp;&amp;s[i+k<span class="dv">-1</span>]==s[j+k<span class="dv">-1</span>];k++)
            ;
}

<span class="dt">void</span> initLOG()
{
    <span class="kw">if</span>(LOG[<span class="dv">0</span>]==<span class="dv">-1</span>)<span class="kw">return</span>;
    LOG[<span class="dv">0</span>]=<span class="dv">-1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;MAXN;i++)
        LOG[i]=(i&amp;(i<span class="dv">-1</span>))?LOG[i<span class="dv">-1</span>]:LOG[i<span class="dv">-1</span>]<span class="dv">+1</span>;
}

<span class="dt">void</span> initSt(<span class="dt">int</span> n)
{
    initLOG();
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++)st[i][<span class="dv">0</span>]=height[i<span class="dv">+1</span>];
    <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">1</span>;(<span class="dv">1</span>&lt;&lt;j)&lt;=n;j++)
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i+(<span class="dv">1</span>&lt;&lt;j)&lt;=n;i++)
            st[i][j]=min(st[i][j<span class="dv">-1</span>],st[i+(<span class="dv">1</span>&lt;&lt;(j<span class="dv">-1</span>))][j<span class="dv">-1</span>]);
}

<span class="dt">bool</span> comp(<span class="dt">int</span> n,<span class="dt">int</span> a,<span class="dt">int</span> b,<span class="dt">int</span> w)
{
    <span class="co">//判断a和b,a+w和b+w的第一关键字是否对应相等</span>
    <span class="kw">if</span>(tmp[a]==tmp[b])
    {
        <span class="kw">if</span>(a+w&gt;n||b+w&gt;n)
        {
            <span class="kw">if</span>(a+w&gt;n&amp;&amp;b+w&gt;n)<span class="kw">return</span> <span class="kw">true</span>;
            <span class="kw">return</span> <span class="kw">false</span>;
        }
        <span class="kw">if</span>(tmp[a+w]==tmp[b+w])<span class="kw">return</span> <span class="kw">true</span>;
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">bool</span> rSort(<span class="dt">int</span> n,<span class="dt">int</span> &amp;m,<span class="dt">int</span> w)
{
    <span class="co">//krank当作第一关键字，tmp相当于第二关键字的SA</span>
    <span class="co">//此时第二关键字已有序,顺序是tmp</span>
    memset(cnt<span class="dv">+1</span>,<span class="dv">0</span>,m*<span class="kw">sizeof</span>(cnt[<span class="dv">0</span>]));
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)cnt[krank[i]]++;<span class="co">//统计</span>
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;=m;i++)cnt[i]+=cnt[i<span class="dv">-1</span>];
    <span class="kw">for</span>(<span class="dt">int</span> i=n;i;i--)<span class="co">//比其第一关键字小的数量就是其新位置</span>
        SA[cnt[krank[tmp[i]]]--]=tmp[i];

    <span class="co">//用tmp的空间暂存rank</span>
    memcpy(tmp<span class="dv">+1</span>,krank<span class="dv">+1</span>,n*<span class="kw">sizeof</span>(krank[<span class="dv">0</span>]));
    krank[SA[<span class="dv">1</span>]]=m=<span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;=n;i++)<span class="co">//生成新的rank</span>
        krank[SA[i]]=comp(n,SA[i],SA[i<span class="dv">-1</span>],w)?m:++m;
    <span class="kw">return</span> m&gt;=n;<span class="co">//分为n类,排序完成</span>

}</code></pre></div>
<h3 id="主要函数-2"><span class="header-section-number">2.5.3</span> 主要函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> initSA(<span class="dt">char</span> *s,<span class="dt">int</span> n)<span class="co">//初始化后缀数组</span>
{
    <span class="dt">int</span> m=<span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)
    {
        krank[i]=s[i<span class="dv">-1</span>];
        m=max(m,krank[i]);
        tmp[i]=i;
    }
    <span class="dt">int</span> w=<span class="dv">0</span>;
    <span class="kw">while</span>(!rSort(n,m,w))
    {
        <span class="kw">if</span>(w)w&lt;&lt;=<span class="dv">1</span>;
        <span class="kw">else</span> w=<span class="dv">1</span>;
        <span class="co">//重新计算tmp</span>
        <span class="dt">int</span> top=<span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i=n-w<span class="dv">+1</span>;i&lt;=n;i++)tmp[++top]=i;<span class="co">//越界的最小</span>
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)
            <span class="kw">if</span>(SA[i]&gt;w)<span class="co">//不越界的从小到大排</span>
                tmp[++top]=SA[i]-w;
    }
    initHeight(s,n);
    initSt(n);
}

<span class="dt">int</span> calcLCP(<span class="dt">int</span> l,<span class="dt">int</span> r)<span class="co">//后缀l到后缀r的最长公共前缀</span>
{
    l=krank[l];r=krank[r];
    <span class="kw">if</span>(l&gt;r)swap(l,r);
    <span class="dt">int</span> k=LOG[r-l];
    <span class="kw">return</span> min(st[l][k],st[r-(<span class="dv">1</span>&lt;&lt;k)][k]);
}</code></pre></div>
<h3 id="用法-2"><span class="header-section-number">2.5.4</span> 用法</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//调用initSA后height,SA,krank数组都计算好了</span>
<span class="co">//下标都从1开始</span>
<span class="co">//调用calcLCP计算LCP,不需要可以去掉LOG表和st表</span></code></pre></div>
<h1 id="图论"><span class="header-section-number">3</span> 图论</h1>
<h2 id="最短路"><span class="header-section-number">3.1</span> 最短路</h2>
<h3 id="dijkstra配对堆优化"><span class="header-section-number">3.1.1</span> dijkstra配对堆优化</h3>
<p>复杂度<span class="math inline">\(\Theta \left ( m \right )\)</span></p>
<h4 id="头文件宏全局变量-4"><span class="header-section-number">3.1.1.1</span> 头文件&amp;宏&amp;全局变量</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;ext/pb_ds/priority_queue.hpp&gt;</span>

<span class="ot">#define MAXN 666</span>
<span class="ot">#define MAXM 6666666</span>
<span class="ot">#define INF 0x3f3f3f3f</span>

<span class="kw">struct</span> Edge{
    <span class="dt">int</span> to;
    <span class="dt">int</span> v;
    <span class="dt">int</span> next;
}edge[MAXM];
<span class="dt">int</span> head[MAXN];
<span class="dt">int</span> top;

<span class="kw">typedef</span> __gnu_pbds::priority_queue&lt;pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt;,greater&lt;pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt;&gt;
,__gnu_pbds::pairing_heap_tag&gt;
Heap;

Heap heap;
Heap::point_iterator pit[MAXN];</code></pre></div>
<h4 id="初始化加边"><span class="header-section-number">3.1.1.2</span> 初始化&amp;加边</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> initEdge()
{
    memset(head,<span class="dv">-1</span>,<span class="kw">sizeof</span>(head));
    top=<span class="dv">0</span>;
}

<span class="dt">void</span> addEdge(<span class="dt">int</span> a,<span class="dt">int</span> b,<span class="dt">int</span> v)
{
    edge[top].to=b;
    edge[top].v=v;
    edge[top].next=head[a];
    head[a]=top++;
}</code></pre></div>
<h4 id="核心代码-1"><span class="header-section-number">3.1.1.3</span> 核心代码</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> dijkstra(<span class="dt">int</span> n,<span class="dt">int</span> S,<span class="dt">int</span> dist[])<span class="co">//点标号从0开始</span>
{
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++)
        dist[i]=INF;
    dist[S]=<span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++)
        pit[i]=heap.push(make_pair(dist[i],i));
    <span class="kw">while</span>(!heap.empty())
    {
        <span class="dt">int</span> nown=heap.top().second;heap.pop();
        <span class="kw">for</span>(<span class="dt">int</span> i=head[nown];i!=<span class="dv">-1</span>;i=edge[i].next)
            <span class="kw">if</span>(dist[edge[i].to]&gt;dist[nown]+edge[i].v)
                heap.modify(pit[edge[i].to],
                                make_pair(dist[edge[i].to]=dist[nown]+edge[i].v,
                                          edge[i].to));
    }
}</code></pre></div>
<h2 id="差分约束"><span class="header-section-number">3.2</span> 差分约束</h2>
<ul>
<li>第一：
<ul>
<li>感觉难点在于建图</li>
</ul></li>
<li>第二：
<ul>
<li>①：对于差分不等式，a - b &lt;= c ，建一条 b 到 a 的权值为 c 的边，求的是最短路，得到的是最大值<br />
</li>
<li>②：对于不等式 a - b &gt;= c ，建一条 b 到 a 的权值为 c 的边，求的是最长路，得到的是最小值<br />
</li>
<li>③：存在负环的话是无解<br />
</li>
<li>④：求不出最短路（dist[ ]没有得到更新）的话是任意解</li>
</ul></li>
<li><p>第三：</p>
<ul>
<li>一种建图方法：<br />
设x[i]是第i位置（或时刻）的值（跟所求值的属性一样），那么把x[i]看成数列，前n项和为s[n]，则x[i] = s[i] - s[i-1]；<br />
那么这样就可以最起码建立起类似这样的一个关系：0 &lt;= s[i] - s[i-1] &lt;= 1;</li>
</ul></li>
</ul>
<h2 id="最大权匹配kuhn-munkres"><span class="header-section-number">3.3</span> 最大权匹配Kuhn-Munkres</h2>
<p>复杂度<span class="math inline">\(O(n^{2}m)\)</span></p>
<h3 id="头文件宏结构体全局变量"><span class="header-section-number">3.3.1</span> 头文件&amp;宏&amp;结构体&amp;全局变量</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MAXN 666</span>
<span class="ot">#define MAXM 666666</span>
<span class="ot">#define INF 0x3f3f3f3f</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> Edge{
    <span class="dt">int</span> to;
    <span class="dt">int</span> v;
    <span class="dt">int</span> next;
}edge[MAXM];
<span class="dt">int</span> head[MAXN],top;

<span class="dt">int</span> from[MAXN];
<span class="dt">int</span> X[MAXN];
<span class="dt">int</span> Y[MAXN];
<span class="dt">bool</span> visX[MAXN];
<span class="dt">bool</span> visY[MAXN];</code></pre></div>
<h3 id="初始化加边-1"><span class="header-section-number">3.3.2</span> 初始化&amp;加边</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> initEdge()
{
    memset(head,<span class="dv">-1</span>,<span class="kw">sizeof</span>(head));
    top=<span class="dv">0</span>;
}

<span class="dt">void</span> addEdge(<span class="dt">int</span> a,<span class="dt">int</span> b,<span class="dt">int</span> v)<span class="co">//第一个集合的a连向第二个集合的b</span>
{
    edge[top].to=b;
    edge[top].v=v;
    edge[top].next=head[a];
    head[a]=top++;
}</code></pre></div>
<h3 id="辅助函数-5"><span class="header-section-number">3.3.3</span> 辅助函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> dfs(<span class="dt">int</span> nown)<span class="co">//匈牙利找增广路</span>
{
    visX[nown]=<span class="kw">true</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=head[nown];i!=<span class="dv">-1</span>;i=edge[i].next)
    {
        <span class="kw">if</span>(visY[edge[i].to])<span class="kw">continue</span>;
        <span class="kw">if</span>(X[nown]+Y[edge[i].to]!=edge[i].v)<span class="kw">continue</span>;
        visY[edge[i].to]=<span class="kw">true</span>;
        <span class="kw">if</span>(from[edge[i].to]==<span class="dv">-1</span>||dfs(from[edge[i].to]))
        {
            from[edge[i].to]=nown;
            <span class="kw">return</span> <span class="kw">true</span>;
        }
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}</code></pre></div>
<h3 id="核心代码-2"><span class="header-section-number">3.3.4</span> 核心代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> KM(<span class="dt">int</span> n)<span class="co">//n为点数,需保证有完备匹配,标号从0开始</span>
{
    <span class="dt">int</span> ans=<span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++)
    {
        from[i]=<span class="dv">-1</span>;
        Y[i]=<span class="dv">0</span>;
        X[i]=-INF;
        <span class="kw">for</span>(<span class="dt">int</span> j=head[i];j!=<span class="dv">-1</span>;j=edge[j].next)
            X[i]=max(X[i],edge[j].v);
        ans+=X[i];
    }
    <span class="kw">for</span>(<span class="dt">int</span> k=<span class="dv">0</span>;k&lt;n;)
    {
        memset(visX,<span class="dv">0</span>,<span class="kw">sizeof</span>(visX));
        memset(visY,<span class="dv">0</span>,<span class="kw">sizeof</span>(visY));
        <span class="kw">if</span>(dfs(k))k++;
        <span class="kw">else</span>
        {
            <span class="dt">int</span> d=INF;
            <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++)
                <span class="kw">if</span>(visX[i])
                    <span class="kw">for</span>(<span class="dt">int</span> j=head[i];j!=<span class="dv">-1</span>;j=edge[j].next)
                        <span class="kw">if</span>(!visY[edge[j].to])
                            d=min(d,X[i]+Y[edge[j].to]-edge[j].v);
            ans-=d;
            <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++)
            {
                <span class="kw">if</span>(visX[i])X[i]-=d;
                <span class="kw">if</span>(visY[i])Y[i]+=d;
            }
        }
    }
    <span class="kw">return</span> ans;
}</code></pre></div>
<h3 id="用法-3"><span class="header-section-number">3.3.5</span> 用法</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//需保证是二分图且有完备匹配(两边点数相同)</span>
<span class="co">//两边点的标号都从0开始</span>
initEdge();<span class="co">//初始化</span>
<span class="kw">for</span>(each a-&gt;b)addEdge(a,b,v);<span class="co">//加边</span>
<span class="dt">int</span> ans=KM();<span class="co">//求解</span></code></pre></div>
<h2 id="全局最小割sw"><span class="header-section-number">3.4</span> 全局最小割SW</h2>
<p>复杂度 <span class="math inline">\(O(nm)\)</span></p>
<h3 id="头文件宏全局变量-5"><span class="header-section-number">3.4.1</span> 头文件&amp;宏&amp;全局变量</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;ext/pb_ds/priority_queue.hpp&gt;</span>

<span class="ot">#define MAXN 3333</span>
<span class="ot">#define MAXM 444444</span><span class="co">//最好是边数的两倍</span>

<span class="dt">const</span> <span class="dt">long</span> <span class="dt">long</span> INF=<span class="bn">0x3f3f3f3f</span>;

<span class="dt">int</span> n,m;

<span class="kw">struct</span> Edge{
    <span class="dt">long</span> <span class="dt">long</span> v;
    <span class="dt">int</span> to;
    <span class="dt">int</span> next;
    <span class="dt">int</span> re;
}edge[MAXM];<span class="co">//边</span>
<span class="dt">int</span> head[MAXN],top;<span class="co">//邻接链表</span>
<span class="dt">int</span> dist[MAXN];

<span class="kw">typedef</span> __gnu_pbds::priority_queue&lt;pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt;,
    less&lt;pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt;&gt;,__gnu_pbds::pairing_heap_tag
    &gt; Heap;
Heap pq;
Heap::point_iterator pqIterator[MAXN];</code></pre></div>
<h3 id="建图"><span class="header-section-number">3.4.2</span> 建图</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> init()<span class="co">//初始化链表</span>
{
    top=<span class="dv">0</span>;
    memset(head,<span class="dv">-1</span>,<span class="kw">sizeof</span>(head));
}

<span class="dt">void</span> addEdge(<span class="dt">int</span> a,<span class="dt">int</span> b,<span class="dt">long</span> <span class="dt">long</span> v)<span class="co">//a-&gt;b,容量为v的边</span>
{
    <span class="kw">if</span>(v==<span class="dv">0</span>)<span class="kw">return</span>;
    edge[top].v=v;
    edge[top].to=b;
    edge[top].re=top<span class="dv">+1</span>;
    edge[top].next=head[a];
    head[a]=top++;

    edge[top].v=v;
    edge[top].to=a;
    edge[top].re=top<span class="dv">-1</span>;
    edge[top].next=head[b];
    head[b]=top++;
}</code></pre></div>
<h3 id="核心代码-3"><span class="header-section-number">3.4.3</span> 核心代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> findST(<span class="dt">int</span> &amp;s,<span class="dt">int</span> &amp;t)<span class="co">//找到某一s点和t点间最小割</span>
{
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)
    {
        <span class="kw">if</span>(head[i]!=<span class="dv">-2</span>)
        {
            dist[i]=<span class="dv">0</span>;
            pqIterator[i]=pq.push(make_pair(dist[i],i));
        }
    }<span class="co">//初始化</span>
    <span class="kw">while</span>(pq.size()&gt;<span class="dv">1</span>)
    {
        s=pq.top().second;pq.pop();
        pqIterator[s]=pq.end();
        <span class="kw">for</span>(<span class="dt">int</span> j=head[s];j!=<span class="dv">-1</span>;j=edge[j].next)
            <span class="kw">if</span>(pqIterator[edge[j].to]!=pq.end())
                pq.modify(pqIterator[edge[j].to]
                         ,make_pair(dist[edge[j].to]+=edge[j].v
                                    ,edge[j].to));
    }
    t=pq.top().second;pq.pop();
    <span class="kw">return</span> dist[t];<span class="co">//dist[t]为s-t最小割</span>
}

<span class="dt">void</span> merge(<span class="dt">int</span> s,<span class="dt">int</span> t)<span class="co">//合并s和t点</span>
{
    <span class="dt">int</span> i=head[t],next;
    <span class="kw">while</span>(i!=<span class="dv">-1</span>)
    {
        next=edge[i].next;
        edge[i].next=head[s];
        head[s]=i;
        edge[edge[i].re].to=s;
        i=next;
    }
    head[t]=<span class="dv">-2</span>;<span class="co">//标记t被合并</span>
}

<span class="dt">int</span> StoerWagner()
{
    <span class="dt">int</span> mincut=INF,s,t;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;n;i++)<span class="co">//最多合并n-1次</span>
    {
        mincut=min(mincut,findST(s,t));
        <span class="kw">if</span>(mincut==<span class="dv">0</span>)<span class="kw">return</span> <span class="dv">0</span>;<span class="co">//达到下限</span>
        merge(s,t);
    }
    <span class="kw">return</span> mincut;
}</code></pre></div>
<h3 id="用法-4"><span class="header-section-number">3.4.4</span> 用法</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> work()
{
    init();
    <span class="dt">int</span> a,b;
    <span class="dt">long</span> <span class="dt">long</span> v;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;m;i++)
    {
        kread(a,b,v);
        addEdge(a,b,v);
    }
    <span class="kw">return</span> StoerWagner();
}

<span class="dt">int</span> main()
{
    <span class="kw">while</span>(~scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m))printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>,work());
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="网络流dinic"><span class="header-section-number">3.5</span> 网络流Dinic</h2>
<h3 id="头文件全局变量宏"><span class="header-section-number">3.5.1</span> 头文件&amp;全局变量&amp;宏</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;queue&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> MAXN = <span class="dv">6666</span>;
<span class="dt">const</span> <span class="dt">int</span> MAXM=<span class="dv">66666</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="bn">0x3f3f3f3f</span>;

<span class="dt">int</span> S,T;

<span class="dt">int</span> head[MAXN*<span class="dv">2</span>],top;
<span class="dt">int</span> cur[MAXN*<span class="dv">2</span>];
<span class="dt">int</span> level[MAXN*<span class="dv">2</span>];
queue&lt;<span class="dt">int</span>&gt;q;
<span class="kw">struct</span> the_edge{
    <span class="dt">int</span> next;
    <span class="dt">int</span> to;
    <span class="dt">int</span> v;
}edge[MAXM];</code></pre></div>
<h3 id="建图-1"><span class="header-section-number">3.5.2</span> 建图</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> init_edge()
{
    memset(head,<span class="dv">-1</span>,<span class="kw">sizeof</span>(head));
    top=<span class="dv">0</span>;
}

<span class="dt">void</span> add_edge(<span class="dt">int</span> a,<span class="dt">int</span> b,<span class="dt">int</span> v)
{
    edge[top].to=b;
    edge[top].v=v;
    edge[top].next=head[a];
    head[a]=top++;

    edge[top].to=a;
    edge[top].v=<span class="dv">0</span>;
    edge[top].next=head[b];
    head[b]=top++;
}</code></pre></div>
<h3 id="辅助函数-6"><span class="header-section-number">3.5.3</span> 辅助函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> bfs()
{
    memset(level,<span class="dv">-1</span>,<span class="kw">sizeof</span>(level));
    level[S]=<span class="dv">0</span>;
    q.push(S);
    <span class="kw">while</span>(!q.empty())
    {
        <span class="dt">int</span> nown=q.front();q.pop();
        <span class="kw">for</span>(<span class="dt">int</span> i=head[nown];i!=<span class="dv">-1</span>;i=edge[i].next)
        {
            <span class="kw">if</span>(!edge[i].v||level[edge[i].to]!=<span class="dv">-1</span>)<span class="kw">continue</span>;
            level[edge[i].to]=level[nown]<span class="dv">+1</span>;
            q.push(edge[i].to);
        }
    }
    <span class="kw">return</span> level[T]!=<span class="dv">-1</span>;
}

<span class="dt">int</span> dfs(<span class="dt">int</span> nown,<span class="dt">int</span> maxf)
{
    <span class="kw">if</span>(nown==T)<span class="kw">return</span> maxf;
    <span class="dt">int</span> nowf=<span class="dv">0</span>,flow;
    <span class="kw">for</span>(<span class="dt">int</span> &amp;i=cur[nown];i!=<span class="dv">-1</span>;i=edge[i].next)
    {
        <span class="kw">if</span>(!edge[i].v||
            level[edge[i].to]!=level[nown]<span class="dv">+1</span>)<span class="kw">continue</span>;
        <span class="kw">if</span>((flow=dfs(edge[i].to,min(maxf-nowf,edge[i].v)))!=<span class="dv">0</span>)
        {
            nowf+=flow;
            edge[i].v-=flow;
            edge[i^<span class="dv">1</span>].v+=flow;
            <span class="kw">if</span>(nowf==maxf)<span class="kw">return</span> maxf;
        }
    }
    <span class="kw">return</span> nowf;
}</code></pre></div>
<h3 id="核心代码-4"><span class="header-section-number">3.5.4</span> 核心代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> dinic()
{
    <span class="dt">int</span> ans=<span class="dv">0</span>;
    <span class="kw">while</span>(bfs())
    {
        memcpy(cur,head,<span class="kw">sizeof</span>(cur));
        ans+=dfs(S,INF);
    }
    <span class="kw">return</span> ans;
}</code></pre></div>
<h3 id="用法-5"><span class="header-section-number">3.5.5</span> 用法</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//指定MAXN,MAXM</span>
<span class="dt">int</span> main(){
    S=<span class="dv">1</span>;T=n;<span class="co">//指定源点汇点</span>
    init_edge();<span class="co">//初始化边</span>
    ...
    <span class="kw">for</span>(...)
        add_edge(x,y,c);<span class="co">//加边</span>
    ...
    printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>,dinic());
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h3 id="技巧"><span class="header-section-number">3.5.6</span> 技巧</h3>
<h3 id="求割边最小的最小割"><span class="header-section-number">3.5.7</span> 求割边最小的最小割</h3>
<h4 id="方法1"><span class="header-section-number">3.5.7.1</span> 方法1</h4>
<p>建边的时候每条边权 w = w * (E + 1) + 1;<br />
这样得到最大流 maxflow / (E + 1) ，最少割边数 maxflow % (E + 1)</p>
<h4 id="方法2"><span class="header-section-number">3.5.7.2</span> 方法2</h4>
<p>建图，得到最大流后，图中边若满流，说明该边是最小割上的边<br />
再建图，原则：满流的边改为容量为 1 的边，未满流的边改为容量 INF 的边，然后最大流即答案</p>
<h2 id="最小费用流"><span class="header-section-number">3.6</span> 最小费用流</h2>
<h3 id="头文件宏全局变量-6"><span class="header-section-number">3.6.1</span> 头文件&amp;宏&amp;全局变量</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;queue&gt;</span>

<span class="ot">#define MAXN 2222</span>
<span class="ot">#define MAXM MAXN*MAXN</span>
<span class="ot">#define INF 0x3f3f3f3f </span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> S,T; <span class="co">//源点 汇点   </span>
<span class="kw">struct</span> Edge  
{  
    <span class="dt">int</span> from,to,flow,worth,next; <span class="co">//结点，流量，费用，链表   </span>
    Edge(){}  
    Edge(<span class="dt">int</span> fr,<span class="dt">int</span> ro,<span class="dt">int</span> fl,<span class="dt">int</span> wo,<span class="dt">int</span> ne)  
    {  
        from=fr,to=ro,flow=fl,worth=wo,next=ne;  
    }  
}edge[MAXM];  
<span class="dt">int</span> head[MAXN]; <span class="co">// 建立链表  </span>
<span class="dt">int</span> top;  <span class="co">//边数</span>
<span class="dt">bool</span> visque[MAXN]; <span class="co">//查看是否入队  </span>
<span class="dt">int</span> dis[MAXN]; <span class="co">//最小距离  </span>
<span class="dt">int</span> pre[MAXN],prx[MAXN]; <span class="co">//记录路线用于更新残量图   </span>
queue&lt;<span class="dt">int</span>&gt;q;  </code></pre></div>
<h3 id="建图-2"><span class="header-section-number">3.6.2</span> 建图</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> init() <span class="co">//初始化  </span>
{  
    memset(head,<span class="dv">0</span>,<span class="kw">sizeof</span>(head));  
    top=<span class="dv">2</span>;<span class="co">//必须是2</span>
}

<span class="dt">void</span> addEdge(<span class="dt">int</span> from,<span class="dt">int</span> to,<span class="dt">int</span> flow,<span class="dt">int</span> worth)  <span class="co">//建图   </span>
{  
    edge[top]=Edge(from,to,flow,worth,head[from]);  
    head[from]=top++;  
    edge[top]=Edge(to,from,<span class="dv">0</span>,-worth,head[to]);    <span class="co">//反向弧   </span>
    head[to]=top++;  
}  </code></pre></div>
<h3 id="辅助函数-7"><span class="header-section-number">3.6.3</span> 辅助函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> bfs() <span class="co">//寻找最短路  </span>
{  

    <span class="kw">while</span>(!q.empty()) q.pop(); <span class="co">//初始化队列  </span>
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;MAXN;i++) dis[i]=INF; <span class="co">//初始化距离   </span>
    q.push(S); <span class="co">//源点入队  </span>
    dis[S]=<span class="dv">0</span>;  
    visque[S]=<span class="kw">true</span>;  
    <span class="kw">while</span>(!q.empty())  
    {  
        <span class="dt">int</span> u=q.front();  
        q.pop();  
        <span class="kw">for</span>(<span class="dt">int</span> i=head[u];i;i=edge[i].next)  
        {  
            <span class="kw">if</span>(edge[i].flow&gt;<span class="dv">0</span>
                &amp;&amp;dis[u]+edge[i].worth&lt;dis[edge[i].to]) 
                <span class="co">//更新最短路   </span>
            {  
                dis[edge[i].to]=dis[u]+edge[i].worth;  
                pre[edge[i].to]=u;  
                prx[edge[i].to]=i;  
                <span class="kw">if</span>(!visque[edge[i].to])  
                {  
                    visque[edge[i].to]=<span class="kw">true</span>;  
                    q.push(edge[i].to);  
                }  
            }  
        }  
        visque[u]=<span class="kw">false</span>; <span class="co">//前面已经让u出队了所以这里要写一下   </span>
    }   
    <span class="kw">return</span> dis[T]!=INF; <span class="co">//判断是否可以到达汇点   </span>
}   
<span class="dt">int</span> dfs()  
{  
    <span class="dt">int</span> u=T;  
    <span class="dt">int</span> ans=INF;  
    <span class="kw">while</span>(u!=S) <span class="co">//找当前路中的最小流量   </span>
    {  
        <span class="kw">if</span>(edge[prx[u]].flow&lt;ans) ans=edge[prx[u]].flow;  
        u=pre[u];  
    }  
    u=T;  
    <span class="kw">while</span>(u!=S) <span class="co">//更新残量图   </span>
    {  
        edge[prx[u]].flow-=ans;  
        edge[prx[u]^<span class="dv">1</span>].flow+=ans;  
        u=pre[u];  
    }  
    <span class="kw">return</span> ans*dis[T];  
}</code></pre></div>
<h3 id="主要函数-3"><span class="header-section-number">3.6.4</span> 主要函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> solve()  
{  
    <span class="dt">int</span> ans=<span class="dv">0</span>;  
    <span class="kw">while</span>(bfs())  
    {  
        ans+=dfs();  
    }   
    <span class="kw">return</span> ans;  
}</code></pre></div>
<h2 id="生成树计数"><span class="header-section-number">3.7</span> 生成树计数</h2>
<h3 id="定理"><span class="header-section-number">3.7.1</span> 定理</h3>
<p>算法引入：<br />
给定一个无向图<span class="math inline">\(G\)</span>，求它生成树的个数<span class="math inline">\(t(G)\)</span>;</p>
<p>算法思想：<br />
(1)<span class="math inline">\(G\)</span>的度数矩阵<span class="math inline">\(D(G)\)</span>是一个<span class="math inline">\(n*n\)</span>的矩阵,并且满足:当<span class="math inline">\(i \neq j\)</span>时,<span class="math inline">\(d_{ij}=0\)</span>;当<span class="math inline">\(i=j\)</span>时,<span class="math inline">\(d_{ij}\)</span>等于<span class="math inline">\(v_i\)</span>的度数;<br />
(2)<span class="math inline">\(G\)</span>的邻接矩阵<span class="math inline">\(A(G)\)</span>是一个<span class="math inline">\(n*n\)</span>的矩阵,并且满足:如果<span class="math inline">\(v_i\)</span>,<span class="math inline">\(v_j\)</span>之间有边直接相连,则<span class="math inline">\(a_{ij}=1\)</span>,否则为<span class="math inline">\(0\)</span>;<br />
定义图<span class="math inline">\(G\)</span>的Kirchhoff矩阵<span class="math inline">\(C(G)\)</span>为<span class="math inline">\(C(G)=D(G)-A(G)\)</span>;<br />
Matrix-Tree定理:<span class="math inline">\(G\)</span>的所有不同的生成树的个数等于其Kirchhoff矩阵<span class="math inline">\(C(G)\)</span>任何一个<span class="math inline">\(n-1\)</span>阶主子式的行列式的绝对值；<br />
所谓<span class="math inline">\(n-1\)</span>阶主子式,就是对于<span class="math inline">\(r \left( 1 \leqslant r \leqslant n \right)\)</span>,将<span class="math inline">\(C(G)\)</span>的第<span class="math inline">\(r\)</span>行,第<span class="math inline">\(r\)</span>列同时去掉后得到的新矩阵,用<span class="math inline">\(Cr(G)\)</span>表示;</p>
<p>Kirchhoff矩阵的特殊性质：<br />
(1)对于任何一个图<span class="math inline">\(G\)</span>,它的Kirchhoff矩阵<span class="math inline">\(C\)</span>的行列式总是<span class="math inline">\(0\)</span>,这是因为<span class="math inline">\(C\)</span>每行每列所有元素的和均为<span class="math inline">\(0\)</span>;<br />
(2)如果<span class="math inline">\(G\)</span>是不连通的,则它的Kirchhoff矩阵<span class="math inline">\(C\)</span>的任一个主子式的行列式均为<span class="math inline">\(0\)</span>;<br />
(3)如果<span class="math inline">\(G\)</span>是一颗树,那么它的Kirchhoff矩阵<span class="math inline">\(C\)</span>的任一个<span class="math inline">\(n-1\)</span>阶主子式的行列式均为<span class="math inline">\(1\)</span>;</p>
<p>算法举例： sd:<br />
SPOJ104(Highways)</p>
<p>题目地址：<br />
<a href="http://www.spoj.com/problems/HIGH/" class="uri">http://www.spoj.com/problems/HIGH/</a></p>
<p>题目大意：<br />
一个有n座城市的组成国家,城市1至n编号,其中一些城市之间可以修建高速公路;<br />
需要有选择的修建一些高速公路,从而组成一个交通网络;<br />
计算有多少种方案,使得任意两座城市之间恰好只有一条路径;</p>
<h3 id="代码-2"><span class="header-section-number">3.7.2</span> 代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> N=<span class="dv">15</span>;

<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL;

<span class="dt">int</span> degree[N];
LL C[N][N];

LL det(LL a[][N],<span class="dt">int</span> n)<span class="co">//生成树计数:Matrix-Tree定理</span>
{
    LL ret=<span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>; i&lt;n; i++)
    {
        <span class="kw">for</span>(<span class="dt">int</span> j=i<span class="dv">+1</span>; j&lt;n; j++)
            <span class="kw">while</span>(a[j][i])
            {
                LL t=a[i][i]/a[j][i];
                <span class="kw">for</span>(<span class="dt">int</span> k=i; k&lt;n; k++)
                    a[i][k]=(a[i][k]-a[j][k]*t);
                <span class="kw">for</span>(<span class="dt">int</span> k=i; k&lt;n; k++)
                    swap(a[i][k],a[j][k]);
                ret=-ret;
            }
        <span class="kw">if</span>(a[i][i]==<span class="dv">0</span>)
            <span class="kw">return</span> <span class="dv">0</span>;
        ret=ret*a[i][i];
    }
    <span class="kw">if</span>(ret&lt;<span class="dv">0</span>)
        ret=-ret;
    <span class="kw">return</span> ret;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> tcase;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;tcase);
    <span class="kw">while</span>(tcase--)
    {
        memset(degree,<span class="dv">0</span>,<span class="kw">sizeof</span>(degree));
        memset(C,<span class="dv">0</span>,<span class="kw">sizeof</span>(C));
        <span class="dt">int</span> n,m;
        scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m);
        <span class="dt">int</span> u,v;
        <span class="kw">while</span>(m--)
        {
            scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>,&amp;u,&amp;v);
            u--;
            v--;
            C[u][v]=C[v][u]=<span class="dv">-1</span>;
            degree[u]++;
            degree[v]++;
        }
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;n; ++i)
            C[i][i]=degree[i];
        printf(<span class="st">&quot;</span><span class="ch">%lld\n</span><span class="st">&quot;</span>,det(C,n));
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="次小生成树"><span class="header-section-number">3.8</span> 次小生成树</h2>
<h3 id="全局变量结构体"><span class="header-section-number">3.8.1</span> 全局变量&amp;结构体</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1003</span>;
<span class="dt">const</span> <span class="dt">double</span> DIS_INF = <span class="dv">999999</span>;

<span class="dt">int</span> t, n, x[maxn], y[maxn], p[maxn], cas, book[maxn] = {<span class="dv">0</span>}
<span class="co">//cas:样例数 book:标记点是否在生成树内   </span>
<span class="dt">int</span> St[maxn], topSt, used[maxn][maxn] = {<span class="dv">0</span>};
<span class="co">//St、topSt:储存已经在生成树内的点 used:标记生成树内部的边</span>
<span class="dt">double</span> dis[maxn][maxn], tot, maxDis[maxn][maxn], ans, low[maxn];
<span class="co">//dis:权值 tot:生成树总权值 maxDis[i][j]:生成树上i-j路径上最大权</span>

<span class="kw">struct</span> Edge {
    <span class="dt">int</span> f, t;
    Edge(<span class="dt">int</span> _f = <span class="dv">0</span>, <span class="dt">int</span> _t = <span class="dv">0</span>) : f(_f), t(_t) {}
    <span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="dt">const</span> Edge &amp;Right) <span class="dt">const</span> {
        <span class="kw">return</span> dis[f][t] &gt; dis[Right.f][Right.t];
    }
};

priority_queue&lt;Edge&gt; pq;</code></pre></div>
<h3 id="算法"><span class="header-section-number">3.8.2</span> 算法</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Prim() {
    book[<span class="dv">0</span>] = cas;
    St[topSt++] = <span class="dv">0</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
        low[i] = dis[<span class="dv">0</span>][i];
        pq.push(Edge(<span class="dv">0</span>, i));
    }
    <span class="kw">while</span> (!pq.empty()) {
        Edge Front = pq.top();
        pq.pop();
        <span class="dt">int</span> f = Front.f, t = Front.t;
        <span class="kw">if</span> (book[t] == cas) <span class="kw">continue</span>;
        book[t] = cas;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; topSt; i++) {
            <span class="dt">int</span> u = St[i];
            maxDis[u][t] = maxDis[t][u]
                         = max(dis[f][t], maxDis[u][f]); 
                         <span class="co">//dp求每一条路径上的最大边</span>
        }
        St[topSt++] = t;
        tot += dis[f][t];
        used[f][t] = used[t][f] = cas;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            <span class="kw">if</span> (book[i] != cas &amp;&amp; dis[t][i] &lt; low[i]) {
                low[i] = dis[t][i];
                pq.push(Edge(t, i));
            }
        }
    }
}

<span class="dt">int</span> main() {
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;t);
    <span class="kw">for</span> (cas = <span class="dv">1</span>; cas &lt;= t; cas++) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        topSt = <span class="dv">0</span>;
        tot = <span class="dv">0</span>;
        ans = <span class="dv">-1</span>;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, x + i, y + i, p + i);
            <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= i; j++) {
                dis[i][j] = dis[j][i] 
                          = sqrt((x[i] - x[j]) *(x[i] - x[j])
                              + (y[i] - y[j])* (y[i] - y[j]));
            }
        }
        Prim();
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;n; i++){
            <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>; j&lt;i; j++){
                <span class="dt">double</span> B;
                <span class="kw">if</span>(used[i][j] == cas){
                    B = <span class="fl">1.0</span>*(p[i]+p[j])/(tot - dis[i][j]);
                }<span class="kw">else</span>{
                    B = <span class="fl">1.0</span>*(p[i]+p[j])/(tot - maxDis[i][j]);
                }
                ans = max(B, ans);
            }
        }
        printf(<span class="st">&quot;</span><span class="ch">%.2f\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="最小树形图"><span class="header-section-number">3.9</span> 最小树形图</h2>
<h3 id="宏常量结构体变量"><span class="header-section-number">3.9.1</span> 宏&amp;常量&amp;结构体&amp;变量</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define M 109</span>
<span class="ot">#define type int</span>

<span class="dt">const</span> <span class="dt">double</span> eps = <span class="fl">1e-10</span>;
<span class="dt">const</span> type inf = (<span class="dv">1</span>) &lt;&lt; <span class="dv">30</span>;

<span class="kw">struct</span> point {
    <span class="dt">double</span> x, y;
} p[M];

<span class="kw">struct</span> Node {
    <span class="dt">int</span> u, v;
    type cost;
} E[M * M + <span class="dv">5</span>];

<span class="dt">int</span> pre[M], ID[M], vis[M];
type In[M];
<span class="dt">int</span> n, m;</code></pre></div>
<h3 id="算法-1"><span class="header-section-number">3.9.2</span> 算法</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">type Directed_MST(<span class="dt">int</span> root, <span class="dt">int</span> NV, <span class="dt">int</span> NE) {
    type ret = <span class="dv">0</span>;
    <span class="kw">while</span> (<span class="kw">true</span>) {
        <span class="co">//1.找最小入边</span>
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; NV; i++)
            In[i] = inf;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; NE; i++) {
            <span class="dt">int</span> u = E[i].u;
            <span class="dt">int</span> v = E[i].v;
            <span class="kw">if</span> (E[i].cost &lt; In[v] &amp;&amp; u != v) {
                pre[v] = u;
                In[v] = E[i].cost;
            }
        }
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; NV; i++) {
            <span class="kw">if</span> (i == root) <span class="kw">continue</span>;
            <span class="kw">if</span> (In[i] == inf) <span class="kw">return</span> <span class="dv">-1</span>;
            <span class="co">//除了跟以外有点没有入边,则根无法到达它</span>
        }
        <span class="co">//2.找环</span>
        <span class="dt">int</span> cntnode = <span class="dv">0</span>;
        memset(ID, <span class="dv">-1</span>, <span class="kw">sizeof</span>(ID));
        memset(vis, <span class="dv">-1</span>, <span class="kw">sizeof</span>(vis));
        In[root] = <span class="dv">0</span>;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; NV; i++) { <span class="co">//标记每个环</span>
            ret += In[i];
            <span class="dt">int</span> v = i;
            <span class="kw">while</span> (vis[v] != i &amp;&amp; ID[v] == <span class="dv">-1</span> &amp;&amp; v != root) {
                vis[v] = i;
                v = pre[v];
            }
            <span class="kw">if</span> (v != root &amp;&amp; ID[v] == <span class="dv">-1</span>) {
                <span class="kw">for</span> (<span class="dt">int</span> u = pre[v]; u != v; u = pre[u]) {
                    ID[u] = cntnode;
                }
                ID[v] = cntnode++;
            }
        }
        <span class="kw">if</span> (cntnode == <span class="dv">0</span>) <span class="kw">break</span>; <span class="co">//无环</span>
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; NV; i++)
            <span class="kw">if</span> (ID[i] == <span class="dv">-1</span>) {
                ID[i] = cntnode++;
            }
        <span class="co">//3.缩点,重新标记</span>
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; NE; i++) {
            <span class="dt">int</span> v = E[i].v;
            E[i].u = ID[E[i].u];
            E[i].v = ID[E[i].v];
            <span class="kw">if</span> (E[i].u != E[i].v) {
                E[i].cost -= In[v];
            }
        }
        NV = cntnode;
        root = ID[root];
    }
    <span class="kw">return</span> ret;
}

<span class="dt">int</span> main() {
    <span class="kw">while</span> (scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m), n + m) {
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, &amp;E[i].u, &amp;E[i].v, &amp;E[i].cost);
            E[i].u--;
            E[i].v--;
        }
        type ans = Directed_MST(<span class="dv">0</span>, n, m);
        <span class="kw">if</span> (ans == <span class="dv">-1</span>)
            printf(<span class="st">&quot;impossible</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">else</span>
            printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="强连通分量"><span class="header-section-number">3.10</span> 强连通分量</h2>
<h3 id="变量宏"><span class="header-section-number">3.10.1</span> 变量&amp;宏</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="dt">const</span> <span class="dt">int</span> N = <span class="dv">10010</span>;
vector&lt;<span class="dt">int</span>&gt; G[N];<span class="co">//邻接表存图</span>
vector&lt;<span class="dt">int</span>&gt; rG[N];<span class="co">//存反向图</span>
vector&lt;<span class="dt">int</span>&gt; vs;<span class="co">//后序遍历顺序的顶点列表</span>
<span class="dt">bool</span> vis[N];
<span class="dt">int</span> cmp[N];<span class="co">//所属强连通分量的拓扑序</span></code></pre></div>
<h3 id="主要函数-4"><span class="header-section-number">3.10.2</span> 主要函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> add_edge(<span class="dt">int</span> u, <span class="dt">int</span> v){
    G[u].push_back(v);
    rG[v].push_back(u);
}

<span class="co">//input: u 顶点</span>
<span class="co">//output: vs 后序遍历顺序的顶点列表</span>
<span class="dt">void</span> dfs(<span class="dt">int</span> u){
    vis[u] = <span class="kw">true</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[u].size(); i++){
        <span class="dt">int</span> v = G[u][i];
        <span class="kw">if</span>(!vis[v])
              dfs(v);
    }
    vs.push_back(u);
}

<span class="co">//input: u 顶点编号; k 拓扑序号</span>
<span class="co">//output: cmp[] 强连通分量拓扑序</span>
<span class="dt">void</span> rdfs(<span class="dt">int</span> u, <span class="dt">int</span> k){
    vis[u] = <span class="kw">true</span>;
    cmp[u] = k;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; rG[u].size(); i++){
        <span class="dt">int</span> v = rG[u][i];
        <span class="kw">if</span>(!vis[v])
              rdfs(v, k);
    }
}

<span class="co">//Strongly Connected Component 强连通分量</span>
<span class="co">//input: n 顶点个数</span>
<span class="co">//output: k 强连通分量数;</span>
<span class="dt">int</span> scc(<span class="dt">int</span> n){
    memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
    vs.clear();
    <span class="kw">for</span>(<span class="dt">int</span> u = <span class="dv">0</span>; u &lt; n; u++)
        <span class="kw">if</span>(!vis[u])
              dfs(u);
    <span class="dt">int</span> k = <span class="dv">0</span>;
    memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
    <span class="kw">for</span>(<span class="dt">int</span> i = vs.size()<span class="dv">-1</span>; i &gt;= <span class="dv">0</span>; i--)
          <span class="kw">if</span>(!vis[vs[i]])
              rdfs(vs[i], k++);
    <span class="kw">return</span> k;
}</code></pre></div>
<h2 id="sat问题"><span class="header-section-number">3.11</span> 2-SAT问题</h2>
<p>【2-SAT问题】<br />
​ 现有一个由N个布尔值组成的序列A，给出一些限制关系，比如A[x] AND A[y]=0、A[x] OR A[y] OR A[z]=1等，要确定A[0..N-1]的值，使得其满足所有限制关系。这个称为SAT问题，特别的，若每种限制关系中最多只对两个元素进行限制，则称为2-SAT问题。</p>
<p>由于在2-SAT问题中，最多只对两个元素进行限制，所以可能的限制关系共有11种：<br />
A[x]<br />
NOT A[x]<br />
A[x] AND A[y]<br />
A[x] AND NOT A[y]<br />
A[x] OR A[y]<br />
A[x] OR NOT A[y]<br />
NOT (A[x] AND A[y])<br />
NOT (A[x] OR A[y])<br />
A[x] XOR A[y]<br />
NOT (A[x] XOR A[y])<br />
A[x] XOR NOT A[y]<br />
进一步，A[x] AND A[y]相当于(A[x]) AND (A[y])（也就是可以拆分成A[x]与A[y]两个限制关系），NOT(A[x] OR A[y])相当于NOT A[x] AND NOT A[y]（也就是可以拆分成NOT A[x]与NOT A[y]两个限制关系）。因此，可能的限制关系最多只有9种。</p>
<p>在实际问题中，2-SAT问题在大多数时候表现成以下形式：有N对物品，每对物品中必须选取一个，也只能选取一个，并且它们之间存在某些限制关系（如某两个物品不能都选，某两个物品不能都不选，某两个物品必须且只能选一个，某个物品必选）等，这时，可以将每对物品当成一个布尔值（选取第一个物品相当于0，选取第二个相当于1），如果所有的限制关系最多只对两个物品进行限制，则它们都可以转化成9种基本限制关系，从而转化为2-SAT模型。</p>
<p>【建模】<br />
其实2-SAT问题的建模是和实际问题非常相似的。<br />
建立一个2N阶的有向图，其中的点分为N对，每对点表示布尔序列A的一个元素的0、1取值（以下将代表A[i]的0取值的点称为i，代表A[i]的1取值的点称为i'）。显然每对点必须且只能选取一个。然后，图中的边具有特定含义。若图中存在边<i, j>，则表示若选了i必须选j。可以发现，上面的9种限制关系中，后7种二元限制关系都可以用连边实现，比如NOT(A[x] AND A[y])需要连两条边&lt;x, y'&gt;和&lt;y, x'&gt;，A[x] OR A[y]需要连两条边<x', y>和<y', x>。而前两种一元关系，对于A[x]（即x必选），可以通过连边<x', x>来实现，而NOT A[x]（即x不能选），可以通过连边&lt;x, x'&gt;来实现。</p>
<p>【O(NM)算法：求字典序最小的解】<br />
根据2-SAT建成的图中边的定义可以发现，若图中i到j有路径，则若i选，则j也要选；或者说，若j不选，则i也不能选；<br />
因此得到一个很直观的算法：<br />
（1）给每个点设置一个状态V，V=0表示未确定，V=1表示确定选取，V=2表示确定不选取。称一个点是已确定的当且仅当其V值非0。设立两个队列Q1和Q2，分别存放本次尝试选取的点的编号和尝试不选的点的编号。<br />
（2）若图中所有的点均已确定，则找到一组解，结束，否则，将Q1、Q2清空，并任选一个未确定的点i，将i加入队列Q1，将i'加入队列Q2；<br />
（3）找到i的所有后继。对于后继j，若j未确定，则将j加入队列Q1；若j'（这里的j'是指与j在同一对的另一个点）未确定，则将j'加入队列Q2；<br />
（4）遍历Q2中的每个点，找到该点的所有前趋（这里需要先建一个补图），若该前趋未确定，则将其加入队列Q2；<br />
（5）在（3）（4）步操作中，出现以下情况之一，则本次尝试失败，否则本次尝试成功：<br />
&lt;1&gt;某个已被加入队列Q1的点被加入队列Q2；<br />
&lt;2&gt;某个已被加入队列Q2的点被加入队列Q1;<br />
&lt;3&gt;某个j的状态为2；<br />
&lt;4&gt;某个i'或j'的状态为1或某个i'或j'的前趋的状态为1；<br />
（6）若本次尝试成功，则将Q1中的所有点的状态改为1，将Q2中所有点的状态改为2，转（2），否则尝试点i'，若仍失败则问题无解。<br />
该算法的时间复杂度为O(NM)（最坏情况下要尝试所有的点，每次尝试要遍历所有的边），但是在多数情况下，远远达不到这个上界。<br />
具体实现时，可以用一个数组vst来表示队列Q1和Q2。设立两个标志变量i1和i2（要求对于不同的i，i1和i2均不同，这样可以避免每次尝试都要初始化一次，节省时间），若vst[i]=i1则表示i已被加入Q1，若vst[i]=i2则表示i已被加入Q2。不过Q1和Q2仍然是要设立的，因为遍历（BFS）的时候需要队列，为了防止重复遍历，加入Q1（或Q2）中的点的vst值必然不等于i1（或i2）。中间一旦发生矛盾，立即中止尝试，宣告失败。</p>
<p>该算法虽然在多数情况下时间复杂度到不了O(NM)，但是综合性能仍然不如下面的O(M)算法。不过，该算法有一个很重要的用处：求字典序最小的解！ 如果原图中的同一对点编号都是连续的（01、23、45……）则可以依次尝试第0对、第1对……点，每对点中先尝试编号小的，若失败再尝试编号大的。这样一定能求出字典序最小的解（如果有解的话），因为一个点一旦被确定，则不可更改。<br />
如果原图中的同一对点编号不连续（比如03、25、14……）则按照该对点中编号小的点的编号递增顺序将每对点排序，然后依次扫描排序后的每对点，先尝试其编号小的点，若成功则将这个点选上，否则尝试编号大的点，若成功则选上，否则（都失败）无解。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> check(<span class="dt">int</span> limit){
    <span class="co">//1.建图</span>
    <span class="co">//2.强连通分量缩点</span>
    scc(<span class="er">2n</span>)
    <span class="co">//3.判断</span>
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
        <span class="kw">if</span>(cmp[i] == cmp[i+n])
            <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre></div>
<h2 id="tarjan缩点找割边找割点"><span class="header-section-number">3.12</span> tarjan缩点/找割边/找割点</h2>
<blockquote>
<p>复杂度<span class="math inline">\(\Theta\left(m\right)\)</span></p>
</blockquote>
<h3 id="环境"><span class="header-section-number">3.12.1</span> 环境</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MAXN 100001</span><span class="co">//点数</span>
<span class="ot">#define MAXM 200002</span><span class="co">//边数</span>

<span class="co">//此题是无向图找割边,然后把环缩点</span>
<span class="dt">int</span> n,m;
<span class="dt">int</span> DFN;
<span class="dt">int</span> dfn[MAXN];<span class="co">//dfs序</span>
<span class="dt">int</span> low[MAXN];<span class="co">//不经过父节点能访问的最早的点的dfn</span>
<span class="dt">int</span> stk[MAXN],tp;<span class="co">//栈</span>
<span class="dt">int</span> fa[MAXN];<span class="co">//并查集,fa[i]为缩点后i所在的点</span>

<span class="kw">struct</span> Edge{
    <span class="dt">int</span> to;
    <span class="dt">int</span> next;
}edge[MAXM];<span class="co">//无向图</span>
<span class="dt">int</span> head[MAXN],top;</code></pre></div>
<h3 id="初始化加边-2"><span class="header-section-number">3.12.2</span> 初始化&amp;加边</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="dt">void</span> initTarjan(<span class="dt">int</span> n)<span class="co">//点编号从1开始</span>
{
    tp=DFN=top=<span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)
    {
        fa[i]=i;
        head[i]=dfn[i]=<span class="dv">-1</span>;
    }
}

<span class="kw">inline</span> <span class="dt">void</span> addEdge(<span class="dt">int</span> a,<span class="dt">int</span> b)
{
    edge[top].to=b;
    edge[top].next=head[a];
    head[a]=top++;

    edge[top].to=a;
    edge[top].next=head[b];
    head[b]=top++;
}</code></pre></div>
<h3 id="辅助函数并查集栈"><span class="header-section-number">3.12.3</span> 辅助函数(并查集,栈)</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="dt">void</span> stkPush(<span class="dt">int</span> x)
{
    stk[tp++]=x;
}

<span class="kw">inline</span> <span class="dt">int</span> stkPop()
{
    <span class="kw">return</span> stk[--tp];
}

<span class="kw">inline</span> <span class="dt">int</span> unionFind(<span class="dt">int</span> x)
{
    <span class="kw">while</span>(fa[fa[x]]!=fa[x])fa[x]=fa[fa[x]];
    <span class="kw">return</span> fa[x];
}

<span class="kw">inline</span> <span class="dt">int</span> reAddEdge(<span class="dt">int</span> e,<span class="dt">int</span> a)<span class="co">//边e交给a</span>
{
    <span class="kw">if</span>(unionFind(edge[e].to)==a)<span class="kw">return</span> edge[e].next;
    <span class="dt">int</span> tmp=edge[e].next;
    edge[e].next=head[a];
    head[a]=e;
    edge[e^<span class="dv">1</span>].to=a;
    <span class="kw">return</span> tmp;
}</code></pre></div>
<h3 id="核心代码-5"><span class="header-section-number">3.12.4</span> 核心代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> tarjan(<span class="dt">int</span> nown,<span class="dt">int</span> p)<span class="co">//缩点</span>
{
    <span class="kw">if</span>(dfn[nown]!=<span class="dv">-1</span>)<span class="kw">return</span>;
    dfn[nown]=low[nown]=DFN++;
    stkPush(nown);
    <span class="kw">for</span>(<span class="dt">int</span> i=head[nown];i!=<span class="dv">-1</span>;i=edge[i].next)
    {
        <span class="kw">if</span>(edge[i].to==p)<span class="kw">continue</span>;
        tarjan(edge[i].to,nown);
        low[nown]=min(low[nown],low[edge[i].to]);
    }
    <span class="kw">if</span>(dfn[nown]==low[nown])
    {
        <span class="co">//此时p为割点</span>
        <span class="co">//把栈顶到nown的点合并到nown上</span>
        <span class="dt">int</span> i;
        <span class="kw">for</span>(i=tp<span class="dv">-1</span>;stk[i]!=nown;i--)
            fa[stk[i]]=nown;
        <span class="co">//重连边</span>
        i=head[nown];head[nown]=<span class="dv">-1</span>;
        <span class="kw">while</span>(i!=<span class="dv">-1</span>)i=reAddEdge(i,nown);
        <span class="kw">while</span>((i=stkPop())!=nown)
            <span class="kw">for</span>(<span class="dt">int</span> j=head[i];j!=<span class="dv">-1</span>;j=reAddEdge(j,nown))
                ;
    }
}</code></pre></div>
<h3 id="用法-6"><span class="header-section-number">3.12.5</span> 用法</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//要求无重边,无自环!!!</span>
initTarjan();
<span class="kw">for</span>(e:u-&gt;v)addEdge(u,v);
tarjan(<span class="dv">1</span>,<span class="dv">0</span>);
<span class="co">//之后图变为以1为根节点的树</span></code></pre></div>
<h2 id="二分图最大匹配"><span class="header-section-number">3.13</span> 二分图最大匹配</h2>
<h3 id="匈牙利算法"><span class="header-section-number">3.13.1</span> 匈牙利算法</h3>
<h4 id="建图变量"><span class="header-section-number">3.13.1.1</span> 建图&amp;变量</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> N = <span class="dv">1010</span>;
<span class="dt">int</span> head[N], tot;
<span class="kw">struct</span> Edge{
    <span class="dt">int</span> to, next;
}edge[N*N];

<span class="dt">void</span> init(){
    tot = <span class="dv">0</span>;
    memset(head, <span class="dv">-1</span>, <span class="kw">sizeof</span>(head));
}

<span class="dt">void</span> add_edge(<span class="dt">int</span> u, <span class="dt">int</span> v){
    edge[tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot++;

    edge[tot].to = u;
    edge[tot].next = head[v];
    head[v] = tot++;
}</code></pre></div>
<h4 id="核心代码-6"><span class="header-section-number">3.13.1.2</span> 核心代码</h4>
<p>复杂度： <span class="math inline">\(O(nm)\)</span></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> matching[N];
<span class="dt">int</span> check[N];

<span class="dt">bool</span> dfs(<span class="dt">int</span> u){
    <span class="kw">for</span>(<span class="dt">int</span> i =  head[u]; i != <span class="dv">-1</span>; i = edge[i].next){
        <span class="dt">int</span> v = edge[i].to;
        <span class="kw">if</span>(!check[v]){<span class="co">//要求不在交替路</span>
            check[v] = <span class="dv">1</span>;<span class="co">//放入交替路</span>
            <span class="kw">if</span>(matching[v] == <span class="dv">-1</span> || dfs(matching[v])){
                <span class="co">//如果是未匹配点，说明交替路为增广路，则交换路径，并返回成功</span>
                matching[u] = v;
                matching[v] = u;
                <span class="kw">return</span> <span class="kw">true</span>;
            }
        }
    }
    <span class="kw">return</span> <span class="kw">false</span>;<span class="co">//不存在增广路</span>
}

<span class="co">//hungarian: 二分图最大匹配匈牙利算法</span>
<span class="co">//input: null</span>
<span class="co">//output: ans 最大匹配数</span>
<span class="dt">int</span> hungarian(){
    <span class="dt">int</span> ans = <span class="dv">0</span>;
    memset(matching, <span class="dv">-1</span>, <span class="kw">sizeof</span>(matching));
    <span class="kw">for</span>(<span class="dt">int</span> u = <span class="dv">0</span>; u &lt; p; u++){
        <span class="kw">if</span>(matching[u] == <span class="dv">-1</span>){
            memset(check, <span class="dv">0</span>, <span class="kw">sizeof</span>(check));
            <span class="kw">if</span>(dfs(u))
              ans++;
        }
    }
    <span class="kw">return</span> ans;
}</code></pre></div>
<h3 id="hopcroft_karp算法"><span class="header-section-number">3.13.2</span> Hopcroft_Karp算法</h3>
<h4 id="变量建图"><span class="header-section-number">3.13.2.1</span> 变量&amp;建图</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> N = <span class="dv">100000</span>;
<span class="dt">const</span> <span class="dt">int</span> M = <span class="dv">20000000</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="bn">0x3f3f3f3f</span>;
<span class="dt">int</span> head[N], tot;
<span class="kw">struct</span> Edge{
    <span class="dt">int</span> to, next;
}edge[M];

<span class="dt">void</span> add_edge(<span class="dt">int</span> u, <span class="dt">int</span> v){
    edge[tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot++;
}</code></pre></div>
<h4 id="核心代码-7"><span class="header-section-number">3.13.2.2</span> 核心代码</h4>
<p>复杂度：<span class="math inline">\(O(\sqrt{V}E)\)</span></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//xlink[i]表示左集合顶点i匹配的右集合的点，ylink[i]表示右集合顶点i匹配的左集合的点</span>
<span class="dt">int</span> xlink[N], ylink[N];
<span class="co">//xlevel[i]表示左集合顶点i的所在层数，ylevel[i]表示右集合顶点i的所在层数</span>
<span class="dt">int</span> xlevel[N], ylevel[N];
<span class="dt">bool</span> vis[N];
<span class="kw">struct</span> Hopcroft_Karp{
    <span class="dt">int</span> dis, xn, yn;<span class="co">//xn表示左集合顶点个数，yn表示右集合顶点个数</span>
    <span class="dt">void</span> init(<span class="dt">int</span> _xn, <span class="dt">int</span> _yn){
        tot = <span class="dv">0</span>;
        xn = _xn;
        yn = _yn;
        memset(head, <span class="dv">-1</span>, <span class="kw">sizeof</span>(head));
        memset(xlink, <span class="dv">-1</span>, <span class="kw">sizeof</span>(xlink));
        memset(ylink, <span class="dv">-1</span>, <span class="kw">sizeof</span>(ylink));
    }
    <span class="dt">bool</span> bfs(){
        queue&lt;<span class="dt">int</span>&gt; que;
        dis = INF;
        memset(xlevel, <span class="dv">-1</span>, <span class="kw">sizeof</span>(xlevel));
        memset(ylevel, <span class="dv">-1</span>, <span class="kw">sizeof</span>(ylevel));
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; xn; i++)
            <span class="kw">if</span>(xlink[i] == <span class="dv">-1</span>){
                que.push(i);
                xlevel[i] = <span class="dv">0</span>;
            }
        <span class="kw">while</span>(!que.empty()){
            <span class="dt">int</span> u = que.front();
            que.pop();
            <span class="kw">if</span>(xlevel[u] &gt; dis)<span class="kw">break</span>;
            <span class="kw">for</span>(<span class="dt">int</span> i = head[u]; i != <span class="dv">-1</span>; i = edge[i].next){
                <span class="dt">int</span> v = edge[i].to;
                <span class="kw">if</span>(ylevel[v] == <span class="dv">-1</span>){
                    ylevel[v] = xlevel[u] + <span class="dv">1</span>;
                    <span class="kw">if</span>(ylink[v] == <span class="dv">-1</span>)
                          dis = ylevel[v];
                    <span class="kw">else</span>{
                        xlevel[ylink[v]] = ylevel[v]<span class="dv">+1</span>;
                        que.push(ylink[v]);
                    }
                }
            }
        }
        <span class="kw">return</span> dis != INF;
    }
    <span class="dt">int</span> dfs(<span class="dt">int</span> u){
        <span class="kw">for</span>(<span class="dt">int</span> i = head[u]; i != <span class="dv">-1</span>; i = edge[i].next){
            <span class="dt">int</span> v = edge[i].to;
            <span class="kw">if</span>(!vis[v] &amp;&amp; ylevel[v] == xlevel[u]<span class="dv">+1</span>){
                vis[v] = <span class="dv">1</span>;
                <span class="kw">if</span>(ylink[v] != <span class="dv">-1</span> &amp;&amp; ylevel[v] == dis)
                      <span class="kw">continue</span>;
                <span class="kw">if</span>(ylink[v] == <span class="dv">-1</span> || dfs(ylink[v])){
                    xlink[u] = v;
                    ylink[v] = u;
                    <span class="kw">return</span> <span class="dv">1</span>;
                }
            }
        }
        <span class="kw">return</span> <span class="dv">0</span>;
    }
    <span class="co">//二分图最大匹配</span>
    <span class="co">//input：建好的二分图</span>
    <span class="co">//output：ans 最大匹配数</span>
    <span class="dt">int</span> max_match(){
        <span class="dt">int</span> ans = <span class="dv">0</span>;
        <span class="kw">while</span>(bfs()){
            memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; xn; i++)
                  <span class="kw">if</span>(xlink[i] == <span class="dv">-1</span>)
                      ans += dfs(i);
        }
        <span class="kw">return</span> ans;
    }
}hk_match;</code></pre></div>
<h4 id="用法-7"><span class="header-section-number">3.13.2.3</span> 用法</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">hk_match.init(n, m);<span class="co">//n为左集合大小，m为右集合大小</span>
<span class="kw">for</span>(e in E)
    add_edge(u, v);
hk_match.max_match();</code></pre></div>
<h1 id="数论"><span class="header-section-number">4</span> 数论</h1>
<h2 id="二分等比数列求和"><span class="header-section-number">4.1</span> 二分等比数列求和</h2>
<h3 id="代码-3"><span class="header-section-number">4.1.1</span> 代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">ll sum(ll a, ll p, ll n) {
    <span class="kw">if</span> (n &lt;= <span class="dv">1</span>) <span class="kw">return</span> a;
    <span class="kw">if</span> (n &amp; <span class="dv">1</span>)
        <span class="kw">return</span> (sum(a, p, n / <span class="dv">2</span>) * (<span class="dv">1</span> + quickPow(p, n / <span class="dv">2</span>)) % MOD
                + quickPow(p, n - <span class="dv">1</span>)) % MOD;
    <span class="kw">else</span>
        <span class="kw">return</span> (sum(a, p, n / <span class="dv">2</span>) * (<span class="dv">1</span> + quickPow(p, n / <span class="dv">2</span>))) % MOD;
}</code></pre></div>
<h3 id="用法-8"><span class="header-section-number">4.1.2</span> 用法</h3>
<p>调用函数 <span class="math inline">\(sum(a,p,n)\)</span> ,求 <span class="math inline">\(\sum_{i=0}^{n-1}ap^i\)</span></p>
<h2 id="扩展欧几里得"><span class="header-section-number">4.2</span> 扩展欧几里得</h2>
<h3 id="定义"><span class="header-section-number">4.2.1</span> 定义</h3>
<p>对于不完全为0的非负整数ab,gcd(a,b)表示a,b的最大公约数,必然存在整数对x,y,使得gcd(a,b)=ax+by。</p>
<h3 id="代码-4"><span class="header-section-number">4.2.2</span> 代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> exgcd(<span class="dt">int</span> a,<span class="dt">int</span> b,<span class="dt">int</span> &amp;x,<span class="dt">int</span> &amp;y){
    <span class="kw">if</span> (b==<span class="dv">0</span>){
        x=<span class="dv">1</span>,y=<span class="dv">0</span>;
        <span class="kw">return</span> a;
    }
    <span class="dt">int</span> q=exgcd(b,a%b,y,x);
    y-=a/b*x;
    <span class="kw">return</span> q;
}</code></pre></div>
<h3 id="求逆元"><span class="header-section-number">4.2.3</span> 求逆元</h3>
<p>求a对b的逆元，即(a^(-1))mod b<br />
int x,y;<br />
exgcd(a,b,x,y);<br />
x即为a对b的逆元</p>
<h2 id="矩阵快速幂"><span class="header-section-number">4.3</span> 矩阵快速幂</h2>
<h3 id="代码-5"><span class="header-section-number">4.3.1</span> 代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MAXN 111</span>
<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;

<span class="dt">const</span> ll MOD = <span class="dv">1000000007</span>;
<span class="kw">struct</span> Matrix{
    ll a[MAXN][MAXN];
    <span class="dt">int</span> r, c;
};

Matrix multi(<span class="dt">const</span> Matrix &amp;x, <span class="dt">const</span> Matrix &amp;y)<span class="co">//矩阵乘法</span>
{
    Matrix z;
    memset(z.a, <span class="dv">0</span>, <span class="kw">sizeof</span>(z.a));
    z.r = x.r, z.c = y.c;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; x.r; i++){
        <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; x.c; k++)<span class="co">//加速优化</span>
        {
            <span class="kw">if</span>(x.a[i][k] == <span class="dv">0</span>) <span class="kw">continue</span>;
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j&lt; y.c; j++)
                z.a[i][j] =(
                    z.a[i][j] + (x.a[i][k] * y.a[k][j]) % MOD
                    ) % MOD;
        }
    }
    <span class="kw">return</span> z;
}

Matrix kpow(Matrix a,Matrix b,<span class="dt">int</span> n)<span class="co">//a*b^n</span>
{
    <span class="kw">while</span>(n){
        <span class="kw">if</span>(n &amp; <span class="dv">1</span>)
            a = multi(a, b);
        b = multi(b, b);
        n &gt;&gt;= <span class="dv">1</span>;
    }
    <span class="kw">return</span> a;
}</code></pre></div>
<h2 id="中国剩余定理"><span class="header-section-number">4.4</span> 中国剩余定理</h2>
<h3 id="定义通式"><span class="header-section-number">4.4.1</span> 定义&amp;通式</h3>
<p>给出了以下的一元线性同余方程组：</p>
<p><span class="math display">\[
\left ( S \right ) :
\left\{
\begin{matrix}
x \equiv a_1 \left ( mod\ m_1 \right )\\
x \equiv a_2 \left ( mod\ m_2 \right )\\
\vdots \\
x \equiv a_n \left ( mod\ m_n \right )
\end{matrix}
\right.
\]</span></p>
<p>有解的判定条件，并用构造法给出了在有解情况下解的具体形式。<br />
中国剩余定理说明：假设整数<span class="math inline">\(m_1,m_2, \cdots ,m_n\)</span>两两互质，则对任意的整数：<span class="math inline">\(a1,a2, \cdots ,an\)</span>，方程组 有解，并且通解可以用如下方式构造得到：<br />
设</p>
<p><span class="math display">\[
M = m_1 \times m_2 \times m_3 \times \cdots \times m_n = \prod_{i=1}^n m_i 
\]</span></p>
<p>是整数<span class="math inline">\(m_1,m_2, \cdots ,m_n\)</span>的乘积，并设</p>
<p><span class="math display">\[
M_i = M \div m_i \ , \forall i \in \left \{ 1, 2, \cdots, n \right \} 
\]</span></p>
<p>是除了<span class="math inline">\(m_i\)</span>以外的<span class="math inline">\(n-1\)</span>个整数的乘积。<br />
设<span class="math inline">\(t_i=M_i^{-1}\)</span>为<span class="math inline">\(M_i\)</span>模<span class="math inline">\(m_i\)</span>的数论倒数(<span class="math inline">\(t_i\)</span>为<span class="math inline">\(M_i\)</span>意义下的逆元)</p>
<p><span class="math display">\[
M_it_i \equiv 1 \left ( mod \ m_i \right ), \forall i \in \left \{ 1,2,\cdots,n \right \}
\]</span></p>
<p>方程组<span class="math inline">\(\left ( S \right )\)</span>的通解形式为</p>
<p><span class="math display">\[
\begin{aligned}
x &amp;= a_1t_1M_1 + a_2t_2M_2 + \cdots + a_nt_nM_n + kM \\
&amp;= kM + \sum_{i=1}^na_it_iM_i, \ k \in \mathbb{Z}
\end{aligned}
\]</span></p>
<p>在模<span class="math inline">\(M_i\)</span>的意义下，方程组<span class="math inline">\(\left ( S \right )\)</span>只有一个解:</p>
<p><span class="math display">\[
x \equiv \left ( a_1t_1M_1 + a_2t_2M_2 + \cdots + a_nt_nM_n \right ) \ mod \ M
\]</span></p>
<h3 id="代码-6"><span class="header-section-number">4.4.2</span> 代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">void</span> extend_Euclid(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> &amp;x, <span class="dt">int</span> &amp;y)
{
    <span class="kw">if</span>(b==<span class="dv">0</span>){
        x = <span class="dv">1</span>;
        y = <span class="dv">0</span>;
        <span class="kw">return</span>;
    }
    extend_Euclid(b, a%b, x, y);
    <span class="dt">int</span> tmp = x;
    x = y;
    y = tmp-(a/b)*y;
}

<span class="dt">int</span> CRT(<span class="dt">int</span> *a, <span class="dt">int</span> *m, <span class="dt">int</span> n)
{
    <span class="dt">int</span> M = <span class="dv">1</span>, ans = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) M*=m[i];
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++){
        <span class="dt">int</span> x, y;
        <span class="dt">int</span> Mi = M/m[i];
        extend_Euclid(Mi, m[i], x, y);
        ans = (ans+Mi*x*a[i])%M;
    }
    <span class="kw">if</span>(ans &lt; <span class="dv">0</span>) ans+=M;
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> a[<span class="dv">5</span>], m[<span class="dv">5</span>] = {<span class="dv">0</span>, <span class="dv">23</span>, <span class="dv">28</span>, <span class="dv">33</span>}, d, kase = <span class="dv">0</span>;
    <span class="kw">while</span>(cin&gt;&gt;a[<span class="dv">1</span>]&gt;&gt;a[<span class="dv">2</span>]&gt;&gt;a[<span class="dv">3</span>]&gt;&gt;d)
    {
        <span class="kw">if</span>(a[<span class="dv">1</span>]==<span class="dv">-1</span>&amp;&amp;a[<span class="dv">2</span>]==<span class="dv">-1</span>&amp;&amp;a[<span class="dv">3</span>]==<span class="dv">-1</span>&amp;&amp;d==<span class="dv">-1</span>)<span class="kw">break</span>;
        <span class="dt">int</span> ans = CRT(a, m, <span class="dv">3</span>);
        <span class="kw">if</span>(ans &lt;= d) ans+=<span class="dv">21252</span>;
        printf(<span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">: the next triple peak occurs in </span><span class="ch">%d</span><span class="st"> days.</span><span class="ch">\n</span><span class="st">&quot;</span>,
        ++kase, ans-d);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="欧拉函数"><span class="header-section-number">4.5</span> 欧拉函数</h2>
<h3 id="定义通式-1"><span class="header-section-number">4.5.1</span> 定义&amp;通式</h3>
<p>欧拉函数是小于等于 <span class="math inline">\(n\)</span> 的正整数中与 <span class="math inline">\(n\)</span> 互质的数的数目（<span class="math inline">\(\varphi \left ( 1 \right )=1\)</span>）。<br />
通式：<span class="math inline">\(\varphi \left ( x \right ) = x\left ( 1 - \frac{1}{p_1} \right )\left ( 1 - \frac{1}{p_2} \right )\left ( 1 - \frac{1}{p_3} \right )\cdots\left ( 1 - \frac{1}{p_n} \right )\)</span><br />
性质: 若a与b<strong>互质</strong>,则<span class="math inline">\(\varphi \left( ab \right) = \varphi \left(a \right)\varphi \left(b \right)\)</span><br />
应用：欧拉降幂公式<br />
<span class="math inline">\(a^b \equiv a^{b \  \% \  \varphi \left( n\right) + \varphi \left( n \right)} (mod\ n)\ (b &gt; \varphi (n))\)</span></p>
<h3 id="代码-7"><span class="header-section-number">4.5.2</span> 代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/*线性筛O(n)时间复杂度内筛出maxn内欧拉函数值*/</span>
<span class="dt">int</span> m[maxn],phi[maxn],p[maxn],pt;
<span class="co">//m[i]是i的最小素因数，p是素数，pt是素数个数</span>
<span class="dt">int</span> make()
{
    phi[<span class="dv">1</span>]=<span class="dv">1</span>;
    <span class="dt">int</span> N=maxn;
    <span class="dt">int</span> k;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;N;i++)
    {
        <span class="kw">if</span>(!m[i])<span class="co">//i是素数</span>
            p[pt++]=m[i]=i,phi[i]=i<span class="dv">-1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;pt&amp;&amp;(k=p[j]*i)&lt;N;j++)
        {
            m[k]=p[j];
            <span class="kw">if</span>(m[i]==p[j])<span class="co">//为了保证以后的数不被再筛，要break</span>
            {
                phi[k]=phi[i]*p[j];
    <span class="co">/*这里的phi[k]与phi[i]后面的∏(p[i]-1)/p[i]都一样</span>
<span class="co">    （m[i]==p[j]）只差一个p[j]，就可以保证∏(p[i]-1)/p[i]前面也一样了*/</span>
                <span class="kw">break</span>;
            }
            <span class="kw">else</span>
                phi[k]=phi[i]*(p[j]<span class="dv">-1</span>);<span class="co">//积性函数性质，f(i*k)=f(i)*f(k)</span>
        }
    }
}

<span class="co">/*直接求解欧拉函数*/</span>
<span class="dt">int</span> phi(<span class="dt">int</span> n)
{
    <span class="dt">int</span> ans=<span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i*i&lt;=n;i++)
    {
        <span class="kw">if</span>(n%i==<span class="dv">0</span>)
        {
            ans*=i<span class="dv">-1</span>;
            n/=i;
            <span class="kw">while</span>(n%i==<span class="dv">0</span>)
            {
                ans*=i;
                n/=i;
            }
        }
    }
    <span class="kw">if</span>(n&gt;<span class="dv">1</span>)ans*=(n<span class="dv">-1</span>);
    <span class="kw">return</span> ans;
}</code></pre></div>
<h2 id="素数筛法"><span class="header-section-number">4.6</span> 素数筛法</h2>
<h3 id="线形筛"><span class="header-section-number">4.6.1</span> 线形筛</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> top;
<span class="dt">int</span> prime[MAXN];
<span class="dt">bool</span> notPrime[MAXN];

<span class="dt">void</span> calcPrime()
{
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;MAXN;i++)
    {
        <span class="kw">if</span>(!notPrime[i])prime[top++]=i;
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;top&amp;&amp;i*prime[j]&lt;MAXN;j++)
        {
            notPrime[i*prime[j]]=<span class="kw">true</span>;
            <span class="kw">if</span>(i%prime[j]==<span class="dv">0</span>)<span class="kw">break</span>;
        }
    }
}</code></pre></div>
<h3 id="复杂度-onfrac34"><span class="header-section-number">4.6.2</span> 复杂度 <span class="math inline">\(O(n^{\frac{3}{4}})\)</span></h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;bits/stdc++.h&gt;</span>
<span class="ot">#define ll long long</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

ll f[<span class="dv">340000</span>],g[<span class="dv">340000</span>],n;

<span class="dt">void</span> init(){
    ll i,j,m;
    <span class="kw">for</span>(m=<span class="dv">1</span>;m*m&lt;=n;++m)f[m]=n/m<span class="dv">-1</span>;
    <span class="kw">for</span>(i=<span class="dv">1</span>;i&lt;=m;++i)g[i]=i<span class="dv">-1</span>;
    <span class="kw">for</span>(i=<span class="dv">2</span>;i&lt;=m;++i){
        <span class="kw">if</span>(g[i]==g[i<span class="dv">-1</span>])<span class="kw">continue</span>;
        <span class="kw">for</span>(j=<span class="dv">1</span>;j&lt;=min(m<span class="dv">-1</span>,n/i/i);++j){
            <span class="kw">if</span>(i*j&lt;m)f[j]-=f[i*j]-g[i<span class="dv">-1</span>];
            <span class="kw">else</span> f[j]-=g[n/i/j]-g[i<span class="dv">-1</span>];
        }
        <span class="kw">for</span>(j=m;j&gt;=i*i;--j)g[j]-=g[j/i]-g[i<span class="dv">-1</span>];
    }
}

<span class="dt">int</span> main(){
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%I64d</span><span class="st">&quot;</span>,&amp;n)!=EOF){
        init();
        cout&lt;&lt;f[<span class="dv">1</span>]&lt;&lt;endl;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h3 id="复杂度-onfrac23"><span class="header-section-number">4.6.3</span> 复杂度 <span class="math inline">\(O(n^{\frac{2}{3}})\)</span></h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="ot">#define LL long long</span>

<span class="dt">const</span> <span class="dt">int</span> N = <span class="fl">5e6</span> + <span class="dv">2</span>;
<span class="dt">bool</span> np[N];
<span class="dt">int</span> prime[N], pi[N];

<span class="dt">int</span> getprime()
{
    <span class="dt">int</span> cnt = <span class="dv">0</span>;
    np[<span class="dv">0</span>] = np[<span class="dv">1</span>] = <span class="kw">true</span>;
    pi[<span class="dv">0</span>] = pi[<span class="dv">1</span>] = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt; N; ++i)
    {
        <span class="kw">if</span>(!np[i]) prime[++cnt] = i;
        pi[i] = cnt;
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; ++j)
        {
            np[i * prime[j]] = <span class="kw">true</span>;
            <span class="kw">if</span>(i % prime[j] == <span class="dv">0</span>)   <span class="kw">break</span>;
        }
    }
    <span class="kw">return</span> cnt;
}

<span class="dt">const</span> <span class="dt">int</span> M = <span class="dv">7</span>;
<span class="dt">const</span> <span class="dt">int</span> PM = <span class="dv">2</span> * <span class="dv">3</span> * <span class="dv">5</span> * <span class="dv">7</span> * <span class="dv">11</span> * <span class="dv">13</span> * <span class="dv">17</span>;
<span class="dt">int</span> phi[PM + <span class="dv">1</span>][M + <span class="dv">1</span>], sz[M + <span class="dv">1</span>];

<span class="dt">void</span> init()
{
    getprime();
    sz[<span class="dv">0</span>] = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= PM; ++i)  phi[i][<span class="dv">0</span>] = i;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= M; ++i)
    {
        sz[i] = prime[i] * sz[i - <span class="dv">1</span>];
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= PM; ++j) 
            phi[j][i] = phi[j][i - <span class="dv">1</span>] - phi[j / prime[i]][i - <span class="dv">1</span>];
    }
}

<span class="dt">int</span> sqrt2(LL x)
{
    LL r = (LL)sqrt(x - <span class="fl">0.1</span>);
    <span class="kw">while</span>(r * r &lt;= x)   ++r;
    <span class="kw">return</span> <span class="dt">int</span>(r - <span class="dv">1</span>);
}

<span class="dt">int</span> sqrt3(LL x)
{
    LL r = (LL)cbrt(x - <span class="fl">0.1</span>);
    <span class="kw">while</span>(r * r * r &lt;= x)   ++r;
    <span class="kw">return</span> <span class="dt">int</span>(r - <span class="dv">1</span>);
}

LL getphi(LL x, <span class="dt">int</span> s)
{
    <span class="kw">if</span>(s == <span class="dv">0</span>)  <span class="kw">return</span> x;
    <span class="kw">if</span>(s &lt;= M)  <span class="kw">return</span> phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];
    <span class="kw">if</span>(x &lt;= prime[s]*prime[s])   <span class="kw">return</span> pi[x] - s + <span class="dv">1</span>;
    <span class="kw">if</span>(x &lt;= prime[s]*prime[s]*prime[s] &amp;&amp; x &lt; N)
    {
        <span class="dt">int</span> s2x = pi[sqrt2(x)];
        LL ans = pi[x] - (s2x + s - <span class="dv">2</span>) * (s2x - s + <span class="dv">1</span>) / <span class="dv">2</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = s + <span class="dv">1</span>; i &lt;= s2x; ++i) ans += pi[x / prime[i]];
        <span class="kw">return</span> ans;
    }
    <span class="kw">return</span> getphi(x, s - <span class="dv">1</span>) - getphi(x / prime[s], s - <span class="dv">1</span>);
}

LL getpi(LL x)
{
    <span class="kw">if</span>(x &lt; N)   <span class="kw">return</span> pi[x];
    LL ans = getphi(x, pi[sqrt3(x)]) + pi[sqrt3(x)] - <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = pi[sqrt3(x)] + <span class="dv">1</span>, ed = pi[sqrt2(x)]; i &lt;= ed; ++i) 
        ans -= getpi(x / prime[i]) - i + <span class="dv">1</span>;
    <span class="kw">return</span> ans;
}

LL lehmer_pi(LL x)
{
    <span class="kw">if</span>(x &lt; N)   <span class="kw">return</span> pi[x];
    <span class="dt">int</span> a = (<span class="dt">int</span>)lehmer_pi(sqrt2(sqrt2(x)));
    <span class="dt">int</span> b = (<span class="dt">int</span>)lehmer_pi(sqrt2(x));
    <span class="dt">int</span> c = (<span class="dt">int</span>)lehmer_pi(sqrt3(x));
    LL sum = getphi(x, a) +(LL)(b + a - <span class="dv">2</span>) * (b - a + <span class="dv">1</span>) / <span class="dv">2</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = a + <span class="dv">1</span>; i &lt;= b; i++)
    {
        LL w = x / prime[i];
        sum -= lehmer_pi(w);
        <span class="kw">if</span> (i &gt; c) <span class="kw">continue</span>;
        LL lim = lehmer_pi(sqrt2(w));
        <span class="kw">for</span> (<span class="dt">int</span> j = i; j &lt;= lim; j++) 
            sum -= lehmer_pi(w / prime[j]) - (j - <span class="dv">1</span>);
    }
    <span class="kw">return</span> sum;
}

<span class="dt">int</span> main()
{
    init();
    LL n;
    <span class="kw">while</span>(~scanf(<span class="st">&quot;</span><span class="ch">%lld</span><span class="st">&quot;</span>,&amp;n))
    {
        printf(<span class="st">&quot;</span><span class="ch">%lld\n</span><span class="st">&quot;</span>,lehmer_pi(n));
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="miller-rabin素性判断"><span class="header-section-number">4.7</span> miller-rabin素性判断</h2>
<h3 id="代码-8"><span class="header-section-number">4.7.1</span> 代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> TIMES = <span class="dv">10</span>;<span class="co">//随机次数</span>

<span class="co">//返回[0, n]之间的一个随机数</span>
ll random0(ll n){
    <span class="kw">return</span> ((<span class="dt">double</span>)rand() / RAND_MAX*n + <span class="fl">0.5</span>);
}

<span class="co">//快速乘a*b%mod</span>
ll quick_mul(ll a, ll b, ll mod){
    ll ans = <span class="dv">0</span>;
    <span class="kw">while</span>(b){
        <span class="kw">if</span>(b&amp;<span class="dv">1</span>){
            ans = (ans+a)%mod;
        }
        b &gt;&gt;= <span class="dv">1</span>;
        a = (a+a) % mod;
    }
    <span class="kw">return</span> ans;
}

<span class="co">//快速幂a^b%mod</span>
ll quick_pow(ll a, ll n, ll mod){
    ll ans = <span class="dv">1</span>;
    <span class="kw">while</span>(n){
        <span class="kw">if</span>(n&amp;<span class="dv">1</span>)ans = quick_mul(ans, a, mod);
        a = quick_mul(a, a, mod);
        n &gt;&gt;= <span class="dv">1</span>;
    }
    <span class="kw">return</span> ans;
}

<span class="dt">bool</span> witness(ll a, ll n){
    ll tmp = n<span class="dv">-1</span>;
    <span class="dt">int</span> i = <span class="dv">0</span>;
    <span class="kw">while</span>(tmp % <span class="dv">2</span> == <span class="dv">0</span>){
        tmp &gt;&gt;= <span class="dv">1</span>;
        i++;
    }
    ll x = quick_pow(a, tmp, n);
    <span class="kw">if</span>(x == <span class="dv">1</span> || x == n<span class="dv">-1</span>)<span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">while</span>(i--){
        x = quick_mul(x, x, n);
        <span class="kw">if</span>(x == n<span class="dv">-1</span>)<span class="kw">return</span> <span class="kw">true</span>;
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">bool</span> miller_rabin(ll n){
    <span class="kw">if</span>(n == <span class="dv">2</span>)<span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">if</span>(n &lt; <span class="dv">2</span> || n % <span class="dv">2</span> == <span class="dv">0</span>)<span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i  = <span class="dv">1</span>; i &lt;= TIMES; i++){
        ll a = random0(n<span class="dv">-2</span>)<span class="dv">+1</span>;
        <span class="kw">if</span>(!witness(a, n))
              <span class="kw">return</span> <span class="kw">false</span>;
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre></div>
<h2 id="莫比乌斯函数"><span class="header-section-number">4.8</span> 莫比乌斯函数</h2>
<h3 id="定义-1"><span class="header-section-number">4.8.1</span> 定义</h3>
<p><span class="math display">\[
\mu = 
\begin{cases} 
1 &amp; n=1 \\ 
(-1)^k &amp; n = p_1p_2\cdots p_k \\
0 &amp; other 
\end{cases}
\]</span></p>
<h3 id="莫比乌斯反演"><span class="header-section-number">4.8.2</span> 莫比乌斯反演</h3>
<p>分数形式:</p>
<p><span class="math display">\[f(n) = \sum_{d|n}g(d)=\sum_{d|n} g(\frac{n}{d})\]</span><br />
<span class="math display">\[g(n) = \sum_{d|n} \mu(d) f(\frac{n}{d}) = \sum_{d|n} \mu(\frac{n}{d})f(d)\]</span></p>
<p>倍数形式:</p>
<p><span class="math display">\[f(n) = \sum_{n|d}g(d)\]</span> <span class="math display">\[g(n) = \sum_{n|d} \mu(\frac{d}{n})f(d)\]</span></p>
<h3 id="技巧-1"><span class="header-section-number">4.8.3</span> 技巧</h3>
<p>若<span class="math inline">\(g(d)=[\frac n d]*[\frac m d]\)</span>之类的阶梯状函数<br />
记录<span class="math inline">\(\mu\)</span>的前缀和</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> d=<span class="dv">1</span>;
<span class="dt">int</span> ans=<span class="dv">0</span>;
<span class="kw">while</span>(d&lt;=min(n,m))
{
    <span class="dt">int</span> last=min(n/(n/d),m/(m/d));
    ans+=(sum[last]-sum[d<span class="dv">-1</span>])*(n/d)*(m/d);
    d=last<span class="dv">+1</span>;
}</code></pre></div>
<h2 id="求原根"><span class="header-section-number">4.9</span> 求原根</h2>
<h3 id="定义-2"><span class="header-section-number">4.9.1</span> 定义</h3>
<p>给定一个数<span class="math inline">\(n\)</span>，若存在一个与 <span class="math inline">\(n\)</span>互素的 <span class="math inline">\(a\)</span>,使得 <span class="math inline">\(a^i(i=0,1,\cdots,\varphi(n))\)</span>在模<span class="math inline">\(n\)</span> 下两两不同,那么称<span class="math inline">\(a\)</span>是<span class="math inline">\(n\)</span>的一个原根。</p>
<h3 id="性质"><span class="header-section-number">4.9.2</span> 性质</h3>
<p><span class="math inline">\(1,2,4,p^n,2p^n\)</span>有原根，其中<span class="math inline">\(p\)</span>是奇素数<br />
一个数<span class="math inline">\(n\)</span>如果有原根，原根个数为 <span class="math inline">\(\varphi(\varphi(n))\)</span><br />
一个数<span class="math inline">\(n\)</span>的全体原根的乘积模 <span class="math inline">\(n\)</span>余1<br />
一个数<span class="math inline">\(n\)</span>的全体原根的总和模 <span class="math inline">\(n\)</span>余 <span class="math inline">\(\mu(n-1)\)</span>(莫比乌斯函数)</p>
<h3 id="头文件全局变量"><span class="header-section-number">4.9.3</span> 头文件&amp;全局变量</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;algorithm&gt;</span>

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="fl">1e6</span> + <span class="dv">6</span>;

<span class="dt">long</span> <span class="dt">long</span> m[maxn], phi[maxn], p[maxn], pt; 
<span class="co">//m[i]是i的最小素因数，p是素数，pt是素数个数</span>
<span class="dt">int</span> n, T;
<span class="dt">long</span> <span class="dt">long</span> sum[maxn];
<span class="dt">int</span> prime[maxn], ptop;
<span class="dt">bool</span> book[maxn]={<span class="dv">0</span>};
<span class="dt">int</span> pr[maxn];</code></pre></div>
<h3 id="辅助函数-8"><span class="header-section-number">4.9.4</span> 辅助函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> gcd(<span class="dt">int</span> a, <span class="dt">int</span> b){
    <span class="kw">return</span> (b&gt;<span class="dv">0</span>)?gcd(b,a%b):a;
}

<span class="dt">void</span> getPrime(<span class="dt">int</span> n) {
    ptop = <span class="dv">0</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; p[i] &lt;= n; i++) {
        <span class="kw">if</span> (n % p[i] == <span class="dv">0</span>) {
            prime[ptop++] = p[i];
            <span class="kw">while</span> (n % p[i] == <span class="dv">0</span>) {
                n /= p[i];
            }
        }
    }
}

<span class="dt">void</span> make() {
    phi[<span class="dv">1</span>] = <span class="dv">1</span>;
    <span class="dt">int</span> N = maxn;
    <span class="dt">int</span> k;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i &lt; N; i++) {
        <span class="kw">if</span> (!m[i]) <span class="co">//i是素数</span>
            p[pt++] = m[i] = i, phi[i] = i - <span class="dv">1</span>, book[i] = <span class="dv">1</span>;
        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; pt &amp;&amp; (k = p[j] * i) &lt; N; j++) {
            m[k] = p[j];
            <span class="kw">if</span> (m[i] == p[j]) <span class="co">//为了保证以后的数不被再筛，要break</span>
            {
                phi[k] = phi[i] * p[j];
                <span class="co">/*这里的phi[k]与phi[i]后面的∏(p[i]-1)/p[i]都一样</span>
<span class="co">                （m[i]==p[j]）只差一个p[j]，</span>
<span class="co">                就可以保证∏(p[i]-1)/p[i]前面也一样了*/</span>
                <span class="kw">break</span>;
            } <span class="kw">else</span>
                phi[k] = phi[i] * (p[j] - <span class="dv">1</span>); 
                <span class="co">//积性函数性质，f(i*k)=f(i)*f(k)</span>
        }
    }
}

<span class="dt">long</span> <span class="dt">long</span> quickPowMod(<span class="dt">long</span> <span class="dt">long</span> a, <span class="dt">int</span> k, <span class="dt">int</span> mod) {
    <span class="dt">long</span> <span class="dt">long</span> ans = <span class="dv">1</span>;
    <span class="kw">while</span> (k) {
        <span class="kw">if</span> (k &amp; <span class="dv">1</span>) {
            ans *= a;
            ans %= mod;
        }
        a *= a;
        a %= mod;
        k /= <span class="dv">2</span>;
    }
    <span class="kw">return</span> ans;
}</code></pre></div>
<h3 id="核心代码-8"><span class="header-section-number">4.9.5</span> 核心代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判断是否有原根</span>
<span class="dt">bool</span> hasPrimitiveRoot(<span class="dt">int</span> n){
    <span class="kw">if</span>(n == <span class="dv">2</span> || n == <span class="dv">4</span>) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">if</span>(book[n]) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">if</span>(n % <span class="dv">2</span> == <span class="dv">0</span>) n /= <span class="dv">2</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>; p[i] &lt;= n; i++){
        <span class="kw">if</span>(n % p[i] == <span class="dv">0</span>){
            <span class="kw">while</span>(n % p[i] == <span class="dv">0</span>){
                n /= p[i];
            }
            <span class="kw">if</span>(n==<span class="dv">1</span>) <span class="kw">return</span> <span class="kw">true</span>;
            <span class="kw">else</span> <span class="kw">return</span> <span class="kw">false</span>;
        }
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">int</span> cntPrimitiveRoot(<span class="dt">int</span> n) {
    <span class="kw">if</span>(!hasPrimitiveRoot(n)){
        printf(<span class="st">&quot;-1</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">return</span> <span class="dv">-1</span>;
    }
    <span class="dt">int</span> cnt = <span class="dv">0</span>;
    <span class="dt">int</span> phi_n = phi[n];
    getPrime(phi_n);
    <span class="co">//枚举</span>
    <span class="kw">if</span>(n == <span class="dv">2</span>){
        cnt = <span class="dv">1</span>;
        printf(<span class="st">&quot;1</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">return</span> <span class="dv">1</span>;
    }
    <span class="kw">for</span> (<span class="dt">int</span> a = <span class="dv">2</span>; a &lt; n; a++) {
        <span class="co">//判断a是否为n的原根</span>
        <span class="dt">bool</span> flag = <span class="kw">true</span>;
        <span class="kw">if</span> (quickPowMod(a, phi_n, n) != <span class="dv">1</span>) <span class="kw">continue</span>;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; ptop; i++) {
            <span class="dt">int</span> k = phi_n / prime[i];
            <span class="kw">if</span> (quickPowMod(a, k, n) == <span class="dv">1</span>) {
                flag = <span class="kw">false</span>;
                <span class="kw">break</span>;
            }
        }
        <span class="kw">if</span> (flag) {
            pr[cnt++] = a;
            <span class="kw">break</span>;
        }
    }
    
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>; i&lt;phi_n; i++){
        <span class="kw">if</span>(gcd(i, phi_n) == <span class="dv">1</span>) pr[cnt++] = quickPowMod(pr[<span class="dv">0</span>], i, n);
    }

    sort(pr, pr+cnt);
    <span class="dt">int</span> prt = unique(pr, pr+cnt) - pr;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;prt; i++){
        printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, pr[i]);
        <span class="kw">if</span>(i!=prt<span class="dv">-1</span>)printf(<span class="st">&quot; &quot;</span>);
        <span class="kw">else</span> printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>); 
    }
    <span class="co">//printf(&quot;%d %lld\n&quot;, cnt, phi[phi[n]]);</span>
    <span class="kw">return</span> phi[phi[n]];
}</code></pre></div>
<h3 id="用法-9"><span class="header-section-number">4.9.6</span> 用法</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main() {
    make();
    <span class="kw">while</span> (~scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n)) {
        cntPrimitiveRoot(n);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="高斯消元"><span class="header-section-number">4.10</span> 高斯消元</h2>
<h3 id="异或-高斯消元"><span class="header-section-number">4.10.1</span> 异或-高斯消元</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> TN&gt;                    <span class="co">//TN为bitset</span>
<span class="dt">int</span> xor_gauss(TN bits[], <span class="dt">int</span> n, <span class="dt">int</span> m) <span class="co">//n行m列</span>
{
    <span class="dt">int</span> i = <span class="dv">0</span>, k = m - <span class="dv">1</span>; <span class="co">//先消高位</span>
    <span class="co">//i枚举行,k枚举列</span>
    <span class="kw">while</span> (i &lt; n &amp;&amp; k &gt;= <span class="dv">0</span>) {
        <span class="dt">int</span> nown = i;
        <span class="kw">while</span> (nown &lt; n &amp;&amp; !bits[nown].test(k))
            nown++;
        <span class="kw">if</span> (nown &lt; n) {
            <span class="kw">for</span> (<span class="dt">int</span> j = nown + <span class="dv">1</span>; j &lt; n; j++)
                <span class="kw">if</span> (bits[j].test(k))
                    bits[j] ^= bits[nown];
            swap(bits[nown], bits[i]);
            i++;
        }
        k--;
    }
    <span class="co">//返回秩</span>
    <span class="kw">return</span> i;
}</code></pre></div>
<h2 id="二次剩余"><span class="header-section-number">4.11</span> 二次剩余</h2>
<h3 id="引用自"><span class="header-section-number">4.11.1</span> 引用自</h3>
<p>http://blog.csdn.net/xf_zhen/article/details/52097988</p>
<h3 id="代码-9"><span class="header-section-number">4.11.2</span> 代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;  </span>
<span class="ot">#include &lt;cstdio&gt;  </span>
<span class="kw">using</span> <span class="kw">namespace</span> std;  

<span class="ot">#define LL long long  </span>

LL quick_mod(LL a,LL b,LL p)<span class="co">//快速幂  </span>
{  
    LL ans = <span class="dv">1</span>;  
    a%=p;  
    <span class="kw">while</span>(b)  
    {  
        <span class="kw">if</span>(b&amp;<span class="dv">1</span>)  
        {  
            ans = ans * a%p;  
            b--;  
        }  
        b&gt;&gt;=<span class="dv">1</span>;  
        a = a*a%p;  
    }  
    <span class="kw">return</span> (ans+p)%p;  
}  
LL Legendre(LL a,LL p)<span class="co">//求勒让得符号（-1,0,1）这里-1返回p-1  </span>
{  
    <span class="kw">return</span> quick_mod(a,(p<span class="dv">-1</span>)&gt;&gt;<span class="dv">1</span>,p);  
}  
<span class="kw">struct</span> T <span class="co">//二次域  </span>
{  
    LL p,d;  
};  
LL w; <span class="co">//二次域第二个单位参数  </span>

LL mod(LL t, LL p)  
{  
    t %=p;  
    <span class="kw">if</span>(t&lt;<span class="dv">0</span>) t+=p;  
    <span class="kw">return</span> t;  
}  
T multi_er(T a,T b, LL p)<span class="co">//二次域乘法  </span>
{  
    T ans;  
    ans.p = (a.p*b.p%p+ a.d*b.d%p*w%p)%p;  
    ans.d = (a.p*b.d%p +a.d*b.p%p)%p;  
    <span class="kw">return</span> ans;  
}  
T pow_er(T a,LL b,LL p)<span class="co">//二次域上的快速幂  </span>
{  
     T ans;  
     ans.p=<span class="dv">1</span>;  
     ans.d =<span class="dv">0</span>;  

    <span class="kw">while</span>(b)  
    {  
        <span class="kw">if</span>(b&amp;<span class="dv">1</span>)  
        {  
           ans = multi_er(ans, a, p);  
            b--;  
        }  
        b&gt;&gt;=<span class="dv">1</span>;  
        a = multi_er(a, a, p);  
    }  
    <span class="kw">return</span> ans;  
}  
<span class="dt">int</span> solve(<span class="dt">int</span> n,<span class="dt">int</span> p)  
{  
    <span class="kw">if</span>(p==<span class="dv">2</span>) <span class="kw">return</span> <span class="dv">1</span>;  
    <span class="kw">if</span>(Legendre(n,p)<span class="dv">+1</span> == p) <span class="kw">return</span> <span class="dv">-1</span>;  
   <span class="co">// printf(&quot;solve ...\n&quot;);  </span>
    LL a = <span class="dv">-1</span>,t;  
    <span class="kw">while</span>(<span class="kw">true</span>)  
    {  
        a = rand()%p;  
        t = a*a -n;  
        w = mod(t,p);  
        <span class="kw">if</span>(Legendre(w,p)<span class="dv">+1</span>==p) <span class="kw">break</span>;  
    }  
    T tmp;  
    tmp.p = a;  
    tmp.d = <span class="dv">1</span>;  
    T ans = pow_er(tmp,(p<span class="dv">+1</span>)&gt;&gt;<span class="dv">1</span>,p);  
    <span class="kw">return</span> ans.p;  
}  
<span class="dt">int</span> main()  
{  
   <span class="dt">int</span> cas;  
   scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;cas);  
   <span class="kw">while</span>(cas--)  
   {  
       <span class="dt">int</span> n,p;  
       scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;n,&amp;p);  
       n %=p;  
       <span class="dt">int</span> a = solve(n,p);  
       <span class="kw">if</span>(a == <span class="dv">-1</span>)  
       {  
           puts(<span class="st">&quot;No root&quot;</span>);  
           <span class="kw">continue</span>;  
       }  
       <span class="kw">else</span>  
       {  
           <span class="dt">int</span> b = p - a;  
           <span class="kw">if</span>(a==b)  
           {  
               printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>,a);  
           }  
           <span class="kw">else</span>  
           {  
               <span class="kw">if</span>(a&gt;b) swap(a,b);  
               printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>,a,b);  
           }  
       }  
   }  
    <span class="kw">return</span> <span class="dv">0</span>;  
}</code></pre></div>
<h2 id="离散对数"><span class="header-section-number">4.12</span> 离散对数</h2>
<h3 id="问题描述"><span class="header-section-number">4.12.1</span> 问题描述</h3>
<p>给定B、N、P，求一个整数L满足 <span class="math inline">\(B^L \equiv N \ (mod \ P)\)</span></p>
<h3 id="全局变量-宏"><span class="header-section-number">4.12.2</span> 全局变量 &amp; 宏</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#define MOD 76543</span>
<span class="dt">int</span> hs[MOD],head[MOD],next[MOD],id[MOD],top;</code></pre></div>
<h3 id="辅助函数-9"><span class="header-section-number">4.12.3</span> 辅助函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> insert(<span class="dt">int</span> x,<span class="dt">int</span> y)
{
    <span class="dt">int</span> k = x%MOD;
    hs[top] = x, id[top] = y, next[top] = head[k], head[k] = top++;
}
<span class="dt">int</span> find(<span class="dt">int</span> x)
{
    <span class="dt">int</span> k = x%MOD;
    <span class="kw">for</span>(<span class="dt">int</span> i = head[k]; i != <span class="dv">-1</span>; i = next[i])
        <span class="kw">if</span>(hs[i] == x)
            <span class="kw">return</span> id[i];
    <span class="kw">return</span> <span class="dv">-1</span>;
}</code></pre></div>
<h3 id="bsgs算法"><span class="header-section-number">4.12.4</span> BSGS算法</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//a^ans = b (mod n)</span>
<span class="dt">int</span> BSGS(<span class="dt">int</span> a,<span class="dt">int</span> b,<span class="dt">int</span> n)
{
    memset(head,<span class="dv">-1</span>,<span class="kw">sizeof</span>(head));
    top = <span class="dv">1</span>;
    <span class="kw">if</span>(b == <span class="dv">1</span>)<span class="kw">return</span> <span class="dv">0</span>;
    <span class="dt">int</span> m = sqrt(n*<span class="fl">1.0</span>), j;
    <span class="dt">long</span> <span class="dt">long</span> x = <span class="dv">1</span>, p = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; ++i, p = p*a%n)insert(p*b%n,i);
    <span class="kw">for</span>(<span class="dt">long</span> <span class="dt">long</span> i = m; ;i += m)
    {
        <span class="kw">if</span>( (j = find(x = x*p%n)) != <span class="dv">-1</span> )<span class="kw">return</span> i-j;
        <span class="kw">if</span>(i &gt; n)<span class="kw">break</span>;
    }
    <span class="kw">return</span> <span class="dv">-1</span>;
}</code></pre></div>
<h3 id="用法-10"><span class="header-section-number">4.12.5</span> 用法</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> P,B,N;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>,&amp;P,&amp;B,&amp;N) == <span class="dv">3</span>)
    {
        <span class="dt">int</span> ans = BSGS(B,N,P);
        <span class="kw">if</span>(ans == <span class="dv">-1</span>)printf(<span class="st">&quot;no solution</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">else</span> printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>,ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="扩展离散对数"><span class="header-section-number">4.13</span> 扩展离散对数</h2>
<h3 id="问题描述-1"><span class="header-section-number">4.13.1</span> 问题描述</h3>
<p>给定B、N、P，求一个整数L满足 <span class="math inline">\(B^L \equiv N \ (mod \ P)\)</span></p>
<h3 id="全局变量结构体宏"><span class="header-section-number">4.13.2</span> 全局变量&amp;结构体&amp;宏</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>
 
<span class="ot">#define MAXN 65536</span>

<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;
 
<span class="kw">struct</span> LINK{
    ll data;
    ll j;
    ll next;
}HASH_LINK[<span class="dv">1000000</span>];
ll ad, head[MAXN];</code></pre></div>
<h3 id="辅助函数-10"><span class="header-section-number">4.13.3</span> 辅助函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">ll Gcd(ll a, ll b){
<span class="kw">return</span> b ? Gcd(b, a % b) : a;
}
 
ll Ext_Gcd(ll a, ll b, ll &amp;x, ll &amp;y){
    <span class="kw">if</span>(!b){
       x = <span class="dv">1</span>; y = <span class="dv">0</span>;
       <span class="kw">return</span> a;
    }
    ll r = Ext_Gcd(b, a % b, x, y);
    ll t = x; x = y; y = t - a / b * y;
    <span class="kw">return</span> r;
}
 
ll POWER(ll a, ll b, ll c){
    ll ans = <span class="dv">1</span>;
    <span class="kw">while</span>(b){
       <span class="kw">if</span>(b &amp; <span class="dv">1</span>) ans = ans * a % c;
       a = a * a % c;
       b &gt;&gt;= <span class="dv">1</span>;
    }
    <span class="kw">return</span> ans;
}
 
<span class="dt">void</span> clear(){
    memset(head, <span class="dv">-1</span>, <span class="kw">sizeof</span>(head));
    ad = <span class="dv">0</span>;
}
 
ll hash(ll a){
    <span class="kw">return</span> a % MAXN;
}
 
<span class="dt">void</span> INSERT_HASH(ll i, ll buf){
    ll hs = hash(buf), tail;
    <span class="kw">for</span>(tail = head[hs]; ~tail; tail = HASH_LINK[tail]. next)
       <span class="kw">if</span>(buf == HASH_LINK[tail]. data) <span class="kw">return</span>;
    HASH_LINK[ad]. data = buf;
    HASH_LINK[ad]. j    = i;
    HASH_LINK[ad]. next = head[hs];
    head[hs] = ad ++;
}</code></pre></div>
<h3 id="扩展bsgs算法"><span class="header-section-number">4.13.4</span> 扩展BSGS算法</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// a^ans = b(mod c)</span>
ll bady_step_giant_step(ll a, ll b, ll c){
    ll i, buf, m, temp, g, D, x, y, n = <span class="dv">0</span>;
    <span class="kw">for</span>(i = <span class="dv">0</span>, buf = <span class="dv">1</span>; i &lt; <span class="dv">100</span>; i ++, buf = buf * a % c)
       <span class="kw">if</span>(buf == b) <span class="kw">return</span> i;
    D = <span class="dv">1</span>;
    <span class="kw">while</span>((g = Gcd(a, c)) != <span class="dv">1</span>){
       <span class="kw">if</span>(b % g) <span class="kw">return</span> <span class="dv">-1</span>; <span class="co">// g | b 不满足，则说明无解</span>
       b /= g;
       c /= g;
       D = D * a / g % c;
       ++ n;
    }
    clear();
    m = ceil(sqrt((<span class="dt">long</span> <span class="dt">double</span>) c));
    <span class="kw">for</span>(i = <span class="dv">0</span>, buf = <span class="dv">1</span>; i &lt;= m; buf = buf * a % c, i ++) INSERT_HASH(i, buf);
    <span class="kw">for</span>(i = <span class="dv">0</span>, temp = POWER(a, m, c), buf = D; i &lt;= m; i ++, buf = temp * buf % c){
       Ext_Gcd(buf, c, x, y);
       x = ((x * b) % c + c) % c;
       <span class="kw">for</span>(ll tail = head[hash(x)]; ~tail; tail = HASH_LINK[tail].next)
           <span class="kw">if</span>(HASH_LINK[tail]. data == x) <span class="kw">return</span> HASH_LINK[tail].j + n + i * m;
    }
    <span class="kw">return</span> <span class="dv">-1</span>;
}</code></pre></div>
<h3 id="用法-11"><span class="header-section-number">4.13.5</span> 用法</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//k^ans = n(mod p) </span>
<span class="dt">int</span> main(){
    ll k, p, n, ans;
    <span class="kw">while</span>(~scanf(<span class="st">&quot;</span><span class="ch">%lld</span><span class="st"> </span><span class="ch">%lld</span><span class="st"> </span><span class="ch">%lld</span><span class="st">&quot;</span>, &amp;k, &amp;p, &amp;n)){
       <span class="kw">if</span>(n &gt;= p){ printf(<span class="st">&quot;Orz,I can’t find D!</span><span class="ch">\n</span><span class="st">&quot;</span>); <span class="kw">continue</span>; }
       ans = bady_step_giant_step(k, n, p);
       ans == <span class="dv">-1</span> ? printf(<span class="st">&quot;Orz,I can’t find D!</span><span class="ch">\n</span><span class="st">&quot;</span>) : printf(<span class="st">&quot;</span><span class="ch">%lld\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="pollard_rho-质因子分解"><span class="header-section-number">4.14</span> Pollard_rho 质因子分解</h2>
<h3 id="环境-1"><span class="header-section-number">4.14.1</span> 环境</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;cstdlib&gt;</span>
<span class="ot">#include&lt;ctime&gt;</span>

<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL;
<span class="ot">#define MAXN 10000</span>

LL factor[MAXN];
<span class="dt">int</span> tot;
<span class="dt">const</span> <span class="dt">int</span> S=<span class="dv">20</span>;</code></pre></div>
<h3 id="辅助函数-11"><span class="header-section-number">4.14.2</span> 辅助函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">LL muti_mod(LL a,LL b,LL c){    <span class="co">//返回(a*b) mod c,a,b,c&lt;2^63</span>
    a%=c;
    b%=c;
    LL ret=<span class="dv">0</span>;
    <span class="kw">while</span> (b){
        <span class="kw">if</span> (b&amp;<span class="dv">1</span>){
            ret+=a;
            <span class="kw">if</span> (ret&gt;=c) ret-=c;
        }
        a&lt;&lt;=<span class="dv">1</span>;
        <span class="kw">if</span> (a&gt;=c) a-=c;
        b&gt;&gt;=<span class="dv">1</span>;
    }
    <span class="kw">return</span> ret;
}

LL pow_mod(LL x,LL n,LL mod){  <span class="co">//返回x^n mod c ,非递归版</span>
    <span class="kw">if</span> (n==<span class="dv">1</span>) <span class="kw">return</span> x%mod;
    <span class="dt">int</span> bit[<span class="dv">90</span>],k=<span class="dv">0</span>;
    <span class="kw">while</span> (n){
        bit[k++]=n&amp;<span class="dv">1</span>;
        n&gt;&gt;=<span class="dv">1</span>;
    }
    LL ret=<span class="dv">1</span>;
    <span class="kw">for</span> (k=k<span class="dv">-1</span>;k&gt;=<span class="dv">0</span>;k--){
        ret=muti_mod(ret,ret,mod);
        <span class="kw">if</span> (bit[k]==<span class="dv">1</span>) ret=muti_mod(ret,x,mod);
    }
    <span class="kw">return</span> ret;
}

<span class="dt">bool</span> check(LL a,LL n,LL x,LL t){   <span class="co">//以a为基，n-1=x*2^t，检验n是不是合数</span>
    LL ret=pow_mod(a,x,n),last=ret;
    <span class="kw">for</span> (<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=t;i++){
        ret=muti_mod(ret,ret,n);
        <span class="kw">if</span> (ret==<span class="dv">1</span> &amp;&amp; last!=<span class="dv">1</span> &amp;&amp; last!=n<span class="dv">-1</span>) <span class="kw">return</span> <span class="dv">1</span>;
        last=ret;
    }
    <span class="kw">if</span> (ret!=<span class="dv">1</span>) <span class="kw">return</span> <span class="dv">1</span>;
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">bool</span> Miller_Rabin(LL n){
    LL x=n<span class="dv">-1</span>,t=<span class="dv">0</span>;
    <span class="kw">while</span> ((x&amp;<span class="dv">1</span>)==<span class="dv">0</span>) x&gt;&gt;=<span class="dv">1</span>,t++;
    <span class="dt">bool</span> flag=<span class="dv">1</span>;
    <span class="kw">if</span> (t&gt;=<span class="dv">1</span> &amp;&amp; (x&amp;<span class="dv">1</span>)==<span class="dv">1</span>){
        <span class="kw">for</span> (<span class="dt">int</span> k=<span class="dv">0</span>;k&lt;S;k++){
            LL a=rand()%(n<span class="dv">-1</span>)<span class="dv">+1</span>;
            <span class="kw">if</span> (check(a,n,x,t)) {flag=<span class="dv">1</span>;<span class="kw">break</span>;}
            flag=<span class="dv">0</span>;
        }
    }
    <span class="kw">if</span> (!flag || n==<span class="dv">2</span>) <span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">return</span> <span class="dv">1</span>;
}

LL gcd(LL a,LL b){
    <span class="kw">if</span> (a==<span class="dv">0</span>) <span class="kw">return</span> <span class="dv">1</span>;
    <span class="kw">if</span> (a&lt;<span class="dv">0</span>) <span class="kw">return</span> gcd(-a,b);
    <span class="kw">while</span> (b){
        LL t=a%b; a=b; b=t;
    }
    <span class="kw">return</span> a;
}</code></pre></div>
<h3 id="核心代码-9"><span class="header-section-number">4.14.3</span> 核心代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//找出任意质因数</span>
LL Pollard_rho(LL x,LL c){ 
    LL i=<span class="dv">1</span>,x0=rand()%x,y=x0,k=<span class="dv">2</span>;
    <span class="kw">while</span> (<span class="dv">1</span>){
        i++;
        x0=(muti_mod(x0,x0,x)+c)%x;
        LL d=gcd(y-x0,x);
        <span class="kw">if</span> (d!=<span class="dv">1</span> &amp;&amp; d!=x){
            <span class="kw">return</span> d;
        }
        <span class="kw">if</span> (y==x0) <span class="kw">return</span> x;
        <span class="kw">if</span> (i==k){
            y=x0;
            k+=k;
        }
    }
}

<span class="co">//递归进行质因数分解N</span>
<span class="dt">void</span> findfac(LL n){           
    <span class="kw">if</span> (!Miller_Rabin(n)){
        factor[tot++] = n;
        <span class="kw">return</span>;
    }
    LL p=n;
    <span class="kw">while</span> (p&gt;=n) p=Pollard_rho(p,rand() % (n<span class="dv">-1</span>) <span class="dv">+1</span>);
    findfac(p);
    findfac(n/p);
}</code></pre></div>
<h3 id="用法-12"><span class="header-section-number">4.14.4</span> 用法</h3>
<p>初始化tot=0，调用findfac(n)，factor[0~tot-1]中为n的全部质因子</p>
<h2 id="fft"><span class="header-section-number">4.15</span> FFT</h2>
<h3 id="定义公式"><span class="header-section-number">4.15.1</span> 定义&amp;公式</h3>
<p>时间复杂度<span class="math inline">\(\Theta \left ( nlog \left ( n \right ) \right )\)</span><br />
FFT（Fast Fourier Transformation）是离散傅氏变换（DFT）的快速算法。即为快速傅氏变换。它是根据离散傅氏变换的奇、偶、虚、实等特性，对离散傅立叶变换的算法进行改进获得的。</p>
<p>令 <span class="math inline">\(W_N=e^{-i \frac{2\pi }{N} }\)</span><br />
DFT : <span class="math inline">\(X \left( k \right) = \sum_{n=0}^{N-1}x \left( n \right)W_N^{nk} ,k=0,1,\cdots,N-1\)</span><br />
IDFT: <span class="math inline">\(x \left( n \right) = \frac{1}{N} \sum_{k=0}^{N-1}X \left( k \right)W_N^{-nk} ,n=0,1,\cdots,N-1\)</span></p>
<h3 id="推导"><span class="header-section-number">4.15.2</span> 推导</h3>
<p>若N为偶数,且<span class="math inline">\(k&lt;\frac{n}{2}\)</span>,则</p>
<p><span class="math display">\[
\begin{aligned}
X\left ( k \right ) 
 &amp;=\sum_{n=0}^{N-1}x \left( n \right ) e^{-i2\pi kn/N} \\ 
 &amp;=\sum_{m=0}^{\frac{N}{2}-1}x \left( 2m \right ) e^{-i2\pi km/\frac{N}{2}}
   +
   e^{-i2\pi k/N}\sum_{m=0}^{\frac{N}{2}-1}x \left( 2m+1 \right ) e^{-i2\pi km/\frac{N}{2}} \\ 
 &amp;=X_1\left( k \right ) + W_N^{k}X_2\left( k \right )
\end{aligned}
\]</span></p>
<p>其中对偶数项做FFT得到<span class="math inline">\(X_1\left( k \right )\)</span>,对奇数项做FFT得到<span class="math inline">\(X_2\left( k \right )\)</span><br />
其中<span class="math inline">\(X_1\left( k \right )\)</span>为第k个偶数项的DFT值<br />
由于<span class="math inline">\(e^{i\pi 2n}=1,n\in \mathbb{Z}\)</span>且<span class="math inline">\(e^{i\pi \left(2n+1\right)}=-1,n\in \mathbb{Z}\)</span></p>
<p><span class="math display">\[
\begin{aligned}
X\left ( k+\frac{N}{2} \right ) 
 &amp;=e^{-i\pi 2m}\sum_{m=0}^{\frac{N}{2}-1}x \left( 2m \right ) e^{-i2\pi km/\frac{N}{2}}
   +
   e^{-i\pi \left(2m+1\right)}\cdot e^{-i2\pi k/N}\sum_{m=0}^{\frac{N}{2}-1}x \left( 2m+1 \right ) e^{-i2\pi km/\frac{N}{2}} \\ 
 &amp;=X_1\left( k \right ) - W_N^{k}X_2\left( k \right )
\end{aligned}
\]</span></p>
<p>这样<span class="math inline">\(X\)</span>每一项都可通过<span class="math inline">\(X_1\)</span>和<span class="math inline">\(X_2\)</span>求出</p>
<h3 id="头文件全局变量-1"><span class="header-section-number">4.15.3</span> 头文件&amp;全局变量</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;complex&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>

<span class="kw">typedef</span> complex&lt;<span class="dt">double</span>&gt; Complex;
<span class="dt">const</span> <span class="dt">double</span> PI=acos(<span class="fl">-1.0</span>);</code></pre></div>
<h3 id="辅助函数-12"><span class="header-section-number">4.15.4</span> 辅助函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> lowbit(<span class="dt">int</span> x)
{
    <span class="kw">return</span> x&amp;-x;
}</code></pre></div>
<h3 id="可选函数"><span class="header-section-number">4.15.5</span> 可选函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> getN(<span class="dt">int</span> n)<span class="co">//返回大于等于n的最小的2^t的值</span>
{
    <span class="dt">int</span> nn=<span class="dv">1</span>;
    <span class="kw">while</span>(nn&lt;n)nn&lt;&lt;=<span class="dv">1</span>;
    <span class="kw">return</span> nn;
}

<span class="co">//规则化数组,使长度n变为2^t的形式,并在多余部分填充0</span>
<span class="dt">void</span> normalize(Complex x[],<span class="dt">int</span> &amp;n)
{
    <span class="dt">int</span> nn=getN(n);
    fill(x+n,x+nn,<span class="dv">0</span>);
    n=nn;
}</code></pre></div>
<h3 id="核心代码-10"><span class="header-section-number">4.15.6</span> 核心代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//n必须为2^t,若不是,用normalize转换</span>
<span class="co">//on==1为DFT,on==-1为IDFT</span>
<span class="dt">void</span> fft(Complex x[],<span class="dt">int</span> n,<span class="dt">int</span> on=<span class="dv">1</span>)
{
    <span class="co">//循环模拟递归向下数组最终样子,位置i和(i二进制对称的数)互换就行了</span>
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;n;i++)
    {
        <span class="dt">int</span> j=<span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> k=i;k;k^=lowbit(k))
            j|=n/lowbit(k);
        j&gt;&gt;=<span class="dv">1</span>;
        <span class="kw">if</span>(i&lt;j)swap(x[i],x[j]);
    }

    <span class="co">//循环模拟递归回溯</span>
    <span class="dt">double</span> ww=<span class="fl">-2.0</span>*PI*on;<span class="co">//中间变量,字面上意思</span>
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>,j=<span class="dv">2</span>;j&lt;=n;i&lt;&lt;=<span class="dv">1</span>,j&lt;&lt;=<span class="dv">1</span>)
    {
        Complex wn(cos(ww/j),sin(ww/j));
        <span class="kw">for</span>(<span class="dt">int</span> k=<span class="dv">0</span>;k&lt;n;k+=j)
        {
            Complex w(<span class="fl">1.0</span>);
            <span class="kw">for</span>(<span class="dt">int</span> t=k;t&lt;k+i;t++)
            {
                Complex a(x[t]);
                Complex b(x[t+i]*w);
                x[t]=a+b;
                x[t+i]=a-b;
                w*=wn;
            }
        }
    }

    <span class="kw">if</span>(on==<span class="dv">-1</span>)
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++)
            x[i]/=n;
}</code></pre></div>
<h3 id="使用例子"><span class="header-section-number">4.15.7</span> 使用例子</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//求两个大数相乘a[0~n-1]*b[0~m-1]</span>
<span class="dt">int</span> nn=getN(max(n,m))&lt;&lt;<span class="dv">1</span>;<span class="co">//大于等于位数的两倍</span>
fill(a+n,a+nn,<span class="dv">0</span>);
fill(b+m,b+nn,<span class="dv">0</span>);<span class="co">//末尾填充0</span>
n=nn;
fft(a,n);
fft(b,n);
<span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++)
    a[i]*=b[i];
fft(a,n,<span class="dv">-1</span>);
<span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++)
    ans[i]=floor(a[i].real()<span class="fl">+0.5</span>);
<span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++)
{
    ans[i<span class="dv">+1</span>]+=ans[i]/<span class="dv">10</span>;
    ans[i]%=<span class="dv">10</span>;
}</code></pre></div>
<h1 id="组合数学"><span class="header-section-number">5</span> 组合数学</h1>
<h2 id="第一类斯特林数"><span class="header-section-number">5.1</span> 第一类斯特林数</h2>
<h3 id="定义-3"><span class="header-section-number">5.1.1</span> 定义</h3>
<p>把n个元素分成k个环排列的方法数。<br />
边界值：<span class="math inline">\(S_1(n,0)=0\)</span> <span class="math inline">\(S_1(n,n)=1\)</span><br />
递推式：<span class="math inline">\(S_1(n+1, k) = S_1(n, k-1)+nS_1(n,k)\)</span></p>
<h3 id="递推初始化"><span class="header-section-number">5.1.2</span> 递推初始化</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> init(){
    <span class="kw">for</span>(ll i=<span class="dv">1</span>; i&lt;MAXN; i++){
        S[i][<span class="dv">0</span>] = <span class="dv">0</span>;
        S[i][i] = <span class="dv">1</span>;
        <span class="kw">for</span>(ll j=<span class="dv">1</span>; j&lt;i; j++){
            S[i][j] = (((i<span class="dv">-1</span>)*S[i<span class="dv">-1</span>][j])%MOD+S[i<span class="dv">-1</span>][j<span class="dv">-1</span>])%MOD;
        }
    }
}</code></pre></div>
<h2 id="第二类斯特林数"><span class="header-section-number">5.2</span> 第二类斯特林数</h2>
<h3 id="定义-4"><span class="header-section-number">5.2.1</span> 定义</h3>
<p>把n个元素分为k个非空子集的方案数<br />
边界值：<span class="math inline">\(S_2(n,0)=0\)</span> <span class="math inline">\(S_2(n,n)=1\)</span><br />
递推式：<span class="math inline">\(S_2(n+1, k) = S_2(n, k-1)+kS_2(n,k)\)</span></p>
<h3 id="递推初始化-1"><span class="header-section-number">5.2.2</span> 递推初始化</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> init() {
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= <span class="dv">100</span>; i++) {
        S2[i][<span class="dv">0</span>] = <span class="dv">0</span>, S2[i][i] = <span class="dv">1</span>;
        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt; i; j++) {
            S2[i][j] = (S2[i - <span class="dv">1</span>][j - <span class="dv">1</span>] + (j * S2[i - <span class="dv">1</span>][j]) % MOD) % MOD;
        }
    }
}</code></pre></div>
<h3 id="常见用法"><span class="header-section-number">5.2.3</span> 常见用法</h3>
<p>把n个小球放入k个盒子中 * 盒子不能为空，不可区分： <span class="math inline">\(S_2(n, k)\)</span> * 盒子能为空，不可区分： <span class="math inline">\(\sum_{i=1}^k{S_2(n, i)}\)</span> * 盒子不能为空，可区分： <span class="math inline">\(k!S_2(n, k)\)</span></p>
<h2 id="分拆数"><span class="header-section-number">5.3</span> 分拆数</h2>
<h3 id="定义-5"><span class="header-section-number">5.3.1</span> 定义</h3>
<p>把正整数n拆分为至多k个正整数之和的方案数。<br />
把正整数n拆分为不超过k的若干个正整数之和的方案数。</p>
<h3 id="dp递推"><span class="header-section-number">5.3.2</span> DP递推</h3>
<p>复杂度： <span class="math inline">\(O(n^2)\)</span><br />
初始值：<span class="math inline">\(dp[0][0]=1\ \ \ dp[n][0]=0\)</span><br />
递推：</p>
<p><span class="math display">\[
\begin{aligned}
&amp; dp[n][m]=dp[n][m-1]+dp[n-m][m]\ \ \ (n \geqslant  m) \\
&amp; dp[n][m] = dp[n][n] \ \ \ (n &lt; m)
\end{aligned}
\]</span></p>
<h3 id="母函数"><span class="header-section-number">5.3.3</span> 母函数</h3>
<p>复杂度： <span class="math inline">\(O(n\sqrt{n})\)</span></p>
<h4 id="推导-1"><span class="header-section-number">5.3.3.1</span> 推导</h4>
<p>正整数n的划分可以用母函数表示为</p>
<p><span class="math display">\[
\sum_{i=0}^{\infty}p(i)x^i = (1+x^1+x^2+\cdots)(1+x^2+x^4+\cdots)(1+x^3+x^6+\cdots)\cdots
\]</span></p>
<p>对其进行等比数列求和，可得</p>
<p><span class="math display">\[
\sum_{i=0}^{\infty}p(i)x^i = \prod_{k=1}^{\infty}(\frac{1}{1-x^k})
\]</span></p>
<p>将<span class="math inline">\(\prod^{\infty}_{k=1}(\frac{1}{1-x^k})\)</span>展开可得：</p>
<p><span class="math display">\[
(1-x)(1-x^2)(1-x^3)\cdots = 1 -x - x^2 + x^5 + x^7 - x^{12} - x^{15} + x^{22} + x^{26} + \cdots
\]</span></p>
<p>观察可得：<br />
指数即扩展五边形数（下一列为对应下标）：</p>
<p><span class="math display">\[
\begin{matrix}
&amp; 0 &amp; 1 &amp; 2 &amp; 5 &amp; 7 &amp; 12 &amp; 15 \\
&amp; 0 &amp; 1 &amp; -1 &amp; 2 &amp; -2 &amp; 3 &amp; -3 
\end{matrix}
\]</span></p>
<p>*扩展五边形数：<span class="math inline">\(Five(x)=\frac{3x^2-x}{2}\)</span></p>
<p>令<span class="math inline">\(Q(x)=\prod^{\infty}_{k=1}{(1-x^k)}\)</span>，所以<span class="math inline">\(Q(x)P(x) = 1\)</span>，即：</p>
<p><span class="math display">\[
(p(0)x^0+p(1)x^1+p(2)x^2+\cdots)(1-x-x^2+x^5+x^7-x^22\cdots) = 1
\]</span></p>
<p>所以<span class="math inline">\(p(k) = p(k-1) + p(k-2) - p(k-5) \cdots\)</span></p>
<h4 id="应用"><span class="header-section-number">5.3.3.2</span> 应用</h4>
<p>要求拆分的数中每个数出现的次数不能大于等于k此，则</p>
<p><span class="math display">\[
\begin{aligned}
P_k(x) \ 
&amp; = (1+x+x^2+ \cdots +x^{k-1})(1+x^2+x^4+\cdots + c^{2(k-1)})\cdots \\
&amp; = \prod^{\infty}_{i=1}{\frac {1-x^{ki}} {1-x^{i}}} \\
&amp; = \frac {Q(x^k)} {Q(x)} \\
&amp; = Q(x^k)P(x)
\end{aligned}
\]</span></p>
<p>例如：当<span class="math inline">\(n=8, k=4\)</span>时：</p>
<p><span class="math display">\[
Q(x^4)P(x) = (1-x^4-x^8+x^{12}+\cdots)P(x)
\]</span></p>
<p>满足指数为8的项的和：<span class="math inline">\(1\times 22x^8 - x^4 \times 5 x^4 - x^8 \times 1 = 16 x^8\)</span></p>
<ul>
<li>示例代码：</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;string&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> __int64 LL;
<span class="dt">const</span> <span class="dt">int</span> Maxn=<span class="dv">100010</span>;
<span class="dt">const</span> LL MOD=<span class="dv">1000000007</span>;
LL Q[Maxn],P[Maxn];
LL GetQ(LL x)
{
    LL ans=(LL)x*x*<span class="dv">3</span>-x;
    <span class="kw">return</span> (ans/<span class="dv">2</span>)%MOD;
}
<span class="dt">void</span> _init()
{
    Q[<span class="dv">0</span>]=<span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;Maxn;i++)
    {
        <span class="kw">if</span>(i&amp;<span class="dv">1</span>) Q[i]=GetQ(i/<span class="dv">2+1</span>);
        <span class="kw">else</span> Q[i]=GetQ(i/<span class="dv">2</span>*(<span class="dv">-1</span>));
    }
    P[<span class="dv">0</span>]=P[<span class="dv">1</span>]=<span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;Maxn;i++)
    {
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">1</span>;;j++)
        {
            <span class="kw">if</span>(Q[j]&gt;i) <span class="kw">break</span>;
            <span class="dt">int</span> t=j;
            <span class="kw">if</span>(t&amp;<span class="dv">1</span>) t=t/<span class="dv">2+1</span>;
            <span class="kw">else</span> t=t/<span class="dv">2</span>;
            <span class="kw">if</span>(t&amp;<span class="dv">1</span>)
                P[i]=(P[i]+P[i-Q[j]]);
            <span class="kw">else</span>
                P[i]=(P[i]-P[i-Q[j]]);
            <span class="kw">if</span>(P[i]&gt;=MOD) P[i]%=MOD;
            <span class="kw">if</span>(P[i]&lt;<span class="dv">0</span>) P[i]+=MOD;
        }
    }
}
<span class="dt">void</span> solved(LL n,LL k)
{
    LL ans=<span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;;i++)
    {
        <span class="kw">if</span>(Q[i]*k&gt;n) <span class="kw">break</span>;
        <span class="dt">int</span> t=i;
        <span class="kw">if</span>(t&amp;<span class="dv">1</span>) t=t/<span class="dv">2+1</span>;
        <span class="kw">else</span> t=t/<span class="dv">2</span>;
        <span class="kw">if</span>(t&amp;<span class="dv">1</span>) ans=(ans-P[n-Q[i]*k]);
        <span class="kw">else</span> ans=(ans+P[n-Q[i]*k]);
        <span class="kw">if</span>(ans&gt;=MOD) ans%=MOD;
        <span class="kw">if</span>(ans&lt;<span class="dv">0</span>) ans+=MOD;
    }
    printf(<span class="st">&quot;</span><span class="ch">%I64d\n</span><span class="st">&quot;</span>,ans);
}
<span class="dt">int</span> main()
{
    _init();
    <span class="dt">int</span> T;
    LL n,k;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;T);
    <span class="kw">while</span>(T--)
    {
        scanf(<span class="st">&quot;</span><span class="ch">%I64d%I64d</span><span class="st">&quot;</span>,&amp;n,&amp;k);
        solved(n,k);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h3 id="性质-1"><span class="header-section-number">5.3.4</span> 性质</h3>
<p>限制拆分结论：<br />
* “将一个正整数n拆为若干个两两不同的正整数之和” 与 “将一个正整数n拆为若干个奇数之和”的方案数相同 * “把正整数n拆分为至多k个正整数之和” 与 “把正整数n拆分为不超过k的若干个正整数之和”的方案数相同 * “把正整数n拆分为若干个相等的正整数之和”的方案数为n的因子个数</p>
<h3 id="代码-10"><span class="header-section-number">5.3.5</span> 代码</h3>
<h4 id="环境-2"><span class="header-section-number">5.3.5.1</span> 环境</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL;

<span class="dt">const</span> <span class="dt">int</span> MAXN = <span class="dv">100010</span>;
<span class="dt">const</span> LL MOD = <span class="dv">1000000007</span>;

LL dp[MAXN]={<span class="dv">0</span>};</code></pre></div>
<h4 id="辅助函数-13"><span class="header-section-number">5.3.5.2</span> 辅助函数</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">LL Five(LL x) { <span class="co">//计算正五边形数</span>
    LL ans = <span class="dv">3</span> * x * x - x;
    <span class="kw">return</span> ans / <span class="dv">2</span>;
}

<span class="dt">bool</span> change(<span class="dt">int</span> i, <span class="dt">int</span> j) {
    LL k = Five(j);
    <span class="kw">if</span> (k &gt; i) <span class="kw">return</span> <span class="kw">false</span>;

    <span class="kw">if</span> (j % <span class="dv">2</span> == <span class="dv">0</span>) <span class="co">//判断奇偶从而判断系数为正还是为负</span>
        dp[i] = (dp[i] - dp[i - k]);
    <span class="kw">else</span>
        dp[i] = (dp[i] + dp[i - k]);
    (dp[i] += MOD) %= MOD;

    <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre></div>
<h4 id="递推母函数初始化"><span class="header-section-number">5.3.5.3</span> 递推母函数初始化</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> init() {
    dp[<span class="dv">0</span>] = <span class="dv">1</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; MAXN; i++)
        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>;change(i,j)&amp;&amp;change(i,-j); j++);
}</code></pre></div>
<h4 id="用法-13"><span class="header-section-number">5.3.5.4</span> 用法</h4>
<p>调用init()后，dp数组内dp[i]表示将正整数划分为若干个正整数之和的方案数。</p>
<h2 id="错排"><span class="header-section-number">5.4</span> 错排</h2>
<h3 id="定义-6"><span class="header-section-number">5.4.1</span> 定义</h3>
<p>将n个不同的元素重新排列后每个元素都不放在自己原来位置上的方法数</p>
<h3 id="递推"><span class="header-section-number">5.4.2</span> 递推</h3>
<p><span class="math display">\[F(i) = (i-1)\times (\ F(i-1)+F(i-2)\ )\]</span></p>
<h3 id="代码-11"><span class="header-section-number">5.4.3</span> 代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//初始化错排函数，循环节为2*mod</span>
<span class="dt">void</span> initF(LL n, LL mod) {
    F[<span class="dv">0</span>] = <span class="dv">1</span>, F[<span class="dv">1</span>] = <span class="dv">0</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i &lt; <span class="dv">2</span> * mod; i++)
        F[i] = LL(i - <span class="dv">1</span>) * (F[i - <span class="dv">1</span>] + F[i - <span class="dv">2</span>]) % mod;
}</code></pre></div>
<h2 id="扩展lucas定理"><span class="header-section-number">5.5</span> 扩展Lucas定理</h2>
<p>快速求组合数取模</p>
<h3 id="预处理加速"><span class="header-section-number">5.5.1</span> 预处理加速</h3>
<p>空间复杂度O(MOD)</p>
<h4 id="环境-3"><span class="header-section-number">5.5.1.1</span> 环境</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL;

<span class="dt">const</span> <span class="dt">int</span> MAXF = <span class="dv">200003</span>;
<span class="dt">const</span> <span class="dt">int</span> MAXMOD = <span class="dv">100003</span>;

LL num[MAXMOD], factor[MAXMOD], power[MAXMOD], tot, pri[MAXMOD];</code></pre></div>
<h4 id="辅助函数-14"><span class="header-section-number">5.5.1.2</span> 辅助函数</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//对模数分解质因子，记录每个质因子factor的指数power和对应的值num</span>
<span class="dt">void</span> div(LL mod) {
    tot = <span class="dv">0</span>;
    LL tmp = mod;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i * i &lt;= mod; i++) {
        <span class="kw">if</span> (tmp % i != <span class="dv">0</span>) <span class="kw">continue</span>;
        factor[++tot] = i, num[tot] = <span class="dv">1</span>, power[tot] = <span class="dv">0</span>;
        <span class="kw">while</span> (tmp % i == <span class="dv">0</span>)
            num[tot] *= i, tmp /= i, power[tot]++;
    }
    <span class="kw">if</span> (tmp != <span class="dv">1</span>) factor[++tot] = tmp, num[tot] = tmp, power[tot] = <span class="dv">1</span>;
}

<span class="co">//扩展欧几里得求逆元</span>
<span class="dt">void</span> ext_gcd(LL a, LL b, LL &amp;x, LL &amp;y) {
    <span class="kw">if</span> (b == <span class="dv">0</span>) {
        x = <span class="dv">1</span>, y = <span class="dv">0</span>;
        <span class="kw">return</span>;
    }
    ext_gcd(b, a % b, x, y);
    LL tp = x;
    x = y;
    y = tp - a / b * y;
}

LL quickPow(LL a, LL b, LL mod) {
    LL res = <span class="dv">1</span>;
    <span class="kw">for</span> (; b &gt; <span class="dv">0</span>; b /= <span class="dv">2</span>) {
        <span class="kw">if</span> (b % <span class="dv">2</span> == <span class="dv">1</span>) res = res * a % mod;
        a = a * a % mod;
    }
    <span class="kw">return</span> res;
}

LL calc(LL n, LL p, LL _p) {
    <span class="kw">if</span> (n &lt; _p) <span class="kw">return</span> pri[n];
    <span class="kw">return</span> (LL(pri[n % p]) * calc(n / _p, p, _p) % p
        * quickPow(pri[p - <span class="dv">1</span>], n / p, p) % p + p) % p;
}

LL count(LL n, LL p) {
    <span class="kw">if</span> (n &lt; p) <span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">return</span> n / p + count(n / p, p);
}

LL C(LL n, LL k, LL p, LL _p, LL t) {
    pri[<span class="dv">0</span>] = <span class="dv">1</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= p; i++)
        <span class="kw">if</span> (i % _p != <span class="dv">0</span>)
            pri[i] = LL(pri[i - <span class="dv">1</span>]) * i % p;
        <span class="kw">else</span>
            pri[i] = pri[i - <span class="dv">1</span>];
    LL t3 = count(n, _p) - count(k, _p) - count(n - k, _p);
    <span class="kw">if</span> (t3 &gt;= t) <span class="kw">return</span> <span class="dv">0</span>;
    LL t1 = calc(n, p, _p), t2 = calc(k, p, _p) * calc(n - k, p, _p) % p;
    LL x, y;
    ext_gcd(t2, p, x, y);
    <span class="kw">return</span> (t1 * x % p * quickPow(_p, t3, p) + p) % p;
}</code></pre></div>
<h4 id="核心代码-11"><span class="header-section-number">5.5.1.3</span> 核心代码</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//求n个元素中任意取m个的方法数模mod</span>
LL exLucas(LL n, LL m, LL mod) {
    LL res = <span class="dv">0</span>, tp;
    LL x, y;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= tot; i++) {
        ext_gcd(mod / num[i], num[i], x, y);
        tp = C(n, m, num[i], factor[i], power[i]);
        res += x * tp * (mod / num[i]) % mod, res %= mod;
    }
    <span class="kw">return</span> (res + mod) % mod;
}</code></pre></div>
<h4 id="用法-14"><span class="header-section-number">5.5.1.4</span> 用法</h4>
<p>调用<span class="math inline">\(div(mod)\)</span>对模数质因数分解，随后调用<span class="math inline">\(exLucas(n, m, mod)\)</span>求n个元素中任意取m个的方法数模mod</p>
<h2 id="二项式反演"><span class="header-section-number">5.6</span> 二项式反演</h2>
<h3 id="定义-7"><span class="header-section-number">5.6.1</span> 定义</h3>
<p>若</p>
<p><span class="math display">\[
f(n) = \sum^n_{j=0} C^j_n \ g(j)
\]</span></p>
<p>可由二项式反演得</p>
<p><span class="math display">\[
g(n) = \sum ^n _{i=0} (-1)^i C^i_n \ f(n-i)
\]</span></p>
<h2 id="卡特兰数"><span class="header-section-number">5.7</span> 卡特兰数</h2>
<h3 id="定义-8"><span class="header-section-number">5.7.1</span> 定义</h3>
<ul>
<li>n个元素进出栈方案数</li>
<li>n个左括号与n个右括号的匹配方案数</li>
<li>一个正n多边形用n-3条不相交的对角线划分成n-2个三角形的方案数</li>
<li>一棵体积为n的有根二叉树有多少种形态</li>
<li><span class="math inline">\(\cdots \cdots\)</span></li>
</ul>
<p><span class="math display">\[
Catalon(n) = \frac{(2n)!}{n!(n+1)!} \ \ (0! = 1)
\]</span></p>
<h3 id="代码-12"><span class="header-section-number">5.7.2</span> 代码</h3>
<h4 id="环境-4"><span class="header-section-number">5.7.2.1</span> 环境</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;

<span class="dt">const</span> <span class="dt">int</span> MAXN = <span class="dv">2000010</span>;

<span class="dt">int</span> prime[MAXN], size[MAXN]={<span class="dv">0</span>}, p, n, len, num[MAXN];
<span class="dt">bool</span> isnot[MAXN];</code></pre></div>
<h4 id="辅助函数-15"><span class="header-section-number">5.7.2.2</span> 辅助函数</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> init() { <span class="co">//素数筛</span>
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= (n &lt;&lt; <span class="dv">1</span>); i++) {
        <span class="kw">if</span> (!isnot[i]) prime[++len] = i, num[i] = len;
        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; prime[j] * i &lt;= (n &lt;&lt; <span class="dv">1</span>); j++) {
            isnot[prime[j] * i] = <span class="dv">1</span>, num[prime[j] * i] = j;
            <span class="kw">if</span> (i % prime[j] == <span class="dv">0</span>) <span class="kw">break</span>;
        }
    }
}

<span class="dt">void</span> div(<span class="dt">int</span> x, <span class="dt">int</span> s) {
    <span class="kw">while</span> (x != <span class="dv">1</span>) {
        size[num[x]] += s;
        x /= prime[num[x]];
    }
}

<span class="kw">inline</span> <span class="dt">void</span> quickPow(<span class="dt">long</span> <span class="dt">long</span> &amp;ans, <span class="dt">int</span> x, <span class="dt">int</span> y) {
    <span class="kw">while</span> (y) {
        <span class="kw">if</span> (y &amp; <span class="dv">1</span>) (ans *= x) %= p;
        y &gt;&gt;= <span class="dv">1</span>;
        (x *= x) %= p;
    }
}</code></pre></div>
<h4 id="核心代码-12"><span class="header-section-number">5.7.2.3</span> 核心代码</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">ll catalon(ll n) {
    <span class="kw">for</span> (<span class="dt">int</span> i = n + <span class="dv">2</span>; i &lt;= (n &lt;&lt; <span class="dv">1</span>); i++)
        div(i, <span class="dv">1</span>);
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= n; i++)
        div(i, <span class="dv">-1</span>);
    <span class="dt">long</span> <span class="dt">long</span> ans = <span class="dv">1</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= len; i++)
        <span class="kw">if</span> (size[i])
            quickPow(ans, prime[i], size[i]);
    <span class="kw">return</span> ans;
}</code></pre></div>
<h1 id="计算几何"><span class="header-section-number">6</span> 计算几何</h1>
<blockquote>
<p>来自<a href="https://wenku.baidu.com/view/194472899e314332396893b0.html?qq-pf-to=pcqq.c2c">ACM计算几何模板__HIT_jerrybond</a>(<strong>Author:jerrybond</strong>)<br />
手动转码</p>
</blockquote>
<h2 id="几何公式"><span class="header-section-number">6.1</span> 几何公式</h2>
<h3 id="三角形"><span class="header-section-number">6.1.1</span> 三角形</h3>
<ol style="list-style-type: decimal">
<li><p>半周长 <span class="math inline">\(P=\frac{a+b+c}{2}\)</span></p></li>
<li><p>面积 <span class="math inline">\(S=\frac{aH_a}{2}=\frac{ab\cdot sin(C)}{2}=\sqrt{P(P-a)(P-b)(P-c)}\)</span></p></li>
<li><p>中线 <span class="math inline">\(M_a=\frac{\sqrt{2(b^2+c^2)-a^2}}{2}=\frac{\sqrt{b^2+c^2+2bc\cdot cos(A)}}{2}\)</span></p></li>
<li><p>角平分线 <span class="math inline">\(T_a=\frac{\sqrt{bc((b+c)^2-a^2)}}{b+c}=\frac{2bc\cdot cos(A/2)}{b+c}\)</span></p></li>
<li><p>高线 <span class="math inline">\(H_a=b\cdot sin(C)=c\cdot sin(B)=\sqrt{b^2-(\frac{a^2+b^2-c^2}{2a}))^2}\)</span></p></li>
<li><p>内切圆半径</p></li>
</ol>
<p><span class="math display">\[
\begin{aligned}
r=\frac{S}{P}&amp;=a\cdot sin(\frac{B}{2})sin(\frac{C}{2})/sin(\frac{B+C}{2})\\
             &amp;=4R\cdot sin(\frac{A}{2})sin(\frac{B}{2})sin(\frac{C}{2})\\
              &amp;=\sqrt{(P-a)(P-b)(P-c)/P} \\
             &amp;=P\cdot tan(\frac{A}{2})tan(\frac{B}{2})tan(\frac{C}{2})
\end{aligned}
\]</span></p>
<ol start="7" style="list-style-type: decimal">
<li>外接圆半径 <span class="math inline">\(R=\frac{abc}{4S}=\frac{a}{2sin(A)}=\frac{b}{2sin(B)}=\frac{c}{2sin(C)}\)</span></li>
</ol>
<h3 id="四边形"><span class="header-section-number">6.1.2</span> 四边形</h3>
<blockquote>
<p><span class="math inline">\(D_1\)</span>,<span class="math inline">\(D_2\)</span> 为对角线,<span class="math inline">\(M\)</span> 对角线中点连线,<span class="math inline">\(\theta\)</span> 为对角线夹角</p>
</blockquote>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(a^2+b^2+c^2+d^2=D_1^2+D_2^2+4M^2\)</span></p></li>
<li><p><span class="math inline">\(S=\frac{D_1D_2sin(\theta)}{2}\)</span></p></li>
</ol>
<blockquote>
<p>(以下对圆的内接四边形)</p>
</blockquote>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(ac+bd=D_1D_2\)</span></p></li>
<li><p><span class="math inline">\(S=\sqrt{(P-a)(P-b)(P-c)(P-d)}\)</span>,P 为半周长</p></li>
</ol>
<h3 id="正-n-边形"><span class="header-section-number">6.1.3</span> 正 n 边形</h3>
<blockquote>
<p><span class="math inline">\(R\)</span> 为外接圆半径,<span class="math inline">\(r\)</span> 为内切圆半径</p>
</blockquote>
<ol style="list-style-type: decimal">
<li><p>中心角 <span class="math inline">\(\theta=2\pi/n\)</span></p></li>
<li><p>内角 <span class="math inline">\(C=(n-2)\pi/n\)</span></p></li>
<li><p>边长 <span class="math inline">\(a=2\sqrt{R^2-r^2}=2R\cdot sin(\frac{\theta}{2})=2r\cdot tan(\frac{\theta}{2})\)</span></p></li>
<li><p>面积 <span class="math inline">\(S=\frac{nar}{2}=nr^2tan(\frac{\theta}{2})=\frac{nR^2sin(\theta)}{2}=\frac{na^2}{4tan(\theta/2)}\)</span></p></li>
</ol>
<h3 id="圆"><span class="header-section-number">6.1.4</span> 圆</h3>
<ol style="list-style-type: decimal">
<li><p>弧长 <span class="math inline">\(l=r\theta\)</span></p></li>
<li><p>弦长 <span class="math inline">\(a=2\sqrt{2hr-h^2}=2r\cdot sin(\frac{\theta}{2})\)</span></p></li>
<li><p>弓形高 <span class="math inline">\(h=r-\sqrt{r^2-\frac{a^2}{4}}=r(1-cos(\frac{\theta}{2}))=\frac{a\cdot tan(\frac{\theta}{4})}{2}\)</span></p></li>
<li><p>扇形面积 <span class="math inline">\(S_1=\frac{rl}{2}=\frac{r^2\theta}{2}\)</span></p></li>
<li><p>弓形面积 <span class="math inline">\(S_2=\frac{rl-a(r-h)}{2}=\frac{r^2(\theta-sin(\theta))}{2}\)</span></p></li>
</ol>
<h3 id="棱柱"><span class="header-section-number">6.1.5</span> 棱柱</h3>
<ol style="list-style-type: decimal">
<li><p>体积 <span class="math inline">\(V=Ah\)</span>,<span class="math inline">\(A\)</span> 为底面积,<span class="math inline">\(h\)</span> 为高</p></li>
<li><p>侧面积 <span class="math inline">\(S=lp\)</span>,<span class="math inline">\(l\)</span> 为棱长,<span class="math inline">\(p\)</span> 为直截面周长</p></li>
<li><p>全面积 <span class="math inline">\(T=S+2A\)</span></p></li>
</ol>
<h3 id="棱锥"><span class="header-section-number">6.1.6</span> 棱锥</h3>
<ol style="list-style-type: decimal">
<li><p>体积 <span class="math inline">\(V=\frac{Ah}{3}\)</span>,<span class="math inline">\(A\)</span> 为底面积,<span class="math inline">\(h\)</span> 为高(以下对正棱锥)</p></li>
<li><p>侧面积 <span class="math inline">\(S=\frac{lp}{2}\)</span>,<span class="math inline">\(l\)</span> 为斜高,<span class="math inline">\(p\)</span> 为底面周长</p></li>
<li><p>全面积 <span class="math inline">\(T=S+A\)</span></p></li>
</ol>
<h3 id="棱台"><span class="header-section-number">6.1.7</span> 棱台</h3>
<ol style="list-style-type: decimal">
<li><p>体积 <span class="math inline">\(V=\frac{\left(A_1+A_2+\sqrt{A_1A_2}\right)h}{3}\)</span>,<span class="math inline">\(A_1\)</span>.<span class="math inline">\(A_2\)</span> 为上下底面积,<span class="math inline">\(h\)</span> 为高(以下为正棱台)</p></li>
<li><p>侧面积 <span class="math inline">\(S=\frac{\left(p_1+p_2\right)l}{2}\)</span>,<span class="math inline">\(p_1\)</span>.<span class="math inline">\(p_2\)</span> 为上下底面周长,<span class="math inline">\(l\)</span> 为斜高</p></li>
<li><p>全面积 <span class="math inline">\(T=S+A_1+A_2\)</span></p></li>
</ol>
<h3 id="圆柱"><span class="header-section-number">6.1.8</span> 圆柱</h3>
<ol style="list-style-type: decimal">
<li><p>侧面积 <span class="math inline">\(S=2\pi rh\)</span></p></li>
<li><p>全面积 <span class="math inline">\(T=2\pi r(h+r)\)</span></p></li>
<li><p>体积 <span class="math inline">\(V=\pi r^2h\)</span></p></li>
</ol>
<h3 id="圆锥"><span class="header-section-number">6.1.9</span> 圆锥</h3>
<ol style="list-style-type: decimal">
<li><p>母线 <span class="math inline">\(l=\sqrt{h^2+r^2}\)</span></p></li>
<li><p>侧面积 <span class="math inline">\(S=\pi rl\)</span></p></li>
<li><p>全面积 <span class="math inline">\(T=\pi r(l+r)\)</span></p></li>
<li><p>体积 <span class="math inline">\(V=\frac{\pi r^2h}{3}\)</span></p></li>
</ol>
<h3 id="圆台"><span class="header-section-number">6.1.10</span> 圆台</h3>
<ol style="list-style-type: decimal">
<li><p>母线 <span class="math inline">\(l=\sqrt{h^2+(r_1-r_2)^2}\)</span></p></li>
<li><p>侧面积 <span class="math inline">\(S=\pi(r_1+r_2)l\)</span></p></li>
<li><p>全面积 <span class="math inline">\(T=\pi r_1(l+r_1)+\pi r_2(l+r2)\)</span></p></li>
<li><p>体积 <span class="math inline">\(V=\frac{\pi\left(r_1^2+r_2^2+r_1r_2\right)h}{3}\)</span></p></li>
</ol>
<h3 id="球"><span class="header-section-number">6.1.11</span> 球</h3>
<ol style="list-style-type: decimal">
<li><p>全面积 <span class="math inline">\(T=4\pi r^2\)</span></p></li>
<li><p>体积 <span class="math inline">\(V=4\pi r^3/3\)</span></p></li>
</ol>
<h3 id="球台"><span class="header-section-number">6.1.12</span> 球台</h3>
<ol style="list-style-type: decimal">
<li><p>侧面积 <span class="math inline">\(S=2\pi rh\)</span></p></li>
<li><p>全面积 <span class="math inline">\(T=\pi (2rh+r_1^2+r_2^2)\)</span></p></li>
<li><p>体积 <span class="math inline">\(V=\frac{\pi h\left(3\left(r_1^2+r_2^2\right)+h^2\right)}{6}\)</span></p></li>
</ol>
<h3 id="球扇形"><span class="header-section-number">6.1.13</span> 球扇形</h3>
<ol style="list-style-type: decimal">
<li><p>全面积 <span class="math inline">\(T=\pi r(2h+r_0)\)</span>,<span class="math inline">\(h\)</span> 为球冠高,<span class="math inline">\(r_0\)</span> 为球冠底面半径</p></li>
<li><p>体积 <span class="math inline">\(V=\frac{2\pi r^2h}{3}\)</span></p></li>
</ol>
<h2 id="直线与线段"><span class="header-section-number">6.2</span> 直线与线段</h2>
<h3 id="预备函数"><span class="header-section-number">6.2.1</span> 预备函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//结构定义与宏定义</span>
<span class="ot">#include&lt;stdio.h&gt;</span>
<span class="ot">#include&lt;string.h&gt;</span>
<span class="ot">#include&lt;stdlib.h&gt;</span>
<span class="ot">#include&lt;math.h&gt;</span>

<span class="dt">const</span> <span class="dt">double</span> eps=<span class="fl">1e-8</span>

<span class="dt">bool</span> zero(<span class="dt">int</span> x)
{
    <span class="kw">return</span> fabs(x)&lt;eps;
}

<span class="kw">struct</span> point{
    <span class="dt">double</span> x,y;
};

<span class="kw">struct</span> line{
    point a,b;
};

<span class="co">//计算 cross product (P1-P0)x(P2-P0)</span>
<span class="dt">double</span> xmult(point p1,point p2,point p0)
{
    <span class="kw">return</span> (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}

<span class="dt">double</span> xmult(<span class="dt">double</span> x1,<span class="dt">double</span> y1,<span class="dt">double</span> x2,<span class="dt">double</span> y2,<span class="dt">double</span> x0,<span class="dt">double</span> y0)
{
    <span class="kw">return</span> (x1-x0)*(y2-y0)-(x2-x0)*(y1-y0);
}

<span class="co">//计算 dot product (P1-P0).(P2-P0)</span>
<span class="dt">double</span> dmult(point p1,point p2,point p0)
{
    <span class="kw">return</span> (p1.x-p0.x)*(p2.x-p0.x)+(p1.y-p0.y)*(p2.y-p0.y);
}

<span class="dt">double</span> dmult(<span class="dt">double</span> x1,<span class="dt">double</span> y1,<span class="dt">double</span> x2,<span class="dt">double</span> y2,<span class="dt">double</span> x0,<span class="dt">double</span> y0)
{
    <span class="kw">return</span> (x1-x0)*(x2-x0)+(y1-y0)*(y2-y0);
}

<span class="co">//两点距离</span>
<span class="dt">double</span> distance(point p1,point p2)
{
    <span class="kw">return</span> sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}

<span class="dt">double</span> distance(<span class="dt">double</span> x1,<span class="dt">double</span> y1,<span class="dt">double</span> x2,<span class="dt">double</span> y2)
{
    <span class="kw">return</span> sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}</code></pre></div>
<h2 id="判三点是否共线"><span class="header-section-number">6.3</span> 判三点是否共线</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> dots_inline(point p1,point p2,point p3)
{
    <span class="kw">return</span> zero(xmult(p1,p2,p3));
}</code></pre></div>
<h3 id="判点是否在线段上"><span class="header-section-number">6.3.1</span> 判点是否在线段上</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判点是否在线段上,包括端点（下面为两种接口模式）</span>
<span class="dt">int</span> dot_online_in(point p,line l)
{
    <span class="kw">return</span> zero(xmult(p,l.a,l.b))
            &amp;&amp;(l.a.x-p.x)*(l.b.x-p.x)&lt;eps
            &amp;&amp;(l.a.y-p.y)*(l.b.y-p.y)&lt;eps;
}

<span class="dt">int</span> dot_online_in(point p,point l1,point l2)
{
    <span class="kw">return</span> zero(xmult(p,l1,l2))
        &amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps
        &amp;&amp;(l1.y-p.y)*(l2.y-p.y)&lt;eps;
}

<span class="co">//判点是否在线段上,不包括端点</span>
<span class="dt">int</span> dot_online_ex(point p,line l)
{
    <span class="kw">return</span> dot_online_in(p,l)&amp;&amp;(!zero(p.x-l.a.x)||!zero(p.y-l.a.y))
        &amp;&amp;(!zero(p.x-l.b.x)||!zero(p.y-l.b.y));
}</code></pre></div>
<h3 id="判断两点在线段的同一侧"><span class="header-section-number">6.3.2</span> 判断两点在线段的同一侧</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判两点在线段同侧,点在线段上返回 0</span>
<span class="dt">int</span> same_side(point p1,point p2,line l)
{
    <span class="kw">return</span> xmult(l.a,p1,l.b)*xmult(l.a,p2,l.b)&gt;eps;
}

<span class="dt">int</span> same_side(point p1,point p2,point l1,point l2)
{
    <span class="kw">return</span> xmult(l1,p1,l2)*xmult(l1,p2,l2)&gt;eps;
}</code></pre></div>
<h3 id="判断两点是否在线段的异侧"><span class="header-section-number">6.3.3</span> 判断两点是否在线段的异侧</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判两点在线段异侧,点在线段上返回 0</span>
<span class="dt">int</span> opposite_side(point p1,point p2,line l)
{
    <span class="kw">return</span> xmult(l.a,p1,l.b)*xmult(l.a,p2,l.b)&lt;-eps;
}

<span class="dt">int</span> opposite_side(point p1,point p2,point l1,point l2)
{
    <span class="kw">return</span> xmult(l1,p1,l2)*xmult(l1,p2,l2)&lt;-eps;
}</code></pre></div>
<h3 id="求点关于直线的对称点"><span class="header-section-number">6.3.4</span> 求点关于直线的对称点</h3>
<ul>
<li><p><strong>点关于直线的对称点 // by lyt</strong></p></li>
<li><p><strong>缺点：用了斜率</strong></p></li>
<li><p><strong>也可以利用&quot;点到直线上的最近点&quot;来做，避免使用斜率。</strong></p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">point symmetric_point(point p1, point l1, point l2)
{
    point ret;
    <span class="kw">if</span> (l1.x &gt; l2.x - eps &amp;&amp; l1.x &lt; l2.x + eps)
    {
        ret.x = (<span class="dv">2</span> * l1.x - p1.x);
        ret.y = p1.y;
    }
    <span class="kw">else</span>
    {
        <span class="dt">double</span> k = (l1.y - l2.y ) / (l1.x - l2.x);
        ret.x = (<span class="dv">2</span>*k*k*l1.x + <span class="dv">2</span>*k*p1.y - <span class="dv">2</span>*k*l1.y - k*k*p1.x + p1.x)
            / (<span class="dv">1</span> + k*k); ret.y = p1.y - (ret.x - p1.x ) / k;
    }
    <span class="kw">return</span> ret;
}</code></pre></div>
<h3 id="判断两线段是否相交"><span class="header-section-number">6.3.5</span> 判断两线段是否相交</h3>
<h4 id="常用版"><span class="header-section-number">6.3.5.1</span> 常用版</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//定义点</span>
<span class="kw">struct</span> Point
{
    <span class="dt">double</span> x;
    <span class="dt">double</span> y;
};

<span class="kw">typedef</span> <span class="kw">struct</span> Point point;

<span class="co">//叉积</span>
<span class="dt">double</span> multi(point p0, point p1, point p2)
{
    <span class="kw">return</span> ( p1.x - p0.x )*( p2.y - p0.y)
          -( p2.x - p0.x )*( p1.y - p0.y);
}

<span class="co">//相交返回 true,否则为 false,接口为两线段的端点</span>
<span class="dt">bool</span> isIntersected(point s1,point e1, point s2,point e2)
{
    <span class="kw">return</span> (max(s1.x,e1.x) &gt;= min(s2.x,e2.x)) &amp;&amp;
        (max(s2.x,e2.x) &gt;= min(s1.x,e1.x)) &amp;&amp;
        (max(s1.y,e1.y) &gt;= min(s2.y,e2.y)) &amp;&amp;
        (max(s2.y,e2.y) &gt;= min(s1.y,e1.y)) &amp;&amp;
        (multi(s1,s2,e1)*multi(s1,e1,e2)&gt;<span class="dv">0</span>) &amp;&amp;
        (multi(s2,s1,e2)*multi(s2,e2,e1)&gt;<span class="dv">0</span>);
}</code></pre></div>
<h4 id="不常用版"><span class="header-section-number">6.3.5.2</span> 不常用版</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判两线段相交,包括端点和部分重合</span>
<span class="dt">int</span> intersect_in(line u,line v)
{
    <span class="kw">if</span> (!dots_inline(u.a,u.b,v.a)||!dots_inline(u.a,u.b,v.b))
        <span class="kw">return</span> !same_side(u.a,u.b,v)&amp;&amp;!same_side(v.a,v.b,u);
    <span class="kw">return</span> dot_online_in(u.a,v)
        ||dot_online_in(u.b,v)
        ||dot_online_in(v.a,u)
        ||dot_online_in(v.b,u);
}

<span class="dt">int</span> intersect_in(point u1,point u2,point v1,point v2)
{
    <span class="kw">if</span> (!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2))
        <span class="kw">return</span> !same_side(u1,u2,v1,v2)&amp;&amp;!same_side(v1,v2,u1,u2);
    <span class="kw">return</span> dot_online_in(u1,v1,v2)
        ||dot_online_in(u2,v1,v2)
        ||dot_online_in(v1,u1,u2)
        ||dot_online_in(v2,u1,u2);
}

<span class="co">//判两线段相交,不包括端点和部分重合</span>
<span class="dt">int</span> intersect_ex(line u,line v)
{
    <span class="kw">return</span> opposite_side(u.a,u.b,v)&amp;&amp;opposite_side(v.a,v.b,u);
}

<span class="dt">int</span> intersect_ex(point u1,point u2,point v1,point v2)
{
    <span class="kw">return</span> opposite_side(u1,u2,v1,v2)&amp;&amp;opposite_side(v1,v2,u1,u2);
}</code></pre></div>
<h3 id="求两条直线的交点"><span class="header-section-number">6.3.6</span> 求两条直线的交点</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//计算两直线交点,注意事先判断直线是否平行!</span>
<span class="co">//线段交点请另外判线段相交(同时还是要判断是否平行!)</span>
point intersection(point u1,point u2,point v1,point v2)
{
    point ret=u1;
    <span class="dt">double</span> t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))
        /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));
    ret.x+=(u2.x-u1.x)*t;
    ret.y+=(u2.y-u1.y)*t;
    <span class="kw">return</span> ret;
}</code></pre></div>
<h3 id="点到直线的最近距离"><span class="header-section-number">6.3.7</span> 点到直线的最近距离</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">point ptoline(point p,point l1,point l2)
{
    point t=p;
    t.x+=l1.y-l2.y,t.y+=l2.x-l1.x;
    <span class="kw">return</span> intersection(p,t,l1,l2);
}</code></pre></div>
<h3 id="点到线段的最近距离"><span class="header-section-number">6.3.8</span> 点到线段的最近距离</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">point ptoseg(point p,point l1,point l2)
{
    point t=p;
    t.x+=l1.y-l2.y,t.y+=l2.x-l1.x;
    <span class="kw">if</span> (xmult(l1,t,p)*xmult(l2,t,p)&gt;eps)
        <span class="kw">return</span> distance(p,l1)&lt;distance(p,l2)?l1:l2;
    <span class="kw">return</span> intersection(p,t,l1,l2);
}</code></pre></div>
<h2 id="多边形"><span class="header-section-number">6.4</span> 多边形</h2>
<h3 id="预备浮点函数"><span class="header-section-number">6.4.1</span> 预备浮点函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include&lt;stdio.h&gt;</span>
<span class="ot">#include&lt;string.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>

<span class="ot">#define MAXN 1000</span>
<span class="co">//offset 为多变形坐标的最大绝对值</span>
<span class="ot">#define offset 10000</span>
<span class="ot">#define eps 1e-8</span>
<span class="co">//浮点数判 0</span>
<span class="ot">#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)</span>
<span class="co">//浮点数判断符</span>
<span class="ot">#define _sign(x) ((x)&gt;eps?1:((x)&lt;-eps?2:0))</span>

<span class="co">//定义点</span>
<span class="kw">struct</span> point
{
    <span class="dt">double</span> x,y;
}pt[MAXN ];

<span class="co">//定义线段</span>
<span class="kw">struct</span> line
{
    point a,b;
};

<span class="co">//叉积</span>
<span class="dt">double</span> xmult(point p1,point p2,point p0)
{
    <span class="kw">return</span> (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}</code></pre></div>
<h3 id="判定是否是凸多边形"><span class="header-section-number">6.4.2</span> 判定是否是凸多边形</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判定凸多边形,顶点按顺时针或逆时针给出,允许相邻边共线,是凸多边形返回1，否则返回0</span>
<span class="dt">int</span> is_convex(<span class="dt">int</span> n,point* p)
{
    <span class="dt">int</span> i,s[<span class="dv">3</span>]={<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>};
    <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;n&amp;&amp;s[<span class="dv">1</span>]|s[<span class="dv">2</span>];i++)
        s[_sign(xmult(p[(i<span class="dv">+1</span>)%n],p[(i<span class="dv">+2</span>)%n],p[i]))]=<span class="dv">0</span>;
    <span class="kw">return</span> s[<span class="dv">1</span>]|s[<span class="dv">2</span>];
}

<span class="co">//判凸边行，顶点按顺时针或逆时针给出,不允许相邻边共线,是凸多边形返回1，否则返回 0</span>
<span class="dt">int</span> is_convex_v2(<span class="dt">int</span> n,point* p)
{
    <span class="dt">int</span> i,s[<span class="dv">3</span>]={<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>};
    <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;n&amp;&amp;s[<span class="dv">0</span>]&amp;&amp;s[<span class="dv">1</span>]|s[<span class="dv">2</span>];i++)
        s[_sign(xmult(p[(i<span class="dv">+1</span>)%n],p[(i<span class="dv">+2</span>)%n],p[i]))]=<span class="dv">0</span>;
    <span class="kw">return</span> s[<span class="dv">0</span>]&amp;&amp;s[<span class="dv">1</span>]|s[<span class="dv">2</span>];
}</code></pre></div>
<h3 id="判定点是否在多边形内"><span class="header-section-number">6.4.3</span> 判定点是否在多边形内</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判点在凸多边形内或多边形边上时返回 1，严格在凸多边形外返回0</span>
<span class="dt">int</span> inside_convex(point q,<span class="dt">int</span> n,point* p) {
    <span class="dt">int</span> i,s[<span class="dv">3</span>]={<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>};
    <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;n&amp;&amp;s[<span class="dv">1</span>]|s[<span class="dv">2</span>];i++)
        s[_sign(xmult(p[(i<span class="dv">+1</span>)%n],q,p[i]))]=<span class="dv">0</span>;
    <span class="kw">return</span> s[<span class="dv">1</span>]|s[<span class="dv">2</span>];
}

<span class="co">//判点严格在凸多边形内返回 1,在边上或者严格在外返回0</span>
<span class="dt">int</span> inside_convex_v2(point q,<span class="dt">int</span> n,point* p) {
    <span class="dt">int</span> i,s[<span class="dv">3</span>]={<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>};
    <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;n&amp;&amp;s[<span class="dv">0</span>]&amp;&amp;s[<span class="dv">1</span>]|s[<span class="dv">2</span>];i++)
        s[_sign(xmult(p[(i<span class="dv">+1</span>)%n],q,p[i]))]=<span class="dv">0</span>;
    <span class="kw">return</span> s[<span class="dv">0</span>]&amp;&amp;s[<span class="dv">1</span>]|s[<span class="dv">2</span>];
}

<span class="co">//判点在任意多边形内,顶点按顺时针或逆时针给出</span>
<span class="co">//on_edge 表示点在多边形边上时的返回值</span>
<span class="co">//offset为多边形坐标上限,严格在内返回1，严格在外返回0</span>
<span class="dt">int</span> inside_polygon(point q,<span class="dt">int</span> n,point* p,<span class="dt">int</span> on_edge=<span class="dv">2</span>)
{
    point q2;
    <span class="dt">int</span> i=<span class="dv">0</span>,count;
    <span class="kw">while</span> (i&lt;n)
        <span class="kw">for</span> (count=i=<span class="dv">0</span>,q2.x=rand()+offset,q2.y=rand()+offset;i&lt;n;i++)
        {
            <span class="kw">if</span>(zero(xmult(q,p[i],p[(i<span class="dv">+1</span>)%n]))
                &amp;&amp;(p[i].x-q.x)*(p[(i<span class="dv">+1</span>)%n].x-q.x)&lt;eps
                &amp;&amp;(p[i].y-q.y)*(p[(i<span class="dv">+1</span>)%n].y-q.y)&lt;eps)
                    <span class="kw">return</span> on_edge;
            <span class="kw">else</span> <span class="kw">if</span> (zero(xmult(q,q2,p[i])))
                <span class="kw">break</span>;
            <span class="kw">else</span> <span class="kw">if</span> (xmult(q,p[i],q2)*xmult(q,p[(i<span class="dv">+1</span>)%n],q2)&lt;-eps&amp;&amp;
                     xmult(p[i],q,p[(i<span class="dv">+1</span>)%n])*xmult(p[i],q2,p[(i<span class="dv">+1</span>)%n])&lt;-eps)
                count++;
        }
    <span class="kw">return</span> count&amp;<span class="dv">1</span>;
}</code></pre></div>
<h3 id="判定一条线段是否在一个任意多边形内"><span class="header-section-number">6.4.4</span> 判定一条线段是否在一个任意多边形内</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//预备函数</span>
<span class="kw">inline</span> <span class="dt">int</span> opposite_side(point p1,point p2,point l1,point l2)
{
    <span class="kw">return</span> xmult(l1,p1,l2)*xmult(l1,p2,l2)&lt;-eps;
}

<span class="kw">inline</span> <span class="dt">int</span> dot_online_in(point p,point l1,point l2)
{
    <span class="kw">return</span> zero(xmult(p,l1,l2))
            &amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps
            &amp;&amp;(l1.y-p.y)*(l2.y-p.y)&lt;eps;
}

<span class="co">//判线段在任意多边形内,顶点按顺时针或逆时针给出,与边界相交返回 1</span>
<span class="dt">int</span> inside_polygon(point l1,point l2,<span class="dt">int</span> n,point* p) {
    point t[MAXN],tt;
    <span class="dt">int</span> i,j,k=<span class="dv">0</span>;
    <span class="kw">if</span> (!inside_polygon(l1,n,p)||!inside_polygon(l2,n,p))
        <span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;n;i++)
    {
        <span class="kw">if</span>(opposite_side(l1,l2,p[i],p[(i<span class="dv">+1</span>)%n])
            &amp;&amp;opposite_side(p[i],p[(i<span class="dv">+1</span>)%n],l1,l2))
            <span class="kw">return</span> <span class="dv">0</span>;
        <span class="kw">else</span> <span class="kw">if</span> (dot_online_in(l1,p[i],p[(i<span class="dv">+1</span>)%n]))
            t[k++]=l1;
        <span class="kw">else</span> <span class="kw">if</span> (dot_online_in(l2,p[i],p[(i<span class="dv">+1</span>)%n]))
            t[k++]=l2;
        <span class="kw">else</span> <span class="kw">if</span> (dot_online_in(p[i],l1,l2))
            t[k++]=p[i];
    }
    <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;k;i++)
        <span class="kw">for</span> (j=i<span class="dv">+1</span>;j&lt;k;j++)
        {
            tt.x=(t[i].x+t[j].x)/<span class="dv">2</span>;
            tt.y=(t[i].y+t[j].y)/<span class="dv">2</span>;
            <span class="kw">if</span> (!inside_polygon(tt,n,p))
                <span class="kw">return</span> <span class="dv">0</span>;
        }
    <span class="kw">return</span> <span class="dv">1</span>;
}</code></pre></div>
<h2 id="三角形-1"><span class="header-section-number">6.5</span> 三角形</h2>
<h3 id="预备函数-1"><span class="header-section-number">6.5.1</span> 预备函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include&lt;stdio.h&gt;</span>

<span class="co">//定义点</span>
<span class="kw">struct</span> point
{
    <span class="dt">double</span> x,y;
};

<span class="co">//定义直线</span>
<span class="kw">struct</span> line
{
    point a,b;
};

<span class="co">//两点距离</span>
<span class="dt">double</span> distance(point p1,point p2)
{
    <span class="kw">return</span> sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}

<span class="co">//两直线求交点</span>
point intersection(line u,line v)
{
    point ret=u.a;
    <span class="dt">double</span> t=((u.a.x-v.a.x)*(v.a.y-v.b.y)-(u.a.y-v.a.y)*(v.a.x-v.b.x))
        /((u.a.x-u.b.x)*(v.a.y-v.b.y)-(u.a.y-u.b.y)*(v.a.x-v.b.x));
    ret.x+=(u.b.x-u.a.x)*t;
    ret.y+=(u.b.y-u.a.y)*t;
    <span class="kw">return</span> ret;
}</code></pre></div>
<h3 id="求三角形的外心"><span class="header-section-number">6.5.2</span> 求三角形的外心</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">point circumcenter(point a,point b,point c)
{
    line u,v;
    u.a.x=(a.x+b.x)/<span class="dv">2</span>;
    u.a.y=(a.y+b.y)/<span class="dv">2</span>;
    u.b.x=u.a.x-a.y+b.y;
    u.b.y=u.a.y+a.x-b.x;
    v.a.x=(a.x+c.x)/<span class="dv">2</span>;
    v.a.y=(a.y+c.y)/<span class="dv">2</span>;
    v.b.x=v.a.x-a.y+c.y;
    v.b.y=v.a.y+a.x-c.x;
    <span class="kw">return</span> intersection(u,v);
}</code></pre></div>
<h3 id="求三角形内心"><span class="header-section-number">6.5.3</span> 求三角形内心</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">point incenter(point a,point b,point c)
{
    line u,v;
    <span class="dt">double</span> m,n;
    u.a=a;
    m=atan2(b.y-a.y,b.x-a.x);
    n=atan2(c.y-a.y,c.x-a.x);
    u.b.x=u.a.x+cos((m+n)/<span class="dv">2</span>);
    u.b.y=u.a.y+sin((m+n)/<span class="dv">2</span>);
    v.a=b;
    m=atan2(a.y-b.y,a.x-b.x);
    n=atan2(c.y-b.y,c.x-b.x);
    v.b.x=v.a.x+cos((m+n)/<span class="dv">2</span>);
    v.b.y=v.a.y+sin((m+n)/<span class="dv">2</span>);
    <span class="kw">return</span> intersection(u,v);
}</code></pre></div>
<h3 id="求三角形垂心"><span class="header-section-number">6.5.4</span> 求三角形垂心</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">point perpencenter(point a,point b,point c)
{
    line u,v;
    u.a=c;
    u.b.x=u.a.x-a.y+b.y;
    u.b.y=u.a.y+a.x-b.x;
    v.a=b;
    v.b.x=v.a.x-a.y+c.y;
    v.b.y=v.a.y+a.x-c.x;
    <span class="kw">return</span> intersection(u,v);
}</code></pre></div>
<h2 id="圆-1"><span class="header-section-number">6.6</span> 圆</h2>
<h3 id="预备函数-2"><span class="header-section-number">6.6.1</span> 预备函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="ot">#define eps 1e-8</span>

<span class="kw">struct</span> point
{
    <span class="dt">double</span> x,y;
};

<span class="dt">double</span> xmult(point p1,point p2,point p0)
{
    <span class="kw">return</span> (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}

<span class="dt">double</span> distance(point p1,point p2)
{
    <span class="kw">return</span> sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}

<span class="co">//点到直线的距离</span>
<span class="dt">double</span> disptoline(point p,point l1,point l2)
{
    <span class="kw">return</span> fabs(xmult(p,l1,l2))/distance(l1,l2);
}

<span class="co">//求两直线交点</span>
point intersection(point u1,point u2,point v1,point v2)
{
    point ret=u1;
    <span class="dt">double</span> t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))
        /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));
    ret.x+=(u2.x-u1.x)*t;
    ret.y+=(u2.y-u1.y)*t;
    <span class="kw">return</span> ret;
}</code></pre></div>
<h3 id="判定直线是否与圆相交"><span class="header-section-number">6.6.2</span> 判定直线是否与圆相交</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判直线和圆相交,包括相切</span>
<span class="dt">int</span> intersect_line_circle(point c,<span class="dt">double</span> r,point l1,point l2)
{
    <span class="kw">return</span> disptoline(c,l1,l2)&lt;r+eps;
}</code></pre></div>
<h3 id="判定线段与圆相交"><span class="header-section-number">6.6.3</span> 判定线段与圆相交</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> intersect_seg_circle(point c,<span class="dt">double</span> r, point l1,point l2)
{
    <span class="dt">double</span> t1=distance(c,l1)-r,t2=distance(c,l2)-r;
    point t=c;
    <span class="kw">if</span> (t1&lt;eps||t2&lt;eps)
        <span class="kw">return</span> t1&gt;-eps||t2&gt;-eps;
    t.x+=l1.y-l2.y;
    t.y+=l2.x-l1.x;
    <span class="kw">return</span> xmult(l1,c,t)*xmult(l2,c,t)&lt;eps&amp;&amp;disptoline(c,l1,l2)-r&lt;eps;
}</code></pre></div>
<h3 id="判圆和圆相交"><span class="header-section-number">6.6.4</span> 判圆和圆相交</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> intersect_circle_circle(point c1,<span class="dt">double</span> r1,point c2,<span class="dt">double</span> r2)
{
    <span class="kw">return</span> distance(c1,c2)&lt;r1+r2+eps&amp;&amp;distance(c1,c2)&gt;fabs(r1-r2)-eps;
}</code></pre></div>
<h3 id="计算圆上到点-p-最近点"><span class="header-section-number">6.6.5</span> 计算圆上到点 p 最近点</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//当 p 为圆心时，返回圆心本身</span>
point dot_to_circle(point c,<span class="dt">double</span> r,point p)
{
    point u,v;
    <span class="kw">if</span> (distance(p,c)&lt;eps)
        <span class="kw">return</span> p;
    u.x=c.x+r*fabs(c.x-p.x)/distance(c,p);
    u.y=c.y+r*fabs(c.y-p.y)/distance(c,p)*((c.x-p.x)*(c.y-p.y)&lt;<span class="dv">0</span>?<span class="dv">-1</span>:<span class="dv">1</span>);
    v.x=c.x-r*fabs(c.x-p.x)/distance(c,p);
    v.y=c.y-r*fabs(c.y-p.y)/distance(c,p)*((c.x-p.x)*(c.y-p.y)&lt;<span class="dv">0</span>?<span class="dv">-1</span>:<span class="dv">1</span>);
    <span class="kw">return</span> distance(u,p)&lt;distance(v,p)?u:v;
}</code></pre></div>
<h3 id="计算直线与圆的交点"><span class="header-section-number">6.6.6</span> 计算直线与圆的交点</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//计算直线与圆的交点,保证直线与圆有交点</span>
<span class="co">//计算线段与圆的交点可用这个函数后判点是否在线段上</span>
<span class="dt">void</span> intersection_line_circle(point c,<span class="dt">double</span> r,point l1
                              ,point l2,point&amp; p1,point&amp; p2)
{
    point p=c;
    <span class="dt">double</span> t;
    p.x+=l1.y-l2.y;
    p.y+=l2.x-l1.x;
    p=intersection(p,c,l1,l2);
    t=sqrt(r*r-distance(p,c)*distance(p,c))/distance(l1,l2);
    p1.x=p.x+(l2.x-l1.x)*t;
    p1.y=p.y+(l2.y-l1.y)*t;
    p2.x=p.x-(l2.x-l1.x)*t;
    p2.y=p.y-(l2.y-l1.y)*t;
}</code></pre></div>
<h3 id="计算两个圆的交点"><span class="header-section-number">6.6.7</span> 计算两个圆的交点</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//计算圆与圆的交点,保证圆与圆有交点,圆心不重合</span>
<span class="dt">void</span> intersection_circle_circle(point c1,<span class="dt">double</span> r1,point c2
                                ,<span class="dt">double</span> r2,point&amp; p1,point&amp; p2)
{
    point u,v;
    <span class="dt">double</span> t;
    t=(<span class="dv">1</span>+(r1*r1-r2*r2)/distance(c1,c2)/distance(c1,c2))/<span class="dv">2</span>;
    u.x=c1.x+(c2.x-c1.x)*t;
    u.y=c1.y+(c2.y-c1.y)*t;
    v.x=u.x+c1.y-c2.y;
    v.y=u.y-c1.x+c2.x;
    intersection_line_circle(c1,r1,u,v,p1,p2);
}</code></pre></div>
<h2 id="球面"><span class="header-section-number">6.7</span> 球面</h2>
<h3 id="给出地球经度纬度计算圆心角"><span class="header-section-number">6.7.1</span> 给出地球经度纬度，计算圆心角</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;math.h&gt;</span>

<span class="dt">const</span> <span class="dt">double</span> pi=acos(<span class="dv">-1</span>);

<span class="co">//计算圆心角 lat 表示纬度,-90&lt;=w&lt;=90,lng 表示经度</span>
<span class="co">//返回两点所在大圆劣弧对应圆心角,0&lt;=angle&lt;=pi</span>
<span class="dt">double</span> angle(<span class="dt">double</span> lng1,<span class="dt">double</span> lat1,<span class="dt">double</span> lng2,<span class="dt">double</span> lat2)
{
    <span class="dt">double</span> dlng=fabs(lng1-lng2)*pi/<span class="dv">180</span>;
    <span class="kw">while</span> (dlng&gt;=pi+pi)
        dlng-=pi+pi;
    <span class="kw">if</span> (dlng&gt;pi)
        dlng=pi+pi-dlng;
    lat1*=pi/<span class="dv">180</span>,lat2*=pi/<span class="dv">180</span>;
    <span class="kw">return</span> acos(cos(lat1)*cos(lat2)*cos(dlng)+sin(lat1)*sin(lat2));
}</code></pre></div>
<h3 id="已知经纬度计算地球上两点直线距离"><span class="header-section-number">6.7.2</span> 已知经纬度，计算地球上两点直线距离</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//计算距离,r 为球半径</span>
<span class="dt">double</span> line_dist(<span class="dt">double</span> r,<span class="dt">double</span> lng1,<span class="dt">double</span> lat1,<span class="dt">double</span> lng2,<span class="dt">double</span> lat2)
{
    <span class="dt">double</span> dlng=fabs(lng1-lng2)*pi/<span class="dv">180</span>;
    <span class="kw">while</span> (dlng&gt;=pi+pi)
        dlng-=pi+pi;
    <span class="kw">if</span> (dlng&gt;pi)
        dlng=pi+pi-dlng;
    lat1*=pi/<span class="dv">180</span>,lat2*=pi/<span class="dv">180</span>;
    <span class="kw">return</span>
        r*sqrt(<span class="dv">2-2</span>*(cos(lat1)*cos(lat2)*cos(dlng)+sin(lat1)*sin(lat2)));
}</code></pre></div>
<h3 id="已知经纬度计算地球上两点球面距离"><span class="header-section-number">6.7.3</span> 已知经纬度，计算地球上两点球面距离</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//计算球面距离,r 为球半径</span>
<span class="kw">inline</span> <span class="dt">double</span> sphere_dist(<span class="dt">double</span> r,<span class="dt">double</span> lng1
                          ,<span class="dt">double</span> lat1,<span class="dt">double</span> lng2,<span class="dt">double</span> lat2)
{
    <span class="kw">return</span> r*angle(lng1,lat1,lng2,lat2);
}</code></pre></div>
<h2 id="三维几何的若干模板"><span class="header-section-number">6.8</span> 三维几何的若干模板</h2>
<h3 id="预备函数-3"><span class="header-section-number">6.8.1</span> 预备函数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//三维几何函数库</span>
<span class="ot">#include &lt;math.h&gt;</span>

<span class="ot">#define eps 1e-8</span>
<span class="ot">#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)</span>

<span class="kw">struct</span> point3{<span class="dt">double</span> x,y,z;};
<span class="kw">struct</span> line3{point3 a,b;};
<span class="kw">struct</span> plane3{point3 a,b,c;};

<span class="co">//计算 cross product U x V</span>
point3 xmult(point3 u,point3 v){
    point3 ret;
    ret.x=u.y*v.z-v.y*u.z;
    ret.y=u.z*v.x-u.x*v.z;
    ret.z=u.x*v.y-u.y*v.x;
    <span class="kw">return</span> ret;
}

<span class="co">//计算 dot product U . V</span>
<span class="dt">double</span> dmult(point3 u,point3 v){
    <span class="kw">return</span> u.x*v.x+u.y*v.y+u.z*v.z;
}

<span class="co">//矢量差 U - V</span>
point3 subt(point3 u,point3 v){
    point3 ret;
    ret.x=u.x-v.x;
    ret.y=u.y-v.y;
    ret.z=u.z-v.z;
    <span class="kw">return</span> ret;
}

<span class="co">//取平面法向量</span>
point3 pvec(plane3 s){
    <span class="kw">return</span> xmult(subt(s.a,s.b),subt(s.b,s.c));
}

point3 pvec(point3 s1,point3 s2,point3 s3){
    <span class="kw">return</span> xmult(subt(s1,s2),subt(s2,s3));
}

<span class="co">//两点距离,单参数取向量大小</span>
<span class="dt">double</span> distance(point3 p1,point3 p2){
    <span class="kw">return</span>
        sqrt((p1.x-p2.x)*(p1.x-p2.x)+
             (p1.y-p2.y)*(p1.y-p2.y)+(p1.z-p2.z)*(p1.z-p2.z));
}

<span class="co">//向量大小</span>
<span class="dt">double</span> vlen(point3 p){
    <span class="kw">return</span> sqrt(p.x*p.x+p.y*p.y+p.z*p.z);
}</code></pre></div>
<h3 id="判定三点是否共线"><span class="header-section-number">6.8.2</span> 判定三点是否共线</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判三点共线</span>
<span class="dt">int</span> dots_inline(point3 p1,point3 p2,point3 p3)
{
    <span class="kw">return</span> vlen(xmult(subt(p1,p2),subt(p2,p3)))&lt;eps;
}</code></pre></div>
<h3 id="判定四点是否共面"><span class="header-section-number">6.8.3</span> 判定四点是否共面</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判四点共面</span>
<span class="dt">int</span> dots_onplane(point3 a,point3 b,point3 c,point3 d)
{
    <span class="kw">return</span> zero(dmult(pvec(a,b,c),subt(d,a)));
}</code></pre></div>
<h3 id="判定点是否在线段上"><span class="header-section-number">6.8.4</span> 判定点是否在线段上</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">//判点是否在线段上,包括端点和共线</span>
<span class="dt">int</span> dot_online_in(point3 p,line3 l){
    <span class="kw">return</span> zero(vlen(xmult(subt(p,l.a),subt(p,l.b))))
            &amp;&amp;(l.a.x-p.x)*(l.b.x-p.x)&lt;eps
            &amp;&amp;(l.a.y-p.y)*(l.b.y-p.y)&lt;eps
            &amp;&amp;(l.a.z-p.z)*(l.b.z-p.z)&lt;eps;
}

<span class="dt">int</span> dot_online_in(point3 p,point3 l1,point3 l2){
    <span class="kw">return</span> zero(vlen(xmult(subt(p,l1),subt(p,l2))))
            &amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps
            &amp;&amp;(l1.y-p.y)*(l2.y-p.y)&lt;eps
            &amp;&amp;(l1.z-p.z)*(l2.z-p.z)&lt;eps;
}

<span class="co">//判点是否在线段上,不包括端点</span>
<span class="dt">int</span> dot_online_ex(point3 p,line3 l){
    <span class="kw">return</span>
        dot_online_in(p,l)
        &amp;&amp;(!zero(p.x-l.a.x)||!zero(p.y-l.a.y)||!zero(p.z-l.a.z))
        &amp;&amp;(!zero(p.x-l.b.x)||!zero(p.y-l.b.y)||!zero(p.z-l.b.z));
}

<span class="dt">int</span> dot_online_ex(point3 p,point3 l1,point3 l2){
    <span class="kw">return</span>
        dot_online_in(p,l1,l2)
        &amp;&amp;(!zero(p.x-l1.x)||!zero(p.y-l1.y)||!zero(p.z-l1.z))
        &amp;&amp;(!zero(p.x-l2.x)||!zero(p.y-l2.y)||!zero(p.z-l2.z));
}</code></pre></div>
<h3 id="判断点是否在空间三角形上"><span class="header-section-number">6.8.5</span> 判断点是否在空间三角形上</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判点是否在空间三角形上,包括边界,三点共线无意义</span>
<span class="dt">int</span> dot_inplane_in(point3 p,plane3 s){
    <span class="kw">return</span> zero(vlen(xmult(subt(s.a,s.b),subt(s.a,s.c)))
             -vlen(xmult(subt(p,s.a),subt(p,s.b)))
             -vlen(xmult(subt(p,s.b),subt(p,s.c)))
             -vlen(xmult(subt(p,s.c),subt(p,s.a))));
}
<span class="dt">int</span> dot_inplane_in(point3 p,point3 s1,point3 s2,point3 s3){
    <span class="kw">return</span> zero(vlen(xmult(subt(s1,s2),subt(s1,s3)))
             -vlen(xmult(subt(p,s1),subt(p,s2)))
             -vlen(xmult(subt(p,s2),subt(p,s3)))
             -vlen(xmult(subt(p,s3),subt(p,s1))));
}
<span class="co">//判点是否在空间三角形上,不包括边界,三点共线无意义</span>
<span class="dt">int</span> dot_inplane_ex(point3 p,plane3 s){
    <span class="kw">return</span> dot_inplane_in(p,s)
        &amp;&amp;vlen(xmult(subt(p,s.a),subt(p,s.b)))&gt;eps
        &amp;&amp;vlen(xmult(subt(p,s.b),subt(p,s.c)))&gt;eps
        &amp;&amp;vlen(xmult(subt(p,s.c),subt(p,s.a)))&gt;eps;
}
<span class="dt">int</span> dot_inplane_ex(point3 p,point3 s1,point3 s2,point3 s3){
    <span class="kw">return</span> dot_inplane_in(p,s1,s2,s3)
        &amp;&amp;vlen(xmult(subt(p,s1),subt(p,s2)))&gt;eps
        &amp;&amp;vlen(xmult(subt(p,s2),subt(p,s3)))&gt;eps
        &amp;&amp;vlen(xmult(subt(p,s3),subt(p,s1)))&gt;eps;
}</code></pre></div>
<h3 id="判断两点是否在线段同侧"><span class="header-section-number">6.8.6</span> 判断两点是否在线段同侧</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> same_side(point3 p1,point3 p2,line3 l){
    <span class="kw">return</span> dmult(xmult(subt(l.a,l.b),subt(p1,l.b))
                ,xmult(subt(l.a,l.b),subt(p2,l.b)))&gt;eps;
}

<span class="dt">int</span> same_side(point3 p1,point3 p2,point3 l1,point3 l2){
    <span class="kw">return</span> dmult(xmult(subt(l1,l2),subt(p1,l2))
                ,xmult(subt(l1,l2),subt(p2,l2)))&gt;eps;
}</code></pre></div>
<h3 id="判断两点是否在线段异侧"><span class="header-section-number">6.8.7</span> 判断两点是否在线段异侧</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判两点在线段异侧,点在线段上返回 0,不共面无意义</span>
<span class="dt">int</span> opposite_side(point3 p1,point3 p2,line3 l){
    <span class="kw">return</span> dmult(xmult(subt(l.a,l.b),subt(p1,l.b))
                ,xmult(subt(l.a,l.b),subt(p2,l.b)))&lt;-eps;
}

<span class="dt">int</span> opposite_side(point3 p1,point3 p2,point3 l1,point3 l2){
    <span class="kw">return</span> dmult(xmult(subt(l1,l2),subt(p1,l2))
                ,xmult(subt(l1,l2),subt(p2,l2)))&lt;-eps;
}</code></pre></div>
<h3 id="判断两点是否在平面同侧"><span class="header-section-number">6.8.8</span> 判断两点是否在平面同侧</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判两点在平面同侧,点在平面上返回 0</span>
<span class="dt">int</span> same_side(point3 p1,point3 p2,plane3 s){
    <span class="kw">return</span> dmult(pvec(s),subt(p1,s.a))*dmult(pvec(s),subt(p2,s.a))&gt;eps;
}

<span class="dt">int</span> same_side(point3 p1,point3 p2,point3 s1,point3 s2,point3 s3){
    <span class="kw">return</span> dmult(pvec(s1,s2,s3),subt(p1,s1))
            *dmult(pvec(s1,s2,s3),subt(p2,s1))&gt;eps;
}</code></pre></div>
<h3 id="判断两点是否在平面异侧"><span class="header-section-number">6.8.9</span> 判断两点是否在平面异侧</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判两点在平面异侧,点在平面上返回 0</span>
<span class="dt">int</span> opposite_side(point3 p1,point3 p2,plane3 s){
    <span class="kw">return</span> dmult(pvec(s),subt(p1,s.a))*dmult(pvec(s),subt(p2,s.a))&lt;-eps;
}

<span class="dt">int</span> opposite_side(point3 p1,point3 p2,point3 s1,point3 s2,point3 s3){
    <span class="kw">return</span> dmult(pvec(s1,s2,s3),subt(p1,s1))
            *dmult(pvec(s1,s2,s3),subt(p2,s1))&lt;-eps;
}</code></pre></div>
<h3 id="判断两空间直线是否平行"><span class="header-section-number">6.8.10</span> 判断两空间直线是否平行</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判两直线平行</span>
<span class="dt">int</span> parallel(line3 u,line3 v){
    <span class="kw">return</span> vlen(xmult(subt(u.a,u.b),subt(v.a,v.b)))&lt;eps;
}

<span class="dt">int</span> parallel(point3 u1,point3 u2,point3 v1,point3 v2){
    <span class="kw">return</span> vlen(xmult(subt(u1,u2),subt(v1,v2)))&lt;eps;
}</code></pre></div>
<h3 id="判断两平面是否平行"><span class="header-section-number">6.8.11</span> 判断两平面是否平行</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判两平面平行</span>
<span class="dt">int</span> parallel(plane3 u,plane3 v){
    <span class="kw">return</span> vlen(xmult(pvec(u),pvec(v)))&lt;eps;
}

<span class="dt">int</span> parallel(point3 u1,point3 u2,point3 u3
             ,point3 v1,point3 v2,point3 v3)
{ 
    <span class="kw">return</span> vlen(xmult(pvec(u1,u2,u3),pvec(v1,v2,v3)))&lt;eps;
}</code></pre></div>
<h3 id="判断直线是否与平面平行"><span class="header-section-number">6.8.12</span> 判断直线是否与平面平行</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判直线与平面平行</span>
<span class="dt">int</span> parallel(line3 l,plane3 s){
    <span class="kw">return</span> zero(dmult(subt(l.a,l.b),pvec(s)));
}

<span class="dt">int</span> parallel(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3){
    <span class="kw">return</span> zero(dmult(subt(l1,l2),pvec(s1,s2,s3)));
}</code></pre></div>
<h3 id="判断两直线是否垂直"><span class="header-section-number">6.8.13</span> 判断两直线是否垂直</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判两直线垂直</span>
<span class="dt">int</span> perpendicular(line3 u,line3 v){
    <span class="kw">return</span> zero(dmult(subt(u.a,u.b),subt(v.a,v.b)));
}

<span class="dt">int</span> perpendicular(point3 u1,point3 u2,point3 v1,point3 v2){
    <span class="kw">return</span> zero(dmult(subt(u1,u2),subt(v1,v2)));
}</code></pre></div>
<h3 id="判断两平面是否垂直"><span class="header-section-number">6.8.14</span> 判断两平面是否垂直</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判两平面垂直</span>
<span class="dt">int</span> perpendicular(plane3 u,plane3 v){
    <span class="kw">return</span> zero(dmult(pvec(u),pvec(v)));
}

<span class="dt">int</span> perpendicular(point3 u1,point3 u2,point3 u3
                  ,point3 v1,point3 v2,point3 v3)
{
    <span class="kw">return</span> zero(dmult(pvec(u1,u2,u3),pvec(v1,v2,v3)));
}</code></pre></div>
<h3 id="判断两条空间线段是否相交"><span class="header-section-number">6.8.15</span> 判断两条空间线段是否相交</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判两线段相交,包括端点和部分重合</span>
<span class="dt">int</span> intersect_in(line3 u,line3 v){
    <span class="kw">if</span> (!dots_onplane(u.a,u.b,v.a,v.b))
        <span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">if</span> (!dots_inline(u.a,u.b,v.a)||!dots_inline(u.a,u.b,v.b)) 
        <span class="kw">return</span> !same_side(u.a,u.b,v)&amp;&amp;!same_side(v.a,v.b,u);
    <span class="kw">return</span> dot_online_in(u.a,v)
        ||dot_online_in(u.b,v)
        ||dot_online_in(v.a,u)
        ||dot_online_in(v.b,u);
}

<span class="dt">int</span> intersect_in(point3 u1,point3 u2,point3 v1,point3 v2){ 
    <span class="kw">if</span>(!dots_onplane(u1,u2,v1,v2))
        <span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">if</span> (!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2))
        <span class="kw">return</span> !same_side(u1,u2,v1,v2)&amp;&amp;!same_side(v1,v2,u1,u2); 
    <span class="kw">return</span> dot_online_in(u1,v1,v2)
        ||dot_online_in(u2,v1,v2)
        ||dot_online_in(v1,u1,u2)
        ||dot_online_in(v2,u1,u2);
}

<span class="co">//判两线段相交,不包括端点和部分重合</span>
<span class="dt">int</span> intersect_ex(line3 u,line3 v){
    <span class="kw">return</span> dots_onplane(u.a,u.b,v.a,v.b)
        &amp;&amp;opposite_side(u.a,u.b,v)
        &amp;&amp;opposite_side(v.a,v.b,u);
}

<span class="dt">int</span> intersect_ex(point3 u1,point3 u2,point3 v1,point3 v2){
    <span class="kw">return</span> dots_onplane(u1,u2,v1,v2)
        &amp;&amp;opposite_side(u1,u2,v1,v2)
        &amp;&amp;opposite_side(v1,v2,u1,u2);
}</code></pre></div>
<h3 id="判断线段是否与空间三角形相交"><span class="header-section-number">6.8.16</span> 判断线段是否与空间三角形相交</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//判线段与空间三角形相交,包括交于边界和(部分)包含</span>
<span class="dt">int</span> intersect_in(line3 l,plane3 s){
    <span class="kw">return</span> !same_side(l.a,l.b,s)&amp;&amp;!same_side(s.a,s.b,l.a,l.b,s.c)&amp;&amp;
        !same_side(s.b,s.c,l.a,l.b,s.a)&amp;&amp;!same_side(s.c,s.a,l.a,l.b,s.b);
}

<span class="dt">int</span> intersect_in(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3){
    <span class="kw">return</span> !same_side(l1,l2,s1,s2,s3)&amp;&amp;!same_side(s1,s2,l1,l2,s3)&amp;&amp;
        !same_side(s2,s3,l1,l2,s1)&amp;&amp;!same_side(s3,s1,l1,l2,s2);
}

<span class="co">//判线段与空间三角形相交,不包括交于边界和(部分)包含</span>
<span class="dt">int</span> intersect_ex(line3 l,plane3 s){
    <span class="kw">return</span>
        opposite_side(l.a,l.b,s)&amp;&amp;opposite_side(s.a,s.b,l.a,l.b,s.c)&amp;&amp;
        opposite_side(s.b,s.c,l.a,l.b,s.a)&amp;&amp;opposite_side(s.c,s.a,l.a,l.b,s.b);
}

<span class="dt">int</span> intersect_ex(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3){
    <span class="kw">return</span>
        opposite_side(l1,l2,s1,s2,s3)&amp;&amp;opposite_side(s1,s2,l1,l2,s3)&amp;&amp;
        opposite_side(s2,s3,l1,l2,s1)&amp;&amp;opposite_side(s3,s1,l1,l2,s2);
}</code></pre></div>
<h3 id="计算两条直线的交点"><span class="header-section-number">6.8.17</span> 计算两条直线的交点</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//计算两直线交点,注意事先判断直线是否共面和平行 !</span>
<span class="co">//线段交点请另外判线段相交(同时还是要判断是否平行!)</span>
point3 intersection(line3 u,line3 v){
    point3 ret=u.a;
    <span class="dt">double</span> t=((u.a.x-v.a.x)*(v.a.y-v.b.y)-(u.a.y-v.a.y)*(v.a.x-v.b.x))
        /((u.a.x-u.b.x)*(v.a.y-v.b.y)-(u.a.y-u.b.y)*(v.a.x-v.b.x));
    ret.x+=(u.b.x-u.a.x)*t;
    ret.y+=(u.b.y-u.a.y)*t;
    ret.z+=(u.b.z-u.a.z)*t;
    <span class="kw">return</span> ret;
}

point3 intersection(point3 u1,point3 u2,point3 v1,point3 v2){
    point3 ret=u1;
    <span class="dt">double</span> t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))
        /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));
    ret.x+=(u2.x-u1.x)*t;
    ret.y+=(u2.y-u1.y)*t;
    ret.z+=(u2.z-u1.z)*t;
    <span class="kw">return</span> ret;
}</code></pre></div>
<h3 id="计算直线与平面的交点"><span class="header-section-number">6.8.18</span> 计算直线与平面的交点</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//计算直线与平面交点,注意事先判断是否平行,并保证三点不共线!</span>
<span class="co">//线段和空间三角形交点请另外判断</span>
point3 intersection(line3 l,plane3 s){
    point3 ret=pvec(s);
    <span class="dt">double</span> t=(ret.x*(s.a.x-l.a.x)+ret.y*(s.a.y-l.a.y)+ret.z*(s.a.z-l.a.z))/
        (ret.x*(l.b.x-l.a.x)+ret.y*(l.b.y-l.a.y)+ret.z*(l.b.z-l.a.z));
    ret.x=l.a.x+(l.b.x-l.a.x)*t;
    ret.y=l.a.y+(l.b.y-l.a.y)*t;
    ret.z=l.a.z+(l.b.z-l.a.z)*t;
    <span class="kw">return</span> ret;
}

point3 intersection(point3 l1,point3 l2
                    ,point3 s1,point3 s2,point3 s3)
{
    point3 ret=pvec(s1,s2,s3);
    <span class="dt">double</span> t=(ret.x*(s1.x-l1.x)+ret.y*(s1.y-l1.y)+ret.z*(s1.z-l1.z))/
        (ret.x*(l2.x-l1.x)+ret.y*(l2.y-l1.y)+ret.z*(l2.z-l1.z));
    ret.x=l1.x+(l2.x-l1.x)*t;
    ret.y=l1.y+(l2.y-l1.y)*t;
    ret.z=l1.z+(l2.z-l1.z)*t;
    <span class="kw">return</span> ret;
}</code></pre></div>
<h3 id="计算两平面的交线"><span class="header-section-number">6.8.19</span> 计算两平面的交线</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//计算两平面交线,注意事先判断是否平行,并保证三点不共线!</span>
line3 intersection(plane3 u,plane3 v)
{
    line3 ret;
    ret.a=parallel(v.a,v.b,u.a,u.b,u.c)
        ?intersection(v.b,v.c,u.a,u.b,u.c)
        :intersection(v.a,v.b,u.a,u.b,u.c);
    ret.b=parallel(v.c,v.a,u.a,u.b,u.c)
        ?intersection(v.b,v.c,u.a,u.b,u.c)
        :intersection(v.c,v.a,u.a,u.b,u.c);
    <span class="kw">return</span> ret;
}

line3 intersection(point3 u1,point3 u2,point3 u3
                   ,point3 v1,point3 v2,point3 v3)
{
    line3 ret;
    ret.a=parallel(v1,v2,u1,u2,u3)
        ?intersection(v2,v3,u1,u2,u3)
        :intersection(v1,v2,u1,u2,u3);
    ret.b=parallel(v3,v1,u1,u2,u3)
        ?intersection(v2,v3,u1,u2,u3)
        :intersection(v3,v1,u1,u2,u3);
    <span class="kw">return</span> ret;
}</code></pre></div>
<h3 id="点到直线的距离"><span class="header-section-number">6.8.20</span> 点到直线的距离</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//点到直线距离</span>
<span class="dt">double</span> ptoline(point3 p,line3 l){
    <span class="kw">return</span> vlen(xmult(subt(p,l.a),subt(l.b,l.a)))/distance(l.a,l.b);
}

<span class="dt">double</span> ptoline(point3 p,point3 l1,point3 l2){
    <span class="kw">return</span> vlen(xmult(subt(p,l1),subt(l2,l1)))/distance(l1,l2);
}</code></pre></div>
<h3 id="计算点到平面的距离"><span class="header-section-number">6.8.21</span> 计算点到平面的距离</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//点到平面距离</span>
<span class="dt">double</span> ptoplane(point3 p,plane3 s){
    <span class="kw">return</span> fabs(dmult(pvec(s),subt(p,s.a)))/vlen(pvec(s));
}

<span class="dt">double</span> ptoplane(point3 p,point3 s1,point3 s2,point3 s3){
    <span class="kw">return</span> fabs(dmult(pvec(s1,s2,s3),subt(p,s1)))/vlen(pvec(s1,s2,s3));
}</code></pre></div>
<h3 id="计算直线到直线的距离"><span class="header-section-number">6.8.22</span> 计算直线到直线的距离</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//直线到直线距离</span>
<span class="dt">double</span> linetoline(line3 u,line3 v){
    point3 n=xmult(subt(u.a,u.b),subt(v.a,v.b));
    <span class="kw">return</span> fabs(dmult(subt(u.a,v.a),n))/vlen(n);
}

<span class="dt">double</span> linetoline(point3 u1,point3 u2,point3 v1,point3 v2){ 
    point3 n=xmult(subt(u1,u2),subt(v1,v2));
    <span class="kw">return</span> fabs(dmult(subt(u1,v1),n))/vlen(n);
}</code></pre></div>
<h3 id="空间两直线夹角的-cos-值"><span class="header-section-number">6.8.23</span> 空间两直线夹角的 cos 值</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//两直线夹角 cos 值</span>
<span class="dt">double</span> angle_cos(line3 u,line3 v){
    <span class="kw">return</span> dmult(subt(u.a,u.b),subt(v.a,v.b))
            /vlen(subt(u.a,u.b))
             /vlen(subt(v.a,v.b));
}

<span class="dt">double</span> angle_cos(point3 u1,point3 u2,point3 v1,point3 v2){
    <span class="kw">return</span> dmult(subt(u1,u2),subt(v1,v2))
            /vlen(subt(u1,u2))
            /vlen(subt(v1,v2));
}</code></pre></div>
<h3 id="两平面夹角的-cos-值"><span class="header-section-number">6.8.24</span> 两平面夹角的 cos 值</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//两平面夹角 cos 值</span>
<span class="dt">double</span> angle_cos(plane3 u,plane3 v){
    <span class="kw">return</span> dmult(pvec(u),pvec(v))/vlen(pvec(u))/vlen(pvec(v));
}

<span class="dt">double</span> angle_cos(point3 u1,point3 u2,point3 u3
                 ,point3 v1,point3 v2,point3 v3)
{
    <span class="kw">return</span> dmult(pvec(u1,u2,u3),pvec(v1,v2,v3))
        /vlen(pvec(u1,u2,u3))
        /vlen(pvec(v1,v2,v3));
}</code></pre></div>
<h3 id="直线与平面夹角-sin-值"><span class="header-section-number">6.8.25</span> 直线与平面夹角 sin 值</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//直线平面夹角 sin 值</span>
<span class="dt">double</span> angle_sin(line3 l,plane3 s){
    <span class="kw">return</span> dmult(subt(l.a,l.b),pvec(s))/vlen(subt(l.a,l.b))/vlen(pvec(s));
}

<span class="dt">double</span> angle_sin(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3){
    <span class="kw">return</span> dmult(subt(l1,l2),pvec(s1,s2,s3))
            /vlen(subt(l1,l2))
            /vlen(pvec(s1,s2,s3));
}</code></pre></div>
<h2 id="最远曼哈顿距离"><span class="header-section-number">6.9</span> 最远曼哈顿距离</h2>
<blockquote>
<p>计算5维坐标系中曼哈顿距离最远的两个点的</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="ot">#define INF 9999999999999.0</span>

<span class="kw">struct</span> Point{
    <span class="dt">double</span> x[<span class="dv">5</span>];
}pt[<span class="dv">100005</span>];

<span class="dt">double</span> dis[<span class="dv">32</span>][<span class="dv">100005</span>], coe[<span class="dv">5</span>], minx[<span class="dv">32</span>], maxx[<span class="dv">32</span>];

<span class="co">//去掉绝对值后有 2^D 种可能</span>
<span class="dt">void</span> GetD(<span class="dt">int</span> N, <span class="dt">int</span> D)
{
    <span class="dt">int</span> s, i, j, tot=(<span class="dv">1</span>&lt;&lt;D);
    <span class="kw">for</span> (s=<span class="dv">0</span>;s&lt;tot;s++)
    {
        <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;D;i++)
            <span class="kw">if</span> (s&amp;(<span class="dv">1</span>&lt;&lt;i))
                coe[i]=<span class="fl">-1.0</span>;
            <span class="kw">else</span> coe[i]=<span class="fl">1.0</span>;
        <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;N;i++)
        {
            dis[s][i]=<span class="fl">0.0</span>;
            <span class="kw">for</span> (j=<span class="dv">0</span>;j&lt;D;j++)
                dis[s][i]=dis[s][i]+coe[j]*pt[i].x[j];
        }
    }
}

<span class="co">//取每种可能中的最大差距</span>
<span class="dt">void</span> Solve(<span class="dt">int</span> N, <span class="dt">int</span> D)
{
    <span class="dt">int</span> s, i, tot=(<span class="dv">1</span>&lt;&lt;D);
    <span class="dt">double</span> tmp, ans;
    <span class="kw">for</span> (s=<span class="dv">0</span>;s&lt;tot;s++)
    {
        minx[s]=INF;
        maxx[s]=-INF;
        <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;N; i++)
        {
            <span class="kw">if</span> (minx[s]&gt;dis[s][i]) minx[s]=dis[s][i];
            <span class="kw">if</span> (maxx[s]&lt;dis[s][i]) maxx[s]=dis[s][i];
        }
    }
    ans=<span class="fl">0.0</span>;
    <span class="kw">for</span> (s=<span class="dv">0</span>; s&lt;tot; s++)
    {
        tmp=maxx[s]-minx[s];
        <span class="kw">if</span> (tmp&gt;ans) ans=tmp;
    }
    printf(<span class="st">&quot;</span><span class="ch">%.2lf\n</span><span class="st">&quot;</span>, ans);
}

<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="dt">int</span> n, i;
    <span class="kw">while</span> (scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;n)==<span class="dv">1</span>)
    {
        <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;n;i++)
            scanf(<span class="st">&quot;</span><span class="ch">%lf%lf%lf%lf%lf</span><span class="st">&quot;</span>,&amp;pt[i].x[<span class="dv">0</span>]
                  ,&amp;pt[i].x[<span class="dv">1</span>],&amp;pt[i].x[<span class="dv">2</span>]
                  ,&amp;pt[i].x[<span class="dv">3</span>],&amp;pt[i].x[<span class="dv">4</span>]);
        GetD(n, <span class="dv">5</span>);
        Solve(n, <span class="dv">5</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="最近点对"><span class="header-section-number">6.10</span> 最近点对</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>

<span class="ot">#define Max(x,y) (x)&gt;(y)?(x):(y)</span>

<span class="kw">struct</span> Q{
    <span class="dt">double</span> x, y;
}q[<span class="dv">100001</span>], sl[<span class="dv">10</span>], sr[<span class="dv">10</span>];

<span class="dt">int</span> cntl, cntr, lm, rm;
<span class="dt">double</span> ans;

<span class="dt">int</span> cmp(<span class="dt">const</span> <span class="dt">void</span>*p1, <span class="dt">const</span> <span class="dt">void</span>*p2)
{
    <span class="kw">struct</span> Q*a1=(<span class="kw">struct</span> Q*)p1;
    <span class="kw">struct</span> Q*a2=(<span class="kw">struct</span> Q*)p2;
    <span class="kw">if</span> (a1-&gt;x&lt;a2-&gt;x)<span class="kw">return</span> <span class="dv">-1</span>;
    <span class="kw">else</span> <span class="kw">if</span> (a1-&gt;x==a2-&gt;x)<span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">else</span> <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="dt">double</span> CalDis(<span class="dt">double</span> x1, <span class="dt">double</span> y1, <span class="dt">double</span> x2, <span class="dt">double</span> y2)
{
    <span class="kw">return</span> sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}

<span class="dt">void</span> MinDis(<span class="dt">int</span> l, <span class="dt">int</span> r)
{
    <span class="kw">if</span> (l==r) <span class="kw">return</span>;
    <span class="dt">double</span> dis;
    <span class="kw">if</span> (l<span class="dv">+1</span>==r)
    {
        dis=CalDis(q[l].x,q[l].y,q[r].x,q[r].y);
        <span class="kw">if</span> (ans&gt;dis) ans=dis;
        <span class="kw">return</span>;
    }
    <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>, i, j;
    MinDis(l,mid);
    MinDis(mid<span class="dv">+1</span>,r);
    lm=mid<span class="dv">+1-5</span>;
    <span class="kw">if</span> (lm&lt;l) lm=l;
    rm=mid<span class="dv">+5</span>;
    <span class="kw">if</span> (rm&gt;r) rm=r;
    cntl=cntr=<span class="dv">0</span>;
    <span class="kw">for</span> (i=mid;i&gt;=lm;i--)
    {
        <span class="kw">if</span> (q[mid<span class="dv">+1</span>].x-q[i].x&gt;=ans)<span class="kw">break</span>;
        sl[++cntl]=q[i];
    }
    <span class="kw">for</span> (i=mid<span class="dv">+1</span>;i&lt;=rm;i++)
    {
        <span class="kw">if</span> (q[i].x-q[mid].x&gt;=ans)<span class="kw">break</span>;
        sr[++cntr]=q[i];
    }
    <span class="kw">for</span> (i=<span class="dv">1</span>;i&lt;=cntl;i++)
        <span class="kw">for</span> (j=<span class="dv">1</span>;j&lt;=cntr;j++)
        {
            dis=CalDis(sl[i].x,sl[i].y,sr[j].x,sr[j].y);
            <span class="kw">if</span> (dis&lt;ans) ans=dis;
        }
}

<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="dt">int</span> n, i;
    <span class="kw">while</span> (scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;n)==<span class="dv">1</span>&amp;&amp;n)
    {
        <span class="kw">for</span> (i=<span class="dv">1</span>;i&lt;=n;i++)
            scanf(<span class="st">&quot;</span><span class="ch">%lf</span><span class="st"> </span><span class="ch">%lf</span><span class="st">&quot;</span>, &amp;q[i].x,&amp;q[i].y);
        qsort(q<span class="dv">+1</span>,n,<span class="kw">sizeof</span>(<span class="kw">struct</span> Q),cmp);
        ans=CalDis(q[<span class="dv">1</span>].x,q[<span class="dv">1</span>].y,q[<span class="dv">2</span>].x,q[<span class="dv">2</span>].y);
        MinDis(<span class="dv">1</span>,n);
        printf(<span class="st">&quot;</span><span class="ch">%.2lf\n</span><span class="st">&quot;</span>,ans/<span class="fl">2.0</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="最小包围圆"><span class="header-section-number">6.11</span> 最小包围圆</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;stdio.h&gt;</span>
<span class="ot">#include&lt;string.h&gt;</span>
<span class="ot">#include&lt;math.h&gt;</span>

<span class="kw">struct</span> Point{
    <span class="dt">double</span> x;
    <span class="dt">double</span> y;
}pt[<span class="dv">1005</span>];

<span class="kw">struct</span> Traingle{
    <span class="kw">struct</span> Point p[<span class="dv">3</span>];
};

<span class="kw">struct</span> Circle{
    <span class="kw">struct</span> Point center;
    <span class="dt">double</span> r;
}ans;

<span class="co">//计算两点距离</span>
<span class="dt">double</span> Dis(<span class="kw">struct</span> Point p, <span class="kw">struct</span> Point q)
{
    <span class="dt">double</span> dx=p.x-q.x;
    <span class="dt">double</span> dy=p.y-q.y;
    <span class="kw">return</span> sqrt(dx*dx+dy*dy);
}

<span class="co">//计算三角形面积</span>
<span class="dt">double</span> Area(<span class="kw">struct</span> Traingle ct)
{
    <span class="kw">return</span> fabs((ct.p[<span class="dv">1</span>].x-ct.p[<span class="dv">0</span>].x)*(ct.p[<span class="dv">2</span>].y-ct.p[<span class="dv">0</span>].y)
                -(ct.p[<span class="dv">2</span>].x-ct.p[<span class="dv">0</span>].x)*(ct.p[<span class="dv">1</span>].y-ct.p[<span class="dv">0</span>].y))/<span class="fl">2.0</span>;
}

<span class="co">//求三角形的外接圆，返回圆心和半径 (存在结构体&quot;圆&quot;中)</span>
<span class="kw">struct</span> Circle CircumCircle(<span class="kw">struct</span> Traingle t)
{
    <span class="kw">struct</span> Circle tmp;
    <span class="dt">double</span> a, b, c, c1, c2;
    <span class="dt">double</span> xA, yA, xB, yB, xC, yC;
    a = Dis(t.p[<span class="dv">0</span>], t.p[<span class="dv">1</span>]);
    b = Dis(t.p[<span class="dv">1</span>], t.p[<span class="dv">2</span>]);
    c = Dis(t.p[<span class="dv">2</span>], t.p[<span class="dv">0</span>]);
    <span class="co">//根据 S = a * b * c / R / 4;求半径 R</span>
    tmp.r = (a*b*c)/(Area(t)*<span class="fl">4.0</span>);
    xA = t.p[<span class="dv">0</span>].x;
    yA = t.p[<span class="dv">0</span>].y;
    xB = t.p[<span class="dv">1</span>].x;
    yB = t.p[<span class="dv">1</span>].y;
    xC = t.p[<span class="dv">2</span>].x;
    yC = t.p[<span class="dv">2</span>].y;
    c1 = (xA*xA+yA*yA - xB*xB-yB*yB) / <span class="dv">2</span>;
    c2 = (xA*xA+yA*yA - xC*xC-yC*yC) / <span class="dv">2</span>;
    tmp.center.x = (c1*(yA - yC)-c2*(yA - yB))
        / ((xA - xB)*(yA - yC)-(xA - xC)*(yA - yB));
    tmp.center.y = (c1*(xA - xC)-c2*(xA - xB))
        / ((yA - yB)*(xA - xC)-(yA - yC)*(xA - xB));
    <span class="kw">return</span> tmp;
}

<span class="co">//确定最小包围圆</span>
<span class="kw">struct</span> Circle MinCircle(<span class="dt">int</span> num, <span class="kw">struct</span> Traingle ct)
{
    <span class="kw">struct</span> Circle ret;
    <span class="kw">if</span> (num==<span class="dv">0</span>) ret.r = <span class="fl">0.0</span>;
    <span class="kw">else</span> <span class="kw">if</span> (num==<span class="dv">1</span>)
    {
        ret.center = ct.p[<span class="dv">0</span>];
        ret.r = <span class="fl">0.0</span>;
    }
    <span class="kw">else</span> <span class="kw">if</span> (num==<span class="dv">2</span>)
    {
        ret.center.x = (ct.p[<span class="dv">0</span>].x+ct.p[<span class="dv">1</span>].x)/<span class="fl">2.0</span>;
        ret.center.y = (ct.p[<span class="dv">0</span>].y+ct.p[<span class="dv">1</span>].y)/<span class="fl">2.0</span>;
        ret.r = Dis(ct.p[<span class="dv">0</span>], ct.p[<span class="dv">1</span>])/<span class="fl">2.0</span>;
    }
    <span class="kw">else</span> <span class="kw">if</span>(num==<span class="dv">3</span>) ret = CircumCircle(ct);
    <span class="kw">return</span> ret;
}

<span class="co">//递归实现增量算法</span>
<span class="dt">void</span> Dfs(<span class="dt">int</span> x, <span class="dt">int</span> num, <span class="kw">struct</span> Traingle ct)
{
    <span class="dt">int</span> i, j;
    <span class="kw">struct</span> Point tmp;
    ans = MinCircle(num, ct);
    <span class="kw">if</span> (num==<span class="dv">3</span>) <span class="kw">return</span>;
    <span class="kw">for</span> (i=<span class="dv">1</span>; i&lt;=x; i++)
        <span class="kw">if</span> (Dis(pt[i], ans.center)&gt;ans.r)
        {
            ct.p[num]=pt[i];
            Dfs(i<span class="dv">-1</span>, num<span class="dv">+1</span>, ct);
            tmp=pt[i];
            <span class="kw">for</span> (j=i;j&gt;=<span class="dv">2</span>;j--)
                pt[j]=pt[j<span class="dv">-1</span>];
            pt[<span class="dv">1</span>]=tmp;
        }
}

<span class="dt">void</span> Solve(<span class="dt">int</span> n)
{
    <span class="kw">struct</span> Traingle ct;
    Dfs(n, <span class="dv">0</span>, ct);
}

<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="dt">int</span> n, i;
    <span class="kw">while</span> (scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n)!=EOF &amp;&amp; n)
    {
        <span class="kw">for</span> (i=<span class="dv">1</span>;i&lt;=n;i++)
            scanf(<span class="st">&quot;</span><span class="ch">%lf</span><span class="st"> </span><span class="ch">%lf</span><span class="st">&quot;</span>, &amp;pt[i].x, &amp;pt[i].y);
        Solve(n);
        printf(<span class="st">&quot;</span><span class="ch">%.2lf</span><span class="st"> </span><span class="ch">%.2lf</span><span class="st"> </span><span class="ch">%.2lf\n</span><span class="st">&quot;</span>, ans.center.x, ans.center.y, ans.r);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="求两个圆的交点"><span class="header-section-number">6.12</span> 求两个圆的交点</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;stdio.h&gt;</span>
<span class="ot">#include&lt;string.h&gt;</span>
<span class="ot">#include&lt;math.h&gt;</span>
<span class="ot">#include&lt;stdlib.h&gt;</span>

<span class="dt">const</span> <span class="dt">double</span> eps = <span class="fl">1e-8</span>;
<span class="dt">const</span> <span class="dt">double</span> PI = acos(<span class="fl">-1.0</span>);

<span class="kw">struct</span> Point{
    <span class="dt">double</span> x;
    <span class="dt">double</span> y;
};

<span class="kw">struct</span> Line{
    <span class="dt">double</span> s, t;
};

<span class="kw">struct</span> Circle{
    Point center;
    <span class="dt">double</span> r;
    Line line[<span class="dv">505</span>];
    <span class="dt">int</span> cnt;
    <span class="dt">bool</span> covered;
}circle[<span class="dv">105</span>];

<span class="dt">double</span> distance(point p1, point p2)
{
    <span class="dt">double</span> dx = p1.x-p2.x;
    <span class="dt">double</span> dy = p1.y-p2.y;
    <span class="kw">return</span> sqrt(dx*dx + dy*dy);
}

point intersection(point u1,point u2, point v1,point v2)
{
    point ret = u1;
    <span class="dt">double</span> t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))
        / ((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));
    ret.x += (u2.x-u1.x)*t;
    ret.y += (u2.y-u1.y)*t;
    <span class="kw">return</span> ret;
}

<span class="dt">void</span> intersection_line_circle(point c,<span class="dt">double</span> r
                              ,point l1,point l2
                              ,point&amp; p1,point&amp; p2)
{
    point p=c;
    <span class="dt">double</span> t;
    p.x+=l1.y-l2.y;
    p.y+=l2.x-l1.x;
    p=intersection(p,c,l1,l2);
    t=sqrt(r*r-distance(p,c)*distance(p,c))/distance(l1,l2);
    p1.x=p.x+(l2.x-l1.x)*t;
    p1.y=p.y+(l2.y-l1.y)*t;
    p2.x=p.x-(l2.x-l1.x)*t;
    p2.y=p.y-(l2.y-l1.y)*t;
}

<span class="co">//计算圆与圆的交点,保证圆与圆有交点,圆心不重合</span>
<span class="dt">void</span> intersection_circle_circle(point c1,<span class="dt">double</span> r1
                                ,point c2,<span class="dt">double</span> r2
                                ,point&amp; p1,point&amp; p2)
{
    point u,v;
    <span class="dt">double</span> t;
    t=(<span class="dv">1</span>+(r1*r1-r2*r2)/distance(c1,c2)/distance(c1,c2))/<span class="dv">2</span>;
    u.x=c1.x+(c2.x-c1.x)*t;
    u.y=c1.y+(c2.y-c1.y)*t;
    v.x=u.x+c1.y-c2.y;
    v.y=u.y-c1.x+c2.x;
    intersection_line_circle(c1,r1,u,v,p1,p2);
}</code></pre></div>
<h2 id="求三角形外接圆圆心"><span class="header-section-number">6.13</span> 求三角形外接圆圆心</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Point{
    <span class="dt">double</span> x;
    <span class="dt">double</span> y;
}pt[<span class="dv">1005</span>];

<span class="kw">struct</span> Traingle{
    <span class="kw">struct</span> Point p[<span class="dv">3</span>];
};

<span class="kw">struct</span> Circle{
    <span class="kw">struct</span> Point center;
    <span class="dt">double</span> r;
}ans;

<span class="co">//计算两点距离</span>
<span class="dt">double</span> Dis(<span class="kw">struct</span> Point p, <span class="kw">struct</span> Point q)
{
    <span class="dt">double</span> dx=p.x-q.x;
    <span class="dt">double</span> dy=p.y-q.y;
    <span class="kw">return</span> sqrt(dx*dx+dy*dy);
}

<span class="co">//计算三角形面积</span>
<span class="dt">double</span> Area(<span class="kw">struct</span> Traingle ct)
{
    <span class="kw">return</span> fabs((ct.p[<span class="dv">1</span>].x-ct.p[<span class="dv">0</span>].x)*(ct.p[<span class="dv">2</span>].y-ct.p[<span class="dv">0</span>].y)
                -(ct.p[<span class="dv">2</span>].x-ct.p[<span class="dv">0</span>].x)*(ct.p[<span class="dv">1</span>].y-ct.p[<span class="dv">0</span>].y))/<span class="fl">2.0</span>;
}

<span class="co">//求三角形的外接圆，返回圆心和半径 (存在结构体&quot;圆&quot;中)</span>
<span class="kw">struct</span> Circle CircumCircle(<span class="kw">struct</span> Traingle t)
{
    <span class="kw">struct</span> Circle tmp;
    <span class="dt">double</span> a, b, c, c1, c2;
    <span class="dt">double</span> xA, yA, xB, yB, xC, yC;
    a = Dis(t.p[<span class="dv">0</span>], t.p[<span class="dv">1</span>]);
    b = Dis(t.p[<span class="dv">1</span>], t.p[<span class="dv">2</span>]);
    c = Dis(t.p[<span class="dv">2</span>], t.p[<span class="dv">0</span>]);
    <span class="co">//根据 S = a * b * c / R / 4;求半径 R</span>
    tmp.r = (a*b*c)/(Area(t)*<span class="fl">4.0</span>);
    xA = t.p[<span class="dv">0</span>].x;
    yA = t.p[<span class="dv">0</span>].y;
    xB = t.p[<span class="dv">1</span>].x;
    yB = t.p[<span class="dv">1</span>].y;
    xC = t.p[<span class="dv">2</span>].x;
    yC = t.p[<span class="dv">2</span>].y;
    c1 = (xA*xA+yA*yA - xB*xB-yB*yB) / <span class="dv">2</span>;
    c2 = (xA*xA+yA*yA - xC*xC-yC*yC) / <span class="dv">2</span>;
    tmp.center.x = (c1*(yA - yC)-c2*(yA - yB))
        / ((xA - xB)*(yA - yC)-(xA - xC)*(yA - yB));
    tmp.center.y = (c1*(xA - xC)-c2*(xA - xB))
        / ((yA - yB)*(xA - xC)-(yA - yC)*(xA - xB));
    <span class="kw">return</span> tmp;
}</code></pre></div>
<h2 id="求凸包"><span class="header-section-number">6.14</span> 求凸包</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>

<span class="ot">#define INF 999999999.9</span>
<span class="ot">#define PI acos(-1.0)</span>

<span class="kw">struct</span> Point{
    <span class="dt">double</span> x, y, dis;
}pt[<span class="dv">1005</span>], stack[<span class="dv">1005</span>], p0;

<span class="dt">int</span> top, tot;

<span class="co">//计算几何距离</span>
<span class="dt">double</span> Dis(<span class="dt">double</span> x1, <span class="dt">double</span> y1, <span class="dt">double</span> x2, <span class="dt">double</span> y2)
{
    <span class="kw">return</span> sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}

<span class="co">//极角比较， 返回-1: p0p1 在 p0p2 的右侧，返回 0:p0,p1,p2 共线</span>
<span class="dt">int</span> Cmp_PolarAngel(<span class="kw">struct</span> Point p1, <span class="kw">struct</span> Point p2, <span class="kw">struct</span> Point pb)
{
    <span class="dt">double</span> delta=(p1.x-pb.x)*(p2.y-pb.y)-(p2.x-pb.x)*(p1.y-pb.y);
    <span class="kw">if</span>(delta&lt;<span class="fl">0.0</span>) <span class="kw">return</span> <span class="dv">1</span>;
    <span class="kw">else</span> <span class="kw">if</span> (delta==<span class="fl">0.0</span>) <span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">else</span> <span class="kw">return</span> <span class="dv">-1</span>;
}

<span class="co">//判断向量 p2p3 是否对 p1p2 构成左旋</span>
<span class="dt">bool</span> Is_LeftTurn(<span class="kw">struct</span> Point p3, <span class="kw">struct</span> Point p2, <span class="kw">struct</span> Point p1)
{
    <span class="dt">int</span> type=Cmp_PolarAngel(p3, p1, p2);
    <span class="kw">if</span> (type&lt;<span class="dv">0</span>) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="co">//先按极角排，再按距离由小到大排</span>
<span class="dt">int</span> Cmp(<span class="dt">const</span> <span class="dt">void</span>*p1, <span class="dt">const</span> <span class="dt">void</span>*p2)
{
    <span class="kw">struct</span> Point*a1=(<span class="kw">struct</span> Point*)p1;
    <span class="kw">struct</span> Point*a2=(<span class="kw">struct</span> Point*)p2;
    <span class="dt">int</span> type=Cmp_PolarAngel(*a1, *a2, p0);
    <span class="kw">if</span> (type&lt;<span class="dv">0</span>) <span class="kw">return</span> <span class="dv">-1</span>;
    <span class="kw">else</span> <span class="kw">if</span> (type==<span class="dv">0</span>)
    {
        <span class="kw">if</span> (a1-&gt;dis&lt;a2-&gt;dis) <span class="kw">return</span> <span class="dv">-1</span>;
        <span class="kw">else</span> <span class="kw">if</span> (a1-&gt;dis==a2-&gt;dis) <span class="kw">return</span> <span class="dv">0</span>;
        <span class="kw">else</span> <span class="kw">return</span> <span class="dv">1</span>;
    }
    <span class="kw">else</span> <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="co">//求凸包</span>
<span class="dt">void</span> Solve(<span class="dt">int</span> n)
{
    <span class="dt">int</span> i, k;
    p0.x=p0.y=INF;
    <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;n;i++)
    {
        scanf(<span class="st">&quot;</span><span class="ch">%lf</span><span class="st"> </span><span class="ch">%lf</span><span class="st">&quot;</span>,&amp;pt[i].x, &amp;pt[i].y);
        <span class="kw">if</span> (pt[i].y &lt; p0.y)
        {
            p0.y=pt[i].y;
            p0.x=pt[i].x;
            k=i;
        }
        <span class="kw">else</span> <span class="kw">if</span> (pt[i].y==p0.y)
        {
            <span class="kw">if</span> (pt[i].x&lt;p0.x)
            {
                p0.x=pt[i].x;
                k=i;
            }
        }
    }
    pt[k]=pt[<span class="dv">0</span>];
    pt[<span class="dv">0</span>]=p0;
    <span class="kw">for</span> (i=<span class="dv">1</span>;i&lt;n;i++)
        pt[i].dis=Dis(pt[i].x,pt[i].y, p0.x,p0.y);
    qsort(pt<span class="dv">+1</span>, n<span class="dv">-1</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> Point), Cmp);
    <span class="co">//去掉极角相同的点</span>
    tot=<span class="dv">1</span>;
    <span class="kw">for</span> (i=<span class="dv">2</span>;i&lt;n;i++)
        <span class="kw">if</span> (Cmp_PolarAngel(pt[i], pt[i<span class="dv">-1</span>], p0))
            pt[tot++]=pt[i<span class="dv">-1</span>];
    pt[tot++]=pt[n<span class="dv">-1</span>];
    <span class="co">//求凸包</span>
    top=<span class="dv">1</span>;
    stack[<span class="dv">0</span>]=pt[<span class="dv">0</span>];
    stack[<span class="dv">1</span>]=pt[<span class="dv">1</span>];
    <span class="kw">for</span> (i=<span class="dv">2</span>;i&lt;tot;i++)
    {
        <span class="kw">while</span> (top&gt;=<span class="dv">1</span>
               &amp;&amp;
               Is_LeftTurn(pt[i], stack[top],stack[top<span class="dv">-1</span>])==<span class="kw">false</span>)
            top--;
        stack[++top]=pt[i];
    }
}

<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="dt">int</span> n;
    <span class="kw">while</span> (scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;n)==<span class="dv">2</span>)
    {
        Solve(n);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="凸包卡壳旋转求出所有对踵点最远点对"><span class="header-section-number">6.15</span> 凸包卡壳旋转求出所有对踵点、最远点对</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>

<span class="ot">#define INF 999999999.9</span>
<span class="ot">#define PI acos(-1.0)</span>

<span class="kw">struct</span> Point{
    <span class="dt">double</span> x, y, dis;
}pt[<span class="dv">6005</span>], stack[<span class="dv">6005</span>], p0;

<span class="dt">int</span> top, tot;

<span class="co">//计算几何距离</span>
<span class="dt">double</span> Dis(<span class="dt">double</span> x1, <span class="dt">double</span> y1, <span class="dt">double</span> x2, <span class="dt">double</span> y2)
{
    <span class="kw">return</span> sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}

<span class="co">//极角比较， 返回-1: p0p1 在 p0p2 的右侧，返回 0:p0,p1,p2 共线</span>
<span class="dt">int</span> Cmp_PolarAngel(<span class="kw">struct</span> Point p1, <span class="kw">struct</span> Point p2, <span class="kw">struct</span> Point pb)
{
    <span class="dt">double</span> delta=(p1.x-pb.x)*(p2.y-pb.y)-(p2.x-pb.x)*(p1.y-pb.y);
    <span class="kw">if</span>(delta&lt;<span class="fl">0.0</span>) <span class="kw">return</span> <span class="dv">1</span>;
    <span class="kw">else</span> <span class="kw">if</span> (delta==<span class="fl">0.0</span>) <span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">else</span> <span class="kw">return</span> <span class="dv">-1</span>;
}

<span class="co">//判断向量 p2p3 是否对 p1p2 构成左旋</span>
<span class="dt">bool</span> Is_LeftTurn(<span class="kw">struct</span> Point p3, <span class="kw">struct</span> Point p2, <span class="kw">struct</span> Point p1)
{
    <span class="dt">int</span> type=Cmp_PolarAngel(p3, p1, p2);
    <span class="kw">if</span> (type&lt;<span class="dv">0</span>) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="co">//先按极角排，再按距离由小到大排</span>
<span class="dt">int</span> Cmp(<span class="dt">const</span> <span class="dt">void</span>*p1, <span class="dt">const</span> <span class="dt">void</span>*p2)
{
    <span class="kw">struct</span> Point*a1=(<span class="kw">struct</span> Point*)p1;
    <span class="kw">struct</span> Point*a2=(<span class="kw">struct</span> Point*)p2;
    <span class="dt">int</span> type=Cmp_PolarAngel(*a1, *a2, p0);
    <span class="kw">if</span> (type&lt;<span class="dv">0</span>) <span class="kw">return</span> <span class="dv">-1</span>;
    <span class="kw">else</span> <span class="kw">if</span> (type==<span class="dv">0</span>)
    {
        <span class="kw">if</span> (a1-&gt;dis&lt;a2-&gt;dis) <span class="kw">return</span> <span class="dv">-1</span>;
        <span class="kw">else</span> <span class="kw">if</span> (a1-&gt;dis==a2-&gt;dis) <span class="kw">return</span> <span class="dv">0</span>;
        <span class="kw">else</span> <span class="kw">return</span> <span class="dv">1</span>;
    }
    <span class="kw">else</span> <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="co">//求凸包</span>
<span class="dt">void</span> Hull(<span class="dt">int</span> n)
{
    <span class="dt">int</span> i, k;
    p0.x=p0.y=INF;
    <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;n;i++)
    {
        scanf(<span class="st">&quot;</span><span class="ch">%lf</span><span class="st"> </span><span class="ch">%lf</span><span class="st">&quot;</span>,&amp;pt[i].x, &amp;pt[i].y);
        <span class="kw">if</span> (pt[i].y &lt; p0.y)
        {
            p0.y=pt[i].y;
            p0.x=pt[i].x;
            k=i;
        }
        <span class="kw">else</span> <span class="kw">if</span> (pt[i].y==p0.y)
        {
            <span class="kw">if</span> (pt[i].x&lt;p0.x)
            {
                p0.x=pt[i].x;
                k=i;
            }
        }
    }
    pt[k]=pt[<span class="dv">0</span>];
    pt[<span class="dv">0</span>]=p0;
    <span class="kw">for</span> (i=<span class="dv">1</span>;i&lt;n;i++)
        pt[i].dis=Dis(pt[i].x,pt[i].y, p0.x,p0.y);
    qsort(pt<span class="dv">+1</span>, n<span class="dv">-1</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> Point), Cmp);
    <span class="co">//去掉极角相同的点</span>
    tot=<span class="dv">1</span>;
    <span class="kw">for</span> (i=<span class="dv">2</span>;i&lt;n;i++)
        <span class="kw">if</span> (Cmp_PolarAngel(pt[i], pt[i<span class="dv">-1</span>], p0))
            pt[tot++]=pt[i<span class="dv">-1</span>];
    pt[tot++]=pt[n<span class="dv">-1</span>];
    <span class="co">//求凸包</span>
    top=<span class="dv">1</span>;
    stack[<span class="dv">0</span>]=pt[<span class="dv">0</span>];
    stack[<span class="dv">1</span>]=pt[<span class="dv">1</span>];
    <span class="kw">for</span> (i=<span class="dv">2</span>;i&lt;tot;i++)
    {
        <span class="kw">while</span> (top&gt;=<span class="dv">1</span> &amp;&amp; Is_LeftTurn(pt[i], stack[top],
                                     stack[top<span class="dv">-1</span>])==<span class="kw">false</span>)
            top--;
        stack[++top]=pt[i];
    }
}

<span class="co">//计算叉积</span>
<span class="dt">double</span> CrossProduct(<span class="kw">struct</span> Point p1, <span class="kw">struct</span> Point p2, <span class="kw">struct</span> Point p3)
{
    <span class="kw">return</span> (p1.x-p3.x)*(p2.y-p3.y)-(p2.x-p3.x)*(p1.y-p3.y);
}

<span class="co">//卡壳旋转，求出凸多边形所有对踵点</span>
<span class="dt">void</span> Rotate(<span class="kw">struct</span> Point*ch, <span class="dt">int</span> n)
{
    <span class="dt">int</span> i, p=<span class="dv">1</span>;
    <span class="dt">double</span> t1, t2, ans=<span class="fl">0.0</span>, dif;
    ch[n]=ch[<span class="dv">0</span>];
    <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;n;i++)
    {
        <span class="co">//如果下一个点与当前边构成的三角形的面积更大，则说明此时不构成对踵点</span>
        <span class="kw">while</span> (fabs(CrossProduct(ch[i],ch[i<span class="dv">+1</span>],ch[p<span class="dv">+1</span>])) &gt;
               fabs(CrossProduct(ch[i],ch[i<span class="dv">+1</span>],ch[p])))
            p=(p<span class="dv">+1</span>)%n;
        dif=fabs(CrossProduct(ch[i],ch[i<span class="dv">+1</span>],ch[p<span class="dv">+1</span>])) -
            fabs(CrossProduct(ch[i],ch[i<span class="dv">+1</span>],ch[p]));
        <span class="co">//如果当前点和下一个点分别构成的三角形面积相等</span>
        <span class="co">//则说明两条边即为平行线，对角线两端都可能是对踵点</span>
        <span class="kw">if</span> (dif==<span class="fl">0.0</span>)
        {
            t1=Dis(ch[p].x, ch[p].y, ch[i].x, ch[i].y);
            t2=Dis(ch[p<span class="dv">+1</span>].x, ch[p<span class="dv">+1</span>].y, ch[i<span class="dv">+1</span>].x, ch[i<span class="dv">+1</span>].y);
            <span class="kw">if</span> (t1&gt;ans)ans=t1;
            <span class="kw">if</span> (t2&gt;ans)ans=t2;
        }
        <span class="co">//说明 p，i 是对踵点</span>
        <span class="kw">else</span> <span class="kw">if</span> (dif&lt;<span class="fl">0.0</span>)
        {
            t1=Dis(ch[p].x, ch[p].y, ch[i].x, ch[i].y);
            <span class="kw">if</span> (t1&gt;ans)ans=t1;
        }
    }
    printf(<span class="st">&quot;</span><span class="ch">%.2lf\n</span><span class="st">&quot;</span>,ans);
}

<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="dt">int</span> n;
    <span class="kw">while</span> (scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;n)==<span class="dv">1</span>)
    {
        Hull(n);
        Rotate(stack, top<span class="dv">+1</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="凸包旋转卡壳求平面面积最大三角"><span class="header-section-number">6.16</span> 凸包+旋转卡壳求平面面积最大三角</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>

<span class="ot">#define INF 99999999999.9</span>
<span class="ot">#define PI acos(-1.0)</span>

<span class="kw">struct</span> Point{
    <span class="dt">double</span> x, y, dis;
}pt[<span class="dv">50005</span>], stack[<span class="dv">50005</span>], p0;

<span class="dt">int</span> top, tot;

<span class="dt">double</span> Dis(<span class="dt">double</span> x1, <span class="dt">double</span> y1, <span class="dt">double</span> x2, <span class="dt">double</span> y2)
{
    <span class="kw">return</span> sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}

<span class="dt">int</span> Cmp_PolarAngel(<span class="kw">struct</span> Point p1, <span class="kw">struct</span> Point p2, <span class="kw">struct</span> Point pb)
{
    <span class="dt">double</span> delta=(p1.x-pb.x)*(p2.y-pb.y)-(p2.x-pb.x)*(p1.y-pb.y);
    <span class="kw">if</span>(delta&lt;<span class="fl">0.0</span>) <span class="kw">return</span> <span class="dv">1</span>;
    <span class="kw">else</span> <span class="kw">if</span> (delta==<span class="fl">0.0</span>) <span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">else</span> <span class="kw">return</span> <span class="dv">-1</span>;
}

<span class="dt">bool</span> Is_LeftTurn(<span class="kw">struct</span> Point p3, <span class="kw">struct</span> Point p2, <span class="kw">struct</span> Point p1)
{
    <span class="dt">int</span> type=Cmp_PolarAngel(p3, p1, p2);
    <span class="kw">if</span> (type&lt;<span class="dv">0</span>) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">int</span> Cmp(<span class="dt">const</span> <span class="dt">void</span>*p1, <span class="dt">const</span> <span class="dt">void</span>*p2)
{
    <span class="kw">struct</span> Point*a1=(<span class="kw">struct</span> Point*)p1;
    <span class="kw">struct</span> Point*a2=(<span class="kw">struct</span> Point*)p2;
    <span class="dt">int</span> type=Cmp_PolarAngel(*a1, *a2, p0);
    <span class="kw">if</span> (type&lt;<span class="dv">0</span>) <span class="kw">return</span> <span class="dv">-1</span>;
    <span class="kw">else</span> <span class="kw">if</span> (type==<span class="dv">0</span>)
    {
        <span class="kw">if</span> (a1-&gt;dis&lt;a2-&gt;dis) <span class="kw">return</span> <span class="dv">-1</span>;
        <span class="kw">else</span> <span class="kw">if</span> (a1-&gt;dis==a2-&gt;dis) <span class="kw">return</span> <span class="dv">0</span>;
        <span class="kw">else</span> <span class="kw">return</span> <span class="dv">1</span>;
    }
    <span class="kw">else</span> <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="dt">void</span> Hull(<span class="dt">int</span> n)
{
    <span class="dt">int</span> i, k;
    p0.x=p0.y=INF;
    <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;n;i++)
    {
        scanf(<span class="st">&quot;</span><span class="ch">%lf</span><span class="st"> </span><span class="ch">%lf</span><span class="st">&quot;</span>,&amp;pt[i].x, &amp;pt[i].y);
        <span class="kw">if</span> (pt[i].y &lt; p0.y)
        {
            p0.y=pt[i].y;
            p0.x=pt[i].x;
            k=i;
        }
        <span class="kw">else</span> <span class="kw">if</span> (pt[i].y==p0.y)
        {
            <span class="kw">if</span> (pt[i].x&lt;p0.x)
            {
                p0.x=pt[i].x;
                k=i;
            }
        }
    }
    pt[k]=pt[<span class="dv">0</span>];
    pt[<span class="dv">0</span>]=p0;
    <span class="kw">for</span> (i=<span class="dv">1</span>;i&lt;n;i++)
        pt[i].dis=Dis(pt[i].x,pt[i].y, p0.x,p0.y);
    qsort(pt<span class="dv">+1</span>, n<span class="dv">-1</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> Point), Cmp);
    tot=<span class="dv">1</span>;
    <span class="kw">for</span> (i=<span class="dv">2</span>;i&lt;n;i++)
        <span class="kw">if</span> (Cmp_PolarAngel(pt[i], pt[i<span class="dv">-1</span>], p0))
            pt[tot++]=pt[i<span class="dv">-1</span>];
    pt[tot++]=pt[n<span class="dv">-1</span>];
    top=<span class="dv">1</span>;
    stack[<span class="dv">0</span>]=pt[<span class="dv">0</span>];
    stack[<span class="dv">1</span>]=pt[<span class="dv">1</span>];
    <span class="kw">for</span> (i=<span class="dv">2</span>;i&lt;tot;i++)
    {
        <span class="kw">while</span> (top&gt;=<span class="dv">1</span> &amp;&amp; Is_LeftTurn(pt[i], stack[top],
                                     stack[top<span class="dv">-1</span>])==<span class="kw">false</span>)
            top--;
        stack[++top]=pt[i];
    }
}

<span class="dt">double</span> TArea(<span class="kw">struct</span> Point p1, <span class="kw">struct</span> Point p2, <span class="kw">struct</span> Point p3)
{
    <span class="kw">return</span> fabs((p1.x-p3.x)*(p2.y-p3.y)-(p2.x-p3.x)*(p1.y-p3.y));
}

<span class="dt">void</span> Rotate(<span class="kw">struct</span> Point*ch, <span class="dt">int</span> n)
{
    <span class="kw">if</span> (n&lt;<span class="dv">3</span>)
    {
        printf(<span class="st">&quot;0.00</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">return</span>;
    }
    <span class="dt">int</span> i, j, k;
    <span class="dt">double</span> ans=<span class="fl">0.0</span>, tmp;
    ch[n]=ch[<span class="dv">0</span>];
    <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;n;i++)
    {
        j=(i<span class="dv">+1</span>)%n;
        k=(j<span class="dv">+1</span>)%n;
        <span class="kw">while</span> ((j!=k) &amp;&amp; (k!=i))
        {
            <span class="kw">while</span>
                (TArea(ch[i],ch[j],ch[k<span class="dv">+1</span>])&gt;TArea(ch[i],ch[j],ch[k]))
                    k=(k<span class="dv">+1</span>)%n;
            tmp=TArea(ch[i],ch[j], ch[k]);
            <span class="kw">if</span> (tmp&gt;ans) ans=tmp;
            j=(j<span class="dv">+1</span>)%n;
        }
    }
    printf(<span class="st">&quot;</span><span class="ch">%.2lf\n</span><span class="st">&quot;</span>,ans/<span class="fl">2.0</span>);
}

<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="dt">int</span> n;
    <span class="kw">while</span> (scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;n)==<span class="dv">1</span>)
    {
        <span class="kw">if</span> (n==<span class="dv">-1</span>)<span class="kw">break</span>;
        Hull(n);
        Rotate(stack, top<span class="dv">+1</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="pick-定理"><span class="header-section-number">6.17</span> Pick 定理</h2>
<p><strong>Pick 定理求整点多边形内部整点数目</strong></p>
<ol style="list-style-type: decimal">
<li><p>给定顶点坐标均是整点（或正方形格点）的简单多边形，皮克定理说明了其面积<span class="math inline">\(A\)</span> 和内部格点数目 <span class="math inline">\(i\)</span>、边上格点数目 <span class="math inline">\(b\)</span> 的关系：<span class="math inline">\(A = i + \frac{b}{2} - 1\)</span></p></li>
<li><p>在两点<span class="math inline">\((x_1,y_1)\)</span>，<span class="math inline">\((x_2,y_2)\)</span>连线之间的整点个数（包含一个端点）为<span class="math inline">\(gcd\left(\left|x_1－x_2\right|,\left|y_1－y_2\right|\right)\)</span></p></li>
<li><p>求三角形面积用叉乘</p></li>
</ol>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;stdio.h&gt;</span>
<span class="ot">#include&lt;stdlib.h&gt;</span>
<span class="ot">#include&lt;math.h&gt;</span>
<span class="ot">#include&lt;string.h&gt;</span>

<span class="dt">long</span> <span class="dt">long</span> x[<span class="dv">3</span>], y[<span class="dv">3</span>], area, b;

<span class="dt">long</span> <span class="dt">long</span> My_Abs(<span class="dt">long</span> <span class="dt">long</span> t)
{
    <span class="kw">if</span> (t&lt;<span class="dv">0</span>) <span class="kw">return</span> -t;
    <span class="kw">return</span> t;
}

<span class="dt">long</span> <span class="dt">long</span> Gcd(<span class="dt">long</span> <span class="dt">long</span> x, <span class="dt">long</span> <span class="dt">long</span> y)
{
    <span class="kw">if</span> (y==<span class="dv">0</span>) <span class="kw">return</span> x;
    <span class="dt">long</span> <span class="dt">long</span> mod=x%y;
    <span class="kw">while</span> (mod)
    {
        x=y;
        y=mod;
        mod=x%y;
    }
    <span class="kw">return</span> y;
}

<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="dt">int</span> i;
    <span class="kw">while</span> (<span class="dv">1</span>)
    {
        <span class="kw">for</span> (i = <span class="dv">0</span>;i &lt; <span class="dv">3</span>;i ++)
            scanf(<span class="st">&quot;</span><span class="ch">%lld</span><span class="st"> </span><span class="ch">%lld</span><span class="st">&quot;</span>, &amp;x[i], &amp;y[i]);
        <span class="kw">if</span>(x[<span class="dv">0</span>]==<span class="dv">0</span>&amp;&amp;y[<span class="dv">0</span>]==<span class="dv">0</span>&amp;&amp;x[<span class="dv">1</span>]==<span class="dv">0</span>&amp;&amp;y[<span class="dv">1</span>]==<span class="dv">0</span>&amp;&amp;x[<span class="dv">2</span>]==<span class="dv">0</span>&amp;&amp;y[<span class="dv">2</span>]==<span class="dv">0</span>)
            <span class="kw">break</span>;
        area = (x[<span class="dv">1</span>]-x[<span class="dv">0</span>])*(y[<span class="dv">2</span>]-y[<span class="dv">0</span>])-(x[<span class="dv">2</span>]-x[<span class="dv">0</span>])*(y[<span class="dv">1</span>]-y[<span class="dv">0</span>]);
        area = My_Abs(area);
        b=<span class="dv">0</span>;
        b=Gcd(My_Abs(x[<span class="dv">1</span>]-x[<span class="dv">0</span>]), My_Abs(y[<span class="dv">1</span>]-y[<span class="dv">0</span>])) +
            Gcd(My_Abs(x[<span class="dv">2</span>]-x[<span class="dv">0</span>]), My_Abs(y[<span class="dv">2</span>]-y[<span class="dv">0</span>])) +
            Gcd(My_Abs(x[<span class="dv">1</span>]-x[<span class="dv">2</span>]), My_Abs(y[<span class="dv">1</span>]-y[<span class="dv">2</span>]));
        printf(<span class="st">&quot;</span><span class="ch">%lld\n</span><span class="st">&quot;</span>, (area-b<span class="dv">+2</span>)/<span class="dv">2</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="求多边形面积和重心"><span class="header-section-number">6.18</span> 求多边形面积和重心</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>

<span class="dt">int</span> x[<span class="dv">1000003</span>], y[<span class="dv">1000003</span>];
<span class="dt">double</span> A, tx, ty, tmp;

<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="dt">int</span> cases, n, i;
    scanf (<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;cases);
    <span class="kw">while</span> (cases --)
    {
        scanf (<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        A = <span class="fl">0.0</span>;
        x[<span class="dv">0</span>] = y[<span class="dv">0</span>] = <span class="dv">0</span>;
        <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt;= n; i ++)
        {
            scanf (<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;x[i], &amp;y[i]);
            A += (x[i<span class="dv">-1</span>]*y[i] - x[i]*y[i<span class="dv">-1</span>]);
        }
        A += x[n]*y[<span class="dv">1</span>] - x[<span class="dv">1</span>]*y[n];
        A = A / <span class="fl">2.0</span>;
        tx = ty = <span class="fl">0.0</span>;
        <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt; n; i ++)
        {
            tmp = x[i]*y[i<span class="dv">+1</span>] - x[i<span class="dv">+1</span>]*y[i];
            tx += (x[i]+x[i<span class="dv">+1</span>]) * tmp;
            ty += (y[i]+y[i<span class="dv">+1</span>]) * tmp;
        }
        tmp = x[n]*y[<span class="dv">1</span>] - x[<span class="dv">1</span>]*y[n];
        tx += (x[n]+x[<span class="dv">1</span>])*tmp;
        ty += (y[n]+y[<span class="dv">1</span>])*tmp;
        printf (<span class="st">&quot;</span><span class="ch">%.2lf</span><span class="st"> </span><span class="ch">%.2lf\n</span><span class="st">&quot;</span>, tx/(<span class="fl">6.0</span>*A), ty/(<span class="fl">6.0</span>*A));
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="判断一个简单多边形是否有核"><span class="header-section-number">6.19</span> 判断一个简单多边形是否有核</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="dt">const</span> <span class="dt">int</span> INF = (<span class="dv">1</span>&lt;&lt;<span class="dv">30</span>);

<span class="kw">struct</span> Point{
    <span class="dt">int</span> x, y;
}pt[<span class="dv">150</span>];

<span class="dt">bool</span> turn_right[<span class="dv">150</span>];

<span class="dt">int</span> det(Point s1, Point t1, Point s2, Point t2)
{
    <span class="dt">int</span> d1x = t1.x-s1.x;
    <span class="dt">int</span> d1y = t1.y-s1.y;
    <span class="dt">int</span> d2x = t2.x-s2.x;
    <span class="dt">int</span> d2y = t2.y-s2.y;
    <span class="kw">return</span> d1x*d2y - d2x*d1y;
}

<span class="dt">void</span> Swap(<span class="dt">int</span> &amp;a, <span class="dt">int</span> &amp;b)
{
    <span class="kw">if</span> (a&gt;b)
    {
        <span class="dt">int</span> t=a;
        a=b;
        b=t;
    }
}

<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="dt">int</span> n, i, cross, maxx, minx, maxy, miny, maxn, minn, countn=<span class="dv">0</span>;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n)==<span class="dv">1</span>&amp;&amp;n)
    {
        maxx=maxy=-INF;
        minx=miny=INF;
        <span class="co">//点按顺时针给出</span>
        <span class="kw">for</span> (i=<span class="dv">1</span>; i&lt;=n; i++)
        {
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;pt[i].x, &amp;pt[i].y);
            <span class="kw">if</span> (maxx&lt;pt[i].x) maxx=pt[i].x;
            <span class="kw">if</span> (maxy&lt;pt[i].y) maxy=pt[i].y;
            <span class="kw">if</span> (minx&gt;pt[i].x) minx=pt[i].x;
            <span class="kw">if</span> (miny&gt;pt[i].y) miny=pt[i].y;
        }
        pt[n<span class="dv">+1</span>]=pt[<span class="dv">1</span>];
        pt[n<span class="dv">+2</span>]=pt[<span class="dv">2</span>];
        pt[n<span class="dv">+3</span>]=pt[<span class="dv">3</span>];
        pt[n<span class="dv">+4</span>]=pt[<span class="dv">4</span>];
        <span class="co">//求每条线段的转向</span>
        <span class="kw">for</span> (i=<span class="dv">1</span>; i&lt;=n<span class="dv">+1</span>; i ++)
        {
            cross = det(pt[i],pt[i<span class="dv">+1</span>], pt[i<span class="dv">+1</span>], pt[i<span class="dv">+2</span>]);
            <span class="kw">if</span> (cross&lt;<span class="dv">0</span>)turn_right[i<span class="dv">+1</span>]=<span class="kw">true</span>;
            <span class="kw">else</span> turn_right[i<span class="dv">+1</span>]=<span class="kw">false</span>;
        }
        <span class="kw">for</span> (i=<span class="dv">2</span>; i&lt;= n<span class="dv">+1</span>; i++)
            <span class="kw">if</span> (turn_right[i] &amp;&amp; turn_right[i<span class="dv">+1</span>])
            {
                <span class="kw">if</span> (pt[i].x==pt[i<span class="dv">+1</span>].x)
                {
                    minn=pt[i].y;
                    maxn=pt[i<span class="dv">+1</span>].y;
                    Swap(minn, maxn);
                    <span class="kw">if</span> (minn&gt;miny) miny=minn;
                    <span class="kw">if</span> (maxn&lt;maxy) maxy=maxn;
                }
                <span class="kw">else</span>
                {
                    minn=pt[i].x;
                    maxn=pt[i<span class="dv">+1</span>].x;
                    Swap(minn, maxn);
                    <span class="kw">if</span> (minn&gt;minx) minx=minn;
                    <span class="kw">if</span> (maxn&lt;maxx) maxx=maxn;
                }
            }
        <span class="kw">if</span> (minx&lt;=maxx &amp;&amp; miny&lt;=maxy)
            printf(<span class="st">&quot;Floor #</span><span class="ch">%d\n</span><span class="st">Surveillance is possible.</span><span class="ch">\n\n</span><span class="st">&quot;</span>, ++countn);
        <span class="kw">else</span> printf(<span class="st">&quot;Floor #</span><span class="ch">%d\n</span><span class="st">Surveillance is impossible.</span><span class="ch">\n\n</span><span class="st">&quot;</span>, ++countn);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="模拟退火"><span class="header-section-number">6.20</span> 模拟退火</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>

<span class="ot">#define Lim 0.999999</span>
<span class="ot">#define EPS 1e-2</span>
<span class="ot">#define PI acos(-1.0)</span>

<span class="dt">double</span> Temp, maxx, minx, maxy, miny, lx, ly, dif;
<span class="dt">int</span> nt, ns, nc;

<span class="kw">struct</span> Target{
    <span class="dt">double</span> x, y;
}T[<span class="dv">105</span>];

<span class="kw">struct</span> Solution{
    <span class="dt">double</span> x, y;
    <span class="dt">double</span> f;
}S[<span class="dv">25</span>], P, A;

<span class="dt">double</span> Dis(<span class="dt">double</span> x1, <span class="dt">double</span> y1, <span class="dt">double</span> x2, <span class="dt">double</span> y2)
{
    <span class="kw">return</span> sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}

<span class="dt">void</span> Seed(<span class="dt">void</span>)
{
    <span class="dt">int</span> i, j;
    <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;ns;i++)
    {
        S[i].x=minx+((<span class="dt">double</span>)(rand()%<span class="dv">1000+1</span>)/<span class="fl">1000.0</span>)*lx;
        S[i].y=miny+((<span class="dt">double</span>)(rand()%<span class="dv">1000+1</span>)/<span class="fl">1000.0</span>)*ly;
        S[i].f=<span class="fl">0.0</span>;
        <span class="kw">for</span> (j=<span class="dv">0</span>;j&lt;nt;j++)
            S[i].f=S[i].f+Dis(S[i].x,S[i].y, T[j].x, T[j].y);
    }
}

<span class="dt">void</span> Trans(<span class="dt">void</span>)
{
    <span class="dt">int</span> i, j, k;
    <span class="dt">double</span> theta;
    <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;ns;i++)
    {
        P=S[i];
        <span class="kw">for</span> (j=<span class="dv">0</span>;j&lt;nc;j++)
        {
            theta=(((<span class="dt">double</span>)(rand()%<span class="dv">1000+1</span>))/<span class="fl">1000.0</span>)*<span class="fl">2.0</span>*PI;
            A.x=P.x+Temp*cos(theta);
            A.y=P.y+Temp*sin(theta);
            <span class="kw">if</span> (A.x&lt;minx||A.x&gt;maxx||A.y&lt;miny||A.y&gt;maxy)
                <span class="kw">continue</span>;
            A.f=<span class="fl">0.0</span>;
            <span class="kw">for</span> (k=<span class="dv">0</span>;k&lt;nt;k++)
                A.f=A.f+Dis(A.x,A.y,T[k].x,T[k].y);
            dif=A.f-S[i].f;
            <span class="kw">if</span> (dif&lt;<span class="fl">0.0</span>)S[i]=A;
            <span class="kw">else</span>
            {
                dif=exp(-dif/Temp);
                <span class="kw">if</span> (dif&gt;Lim) S[i]=A;
            }
        }
    }
}

<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="dt">int</span> i, k;
    <span class="kw">while</span> (scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;nt)==<span class="dv">1</span>&amp;&amp;nt)
    {
        maxx=maxy=<span class="dv">0</span>;
        minx=miny=(<span class="dv">1</span>&lt;&lt;<span class="dv">20</span>);
        <span class="kw">for</span> (i=<span class="dv">0</span>;i&lt;nt;i++)
        {
            scanf(<span class="st">&quot;</span><span class="ch">%lf</span><span class="st"> </span><span class="ch">%lf</span><span class="st">&quot;</span>,&amp;T[i].x,&amp;T[i].y);
            <span class="kw">if</span> (maxx&lt;T[i].x)maxx=T[i].x;
            <span class="kw">if</span> (minx&gt;T[i].x)minx=T[i].x;
            <span class="kw">if</span> (maxy&lt;T[i].y)maxy=T[i].y;
            <span class="kw">if</span> (miny&gt;T[i].y)miny=T[i].y;
        }
        lx=maxx-minx;
        ly=maxy-miny;
        Temp=sqrt(lx*lx+ly*ly)/<span class="fl">3.0</span>;
        ns=<span class="dv">5</span>, nc=<span class="dv">10</span>;
        Seed();
        <span class="kw">while</span> (Temp&gt;EPS)
        {
            Trans();
            Temp=Temp*<span class="fl">0.40</span>;
        }
        k=<span class="dv">0</span>;
        <span class="kw">for</span> (i=<span class="dv">1</span>;i&lt;ns;i++)
            <span class="kw">if</span> (S[k].f&gt;S[i].f)
                k=i;
        printf (<span class="st">&quot;</span><span class="ch">%.0lf\n</span><span class="st">&quot;</span>, S[k].f);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="六边形坐标系"><span class="header-section-number">6.21</span> 六边形坐标系</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//第一种六边形坐标系</span>
<span class="ot">#include&lt;stdio.h&gt;</span>
<span class="ot">#include&lt;math.h&gt;</span>
<span class="ot">#include&lt;string.h&gt;</span>
<span class="ot">#include&lt;stdlib.h&gt;</span>

<span class="dt">double</span> Dis(<span class="dt">double</span> x1, <span class="dt">double</span> y1, <span class="dt">double</span> x2, <span class="dt">double</span> y2)
{
    <span class="dt">double</span> dx=x1-x2;
    <span class="dt">double</span> dy=y1-y2;
    <span class="kw">return</span> sqrt(dx*dx+dy*dy);
}

<span class="dt">void</span> Get_KL(<span class="dt">double</span> L, <span class="dt">double</span> x, <span class="dt">double</span> y, <span class="dt">int</span> &amp;k, <span class="dt">int</span> &amp;l, <span class="dt">double</span> &amp;cd)
{
    k=floor((<span class="fl">2.0</span>*x)/(<span class="fl">3.0</span>*L));
    l=floor((<span class="fl">2.0</span>*y)/(sqrt(<span class="fl">3.0</span>)*L));
    <span class="dt">double</span> d1, d2, x1, y1, x2, y2;
    <span class="kw">if</span> ((k+l)&amp;<span class="dv">1</span>)
    {
        x1=k*L*<span class="fl">1.5</span>;
        y1=(l<span class="fl">+1.0</span>)*L*sqrt(<span class="fl">3.0</span>)*<span class="fl">0.5</span>;
        x2=(k<span class="fl">+1.0</span>)*L*<span class="fl">1.5</span>;
        y2=l*L*sqrt(<span class="fl">3.0</span>)*<span class="fl">0.5</span>;
        d1=Dis(x1,y1, x,y);
        d2=Dis(x2,y2, x,y);
        <span class="kw">if</span> (d1&gt;d2)
        {
            k++;
            cd=d2;
        }
        <span class="kw">else</span>
        {
            l++;
            cd=d1;
        }
    }
    <span class="kw">else</span>
    {
        x1=k*L*<span class="fl">1.5</span>;
        y1=l*L*sqrt(<span class="fl">3.0</span>)*<span class="fl">0.5</span>;
        x2=(k<span class="fl">+1.0</span>)*L*<span class="fl">1.5</span>;
        y2=(l<span class="fl">+1.0</span>)*L*sqrt(<span class="fl">3.0</span>)*<span class="fl">0.5</span>;
        d1=Dis(x1,y1, x,y);
        d2=Dis(x2,y2, x,y);
        <span class="kw">if</span> (d1&gt;d2)
        {
            k++,l++;
            cd=d2;
        }
        <span class="kw">else</span> cd=d1;
    }
}

<span class="dt">int</span> My_Abs(<span class="dt">int</span> x)
{
    <span class="kw">if</span> (x&lt;<span class="dv">0</span>) <span class="kw">return</span> -x;
    <span class="kw">return</span> x;
}

<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="dt">double</span> L, x1, y1, x2, y2, ans, cd1, cd2;
    <span class="dt">int</span> k1, l1, k2, l2;
    <span class="kw">while</span> (scanf(<span class="st">&quot;</span><span class="ch">%lf</span><span class="st"> </span><span class="ch">%lf</span><span class="st"> </span><span class="ch">%lf</span><span class="st"> </span><span class="ch">%lf</span><span class="st"> </span><span class="ch">%lf</span><span class="st">&quot;</span>,&amp;L,&amp;x1,&amp;y1,&amp;x2,&amp;y2)==<span class="dv">5</span>)
    {
        <span class="kw">if</span> (L==<span class="fl">0.0</span>&amp;&amp;x1==<span class="fl">0.0</span>&amp;&amp;y1==<span class="fl">0.0</span>&amp;&amp;x2==<span class="fl">0.0</span>&amp;&amp;y2==<span class="fl">0.0</span>) <span class="kw">break</span>;
        Get_KL(L, x1, y1, k1, l1, cd1);
        Get_KL(L, x2, y2, k2, l2, cd2);
        <span class="kw">if</span> (k1==k2&amp;&amp;l1==l2) printf(<span class="st">&quot;</span><span class="ch">%.3lf\n</span><span class="st">&quot;</span>, Dis(x1,y1, x2,y2));
        <span class="kw">else</span>
        {
            ans=cd1+cd2;
            <span class="kw">if</span> (My_Abs(k1-k2) &gt; My_Abs(l1-l2))
                ans=ans+sqrt(<span class="fl">3.0</span>)*L*My_Abs(k1-k2);
            <span class="kw">else</span>
                ans=ans+sqrt(<span class="fl">3.0</span>)*L*My_Abs(k1-k2)
                    +sqrt(<span class="fl">3.0</span>)*L*(<span class="dt">double</span>)(My_Abs(l1-l2)-My_Abs(k1-k2))/<span class="fl">2.0</span>
                    ;
            printf(<span class="st">&quot;</span><span class="ch">%.3lf\n</span><span class="st">&quot;</span>, ans);
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="co">//第二种六边形坐标系</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>

<span class="kw">struct</span> A{
    <span class="dt">int</span> x, y, num;
}a[<span class="dv">10001</span>];

<span class="dt">const</span> <span class="dt">int</span> dec[<span class="dv">6</span>][<span class="dv">2</span>] = {{<span class="dv">-1</span>,<span class="dv">1</span>},{<span class="dv">-1</span>,<span class="dv">0</span>},{<span class="dv">0</span>,<span class="dv">-1</span>},{<span class="dv">1</span>,<span class="dv">-1</span>},{<span class="dv">1</span>,<span class="dv">0</span>},{<span class="dv">0</span>,<span class="dv">1</span>}};

<span class="dt">bool</span> adj(<span class="dt">int</span> x1, <span class="dt">int</span> y1, <span class="dt">int</span> x2, <span class="dt">int</span> y2) {
    <span class="kw">if</span> (x1 == x2 &amp;&amp; abs(y1-y2) == <span class="dv">1</span>) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">if</span> (y1 == y2 &amp;&amp; abs(x1-x2) == <span class="dv">1</span>) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">if</span> (x1 == x2 + <span class="dv">1</span> &amp;&amp; y1 == y2 <span class="dv">-1</span>) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">if</span> (x1 == x2 - <span class="dv">1</span> &amp;&amp; y1 == y2 <span class="dv">+1</span>) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">bool</span> flag[<span class="dv">10001</span>];

<span class="dt">int</span> main ()
{
    <span class="dt">int</span> i, j, k, x, u, v, cut, minn, cnt[<span class="dv">6</span>];
    memset(cnt, <span class="dv">0</span>, <span class="kw">sizeof</span>(cnt));
    a[<span class="dv">1</span>].num = <span class="dv">1</span>, cnt[<span class="dv">1</span>] = <span class="dv">1</span>;
    a[<span class="dv">1</span>].x = a[<span class="dv">1</span>].y = <span class="dv">0</span>;
    <span class="kw">for</span> (i = <span class="dv">2</span>; i &lt; <span class="dv">10001</span>; i ++)
    {
        k = (<span class="dt">int</span>)((<span class="fl">3.0</span>+sqrt(<span class="fl">12.0</span>*i - <span class="fl">3.0</span>))/<span class="fl">6.0+0.0000001</span>);
        <span class="kw">if</span> (i == <span class="dv">3</span>*(k<span class="dv">-1</span>)*(k<span class="dv">-1</span>)<span class="dv">+3</span>*(k<span class="dv">-1</span>)<span class="dv">+1</span>) k --;
        j = i - (<span class="dv">3</span>*(k<span class="dv">-1</span>)*(k<span class="dv">-1</span>)<span class="dv">+3</span>*(k<span class="dv">-1</span>)<span class="dv">+1</span>);
        <span class="co">//当前的六边形是第 k 层的第 j 个六边形</span>
        <span class="kw">if</span> (j == <span class="dv">1</span>) a[i].x = a[i<span class="dv">-1</span>].x, a[i].y = a[i<span class="dv">-1</span>].y + <span class="dv">1</span>;
        <span class="kw">else</span>
        {
            x = (j<span class="dv">-1</span>) / k;
            a[i].x = a[i<span class="dv">-1</span>].x + dec[x][<span class="dv">0</span>];
            a[i].y = a[i<span class="dv">-1</span>].y + dec[x][<span class="dv">1</span>];
        }
        memset(flag, <span class="kw">false</span>, <span class="kw">sizeof</span>(flag));
        x = <span class="dv">12</span>*k<span class="dv">-6</span>, cut = <span class="dv">0</span>;
        <span class="kw">for</span> (u = i<span class="dv">-1</span>, v = <span class="dv">0</span>; u&gt;=<span class="dv">1</span>&amp;&amp;v&lt;x; u --, v ++)
            <span class="kw">if</span> (adj(a[u].x, a[u].y, a[i].x, a[i].y))
            {
                cut ++;
                flag[a[u].num] = <span class="kw">true</span>;
                <span class="kw">if</span> (cut == <span class="dv">3</span>) <span class="kw">break</span>;
            }
        minn = <span class="dv">10001</span>;
        <span class="kw">for</span> (u = <span class="dv">1</span>; u &lt; <span class="dv">6</span>; u ++)
            <span class="kw">if</span> ((!flag[u])&amp;&amp;minn &gt; cnt[u])
            {
                minn = cnt[u];
                x = u;
            }
        a[i].num = x;
        cnt[x] ++;
    }
    scanf (<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;x);
    <span class="kw">while</span> (x --)
    {
        scanf (<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;i);
        printf (<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, a[i].num);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="用一个给定半径的圆覆盖最多的点"><span class="header-section-number">6.22</span> 用一个给定半径的圆覆盖最多的点</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//同半径圆的圆弧表示</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>

<span class="ot">#define PI acos(-1.0)</span>

<span class="kw">struct</span> Point{
    <span class="dt">double</span> x, y;
}pt[<span class="dv">2005</span>];

<span class="dt">double</span> dis[<span class="dv">2005</span>][<span class="dv">2005</span>];

<span class="kw">struct</span> List{
    <span class="dt">double</span> a;
    <span class="dt">bool</span> flag;
    <span class="dt">int</span> id;
}list[<span class="dv">8005</span>];

<span class="dt">int</span> cnt;

<span class="dt">double</span> Dis(<span class="dt">int</span> i, <span class="dt">int</span> j)
{
    <span class="dt">double</span> dx=pt[i].x-pt[j].x;
    <span class="dt">double</span> dy=pt[i].y-pt[j].y;
    <span class="kw">return</span> sqrt(dx*dx+dy*dy);
}

<span class="dt">int</span> Cmp(<span class="dt">const</span> <span class="dt">void</span>*p1, <span class="dt">const</span> <span class="dt">void</span>*p2)
{
    <span class="kw">struct</span> List*a1=(<span class="kw">struct</span> List*)p1;
    <span class="kw">struct</span> List*a2=(<span class="kw">struct</span> List*)p2;
    <span class="kw">if</span> (a1-&gt;a&lt;a2-&gt;a)<span class="kw">return</span> <span class="dv">-1</span>;
    <span class="kw">else</span> <span class="kw">if</span> (a1-&gt;a==a2-&gt;a) <span class="kw">return</span> a1-&gt;id-a2-&gt;id;
    <span class="kw">else</span> <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="dt">int</span> main (<span class="dt">void</span>)
{
    <span class="dt">int</span> n, i, j, ans, num;
    <span class="dt">double</span> r, theta, delta, a1, a2;
    <span class="kw">while</span> (scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%lf</span><span class="st">&quot;</span>,&amp;n,&amp;r)==<span class="dv">2</span>)
    {
        <span class="kw">if</span> (n==<span class="dv">0</span>&amp;&amp;r==<span class="fl">0.0</span>) <span class="kw">break</span>;
        r=r<span class="fl">+0.001</span>;
        r=r*<span class="fl">2.0</span>;
        <span class="kw">for</span> (i=<span class="dv">1</span>;i&lt;=n;i++)
            scanf(<span class="st">&quot;</span><span class="ch">%lf</span><span class="st"> </span><span class="ch">%lf</span><span class="st">&quot;</span>, &amp;pt[i].x, &amp;pt[i].y);
        <span class="kw">for</span> (i=<span class="dv">1</span>;i&lt;n;i++)
            <span class="kw">for</span> (j=i<span class="dv">+1</span>;j&lt;=n;j++)
            {
                dis[i][j]=Dis(i, j);
                dis[j][i]=dis[i][j];
            }
        ans=<span class="dv">0</span>;
        <span class="kw">for</span> (i=<span class="dv">1</span>;i&lt;=n;i++)
        {
            cnt=<span class="dv">0</span>;
            <span class="kw">for</span> (j=<span class="dv">1</span>;j&lt;=n;j++)
                <span class="kw">if</span> ((j!=i)&amp;&amp;(dis[i][j]&lt;=r))
                {
                    theta=atan2(pt[j].y-pt[i].y, pt[j].x-pt[i].x);
                    <span class="kw">if</span> (theta&lt;<span class="fl">0.0</span>) theta=theta<span class="fl">+2.0</span>*PI;
                    delta=acos(dis[i][j]/r);
                    a1=theta-delta;
                    a2=theta+delta;
                    list[++cnt].a=a1;
                    list[cnt].flag=<span class="kw">true</span>;
                    list[cnt].id=cnt;
                    list[++cnt].a=a2;
                    list[cnt].flag=<span class="kw">false</span>;
                    list[cnt].id=cnt;
                }
            qsort(list<span class="dv">+1</span>,cnt,<span class="kw">sizeof</span>(<span class="kw">struct</span> List),Cmp);
            num=<span class="dv">0</span>;
            <span class="kw">for</span> (j=<span class="dv">1</span>;j&lt;=cnt;j++)
                <span class="kw">if</span> (list[j].flag)
                {
                    num++;
                    <span class="kw">if</span> (num&gt;ans) ans=num;
                }
                <span class="kw">else</span> num--;
        }
        printf(<span class="st">&quot;It is possible to cover </span><span class="ch">%d</span><span class="st"> points.</span><span class="ch">\n</span><span class="st">&quot;</span>, ans<span class="dv">+1</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="最近圆对"><span class="header-section-number">6.23</span> 最近圆对</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;stdlib.h&gt;</span>
<span class="ot">#include&lt;string.h&gt;</span>
<span class="ot">#include&lt;set&gt;</span>
<span class="ot">#include&lt;math.h&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;
set &lt;<span class="dt">int</span>&gt;tree;
set &lt;<span class="dt">int</span>&gt;::iterator iter;

<span class="kw">struct</span> Point{
    <span class="dt">double</span> x;
    <span class="dt">int</span> id, flag;
}p1[<span class="dv">100001</span>], p2[<span class="dv">100001</span>];

<span class="dt">int</span> tot1, tot2;

<span class="kw">struct</span> Q{
    <span class="dt">double</span> x,y, r;
}q[<span class="dv">50001</span>];

<span class="dt">int</span> cmp(<span class="dt">const</span> <span class="dt">void</span>*p1, <span class="dt">const</span> <span class="dt">void</span>*p2)
{
    <span class="kw">struct</span> Point*a1=(<span class="kw">struct</span> Point*)p1;
    <span class="kw">struct</span> Point*a2=(<span class="kw">struct</span> Point*)p2;
    <span class="kw">if</span> (a1-&gt;x&lt;a2-&gt;x) <span class="kw">return</span> <span class="dv">-1</span>;
    <span class="kw">else</span> <span class="kw">if</span> (a1-&gt;x==a2-&gt;x) <span class="kw">return</span> a2-&gt;flag-a1-&gt;flag;
    <span class="kw">else</span> <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="dt">int</span> cmp1(<span class="dt">const</span> <span class="dt">void</span>*p1, <span class="dt">const</span> <span class="dt">void</span>*p2)
{
    <span class="kw">struct</span> Q*a1=(<span class="kw">struct</span> Q*)p1;
    <span class="kw">struct</span> Q*a2=(<span class="kw">struct</span> Q*)p2;
    <span class="kw">if</span> (a1-&gt;y&lt;a2-&gt;y)<span class="kw">return</span> <span class="dv">-1</span>;
    <span class="kw">else</span> <span class="kw">if</span> (a1-&gt;y==a2-&gt;y)<span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">else</span> <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="dt">double</span> dis(<span class="dt">double</span> x1, <span class="dt">double</span> y1, <span class="dt">double</span> x2, <span class="dt">double</span> y2)
{
    <span class="kw">return</span> sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}

<span class="dt">bool</span> judge(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">double</span> d)
{
    <span class="kw">if</span> (dis(q[i].x, q[i].y, q[j].x,
            q[j].y)&lt;=q[i].r+q[j].r<span class="fl">+2.0</span>*d)
        <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">bool</span> insert(<span class="dt">int</span> v,<span class="dt">double</span> d)
{
    iter = tree.insert(v).first;
    <span class="kw">if</span> (iter != tree.begin())
    {
        <span class="kw">if</span> (judge(v, *--iter,d))
        {
            <span class="kw">return</span> <span class="kw">true</span>;
        }
        ++iter;
    }
    <span class="kw">if</span> (++iter != tree.end())
    {
        <span class="kw">if</span> (judge(v, *iter,d))
        {
            <span class="kw">return</span> <span class="kw">true</span>;
        }
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">bool</span> remove(<span class="dt">int</span> v,<span class="dt">double</span> d)
{
    iter = tree.find(v);
    <span class="kw">if</span> (iter != tree.begin() &amp;&amp; iter != --tree.end())
    {
        <span class="dt">int</span> a = *--iter;
        ++iter;
        <span class="dt">int</span> b = *++iter;
        <span class="kw">if</span> (judge(a, b,d))
        {
            <span class="kw">return</span> <span class="kw">true</span>;
        }
    }
    tree.erase(v);
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">bool</span> check(<span class="dt">double</span> d)
{
    <span class="dt">int</span> i=<span class="dv">1</span>, j=<span class="dv">1</span>;
    <span class="kw">while</span> (i&lt;=tot1&amp;&amp;j&lt;=tot2)
    {
        <span class="kw">if</span> (p1[i].x-d&lt;=p2[j].x+d)
        {
            <span class="kw">if</span> (insert(p1[i++].id, d))
                <span class="kw">return</span> <span class="kw">true</span>;
        }
        <span class="kw">else</span>
        {
            <span class="kw">if</span> (remove(p2[j++].id, d))
                <span class="kw">return</span> <span class="kw">true</span>;
        }
    }
    <span class="kw">while</span> (i&lt;=tot1)
    {
        <span class="kw">if</span> (insert(p1[i++].id, d))
            <span class="kw">return</span> <span class="kw">true</span>;
    }
    <span class="kw">while</span> (j&lt;=tot2)
    {
        <span class="kw">if</span> (remove(p2[j++].id, d))
            <span class="kw">return</span> <span class="kw">true</span>;
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">int</span> main ()
{
    <span class="dt">int</span> cases, n, i;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;cases);
    <span class="kw">while</span> (cases--)
    {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;n);
        tot1=tot2=<span class="dv">0</span>;
        <span class="kw">for</span> (i=<span class="dv">1</span>;i&lt;=n;i++)
            scanf(<span class="st">&quot;</span><span class="ch">%lf</span><span class="st"> </span><span class="ch">%lf</span><span class="st"> </span><span class="ch">%lf</span><span class="st">&quot;</span>,&amp;q[i].x,&amp;q[i].y, &amp;q[i].r);
        qsort(q<span class="dv">+1</span>,n,<span class="kw">sizeof</span>(<span class="kw">struct</span> Q),cmp1);
        <span class="kw">for</span> (i=<span class="dv">1</span>;i&lt;=n;i++)
        {
            tot1++;
            p1[tot1].x=q[i].x-q[i].r;
            p1[tot1].id=i;
            p1[tot1].flag=<span class="dv">1</span>;
            tot2++;
            p2[tot2].x=q[i].x+q[i].r;
            p2[tot2].id=i;
            p2[tot2].flag=<span class="dv">-1</span>;
        }
        qsort(p1<span class="dv">+1</span>,tot1,<span class="kw">sizeof</span>(<span class="kw">struct</span> Point),cmp);
        qsort(p2<span class="dv">+1</span>,tot2,<span class="kw">sizeof</span>(<span class="kw">struct</span> Point),cmp);
        <span class="dt">double</span> head=<span class="fl">0.0</span>, tail=dis(q[<span class="dv">1</span>].x,q[<span class="dv">1</span>].y,q[<span class="dv">2</span>].x,q[<span class="dv">2</span>].y)<span class="fl">+1.0</span>,
        mid;
        <span class="kw">while</span> (tail-head&gt;<span class="fl">1e-8</span>)
        {
            tree.clear();
            mid=(head+tail)/<span class="fl">2.0</span>;
            <span class="kw">if</span> (check(mid))
            {
                tail=mid;
            }
            <span class="kw">else</span> head=mid;
        }
        printf (<span class="st">&quot;</span><span class="ch">%.6lf\n</span><span class="st">&quot;</span>,<span class="fl">2.0</span>*head);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="求两个圆的面积交"><span class="header-section-number">6.24</span> 求两个圆的面积交</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> area_of_overlap(point c1, <span class="dt">double</span> r1, point c2, <span class="dt">double</span> r2)
{
    <span class="dt">double</span> a = distance(c1, c2), b = r1, c = r2;
    <span class="dt">double</span> cta1 = acos((a * a + b * b - c * c) / <span class="dv">2</span> / (a * b));
    <span class="dt">double</span> cta2 = acos((a * a + c * c - b * b) / <span class="dv">2</span> / (a * c));
    <span class="dt">double</span> s1 = r1*r1*cta1 - r1*r1*sin(cta1)*(a * a + b * b - c * c) / <span class="dv">2</span> / (a * b);
    <span class="dt">double</span> s2 = r2*r2*cta2 - r2*r2*sin(cta2)*(a * a + c * c - b * b) / <span class="dv">2</span> / (a * c);
    <span class="kw">return</span> s1 + s2;
}</code></pre></div>
<h1 id="dp"><span class="header-section-number">7</span> DP</h1>
<h2 id="数位dp"><span class="header-section-number">7.1</span> 数位DP</h2>
<h3 id="常规解法"><span class="header-section-number">7.1.1</span> 常规解法</h3>
<p>按位枚举状态，适用于统计连续范围内具有某一和位相关性质的数的数量等。</p>
<h3 id="示例问题"><span class="header-section-number">7.1.2</span> 示例问题</h3>
<h4 id="b-number"><span class="header-section-number">7.1.2.1</span> B-number</h4>
<p>含有数字13和能够被13整除的数的个数。</p>
<h4 id="循环"><span class="header-section-number">7.1.2.2</span> 循环</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">long</span> <span class="dt">long</span> dp[<span class="dv">15</span>][<span class="dv">13</span>][<span class="dv">2</span>][<span class="dv">2</span>][<span class="dv">2</span>], mod[<span class="dv">15</span>];

<span class="dt">int</span> main() {
    string n;
    <span class="dt">long</span> <span class="dt">long</span> num = <span class="dv">1</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= <span class="dv">15</span>; i++) {
        mod[i] = num % <span class="dv">13</span>;
        num *= <span class="dv">10</span>;
    }
    <span class="kw">while</span> (cin &gt;&gt; n) {
        <span class="dt">int</span> len = n.size();
        memset(dp, <span class="dv">0</span>, <span class="kw">sizeof</span>(dp));
        dp[<span class="dv">0</span>][<span class="dv">0</span>][<span class="dv">1</span>][<span class="dv">0</span>][<span class="dv">0</span>] = <span class="dv">1</span>;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len; i++)
            <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">13</span>; j++)
                <span class="kw">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt;= <span class="dv">1</span>; k++) {
                    <span class="dt">int</span> r = (k == <span class="dv">1</span> ? n[i] - <span class="st">&#39;0&#39;</span> : <span class="dv">9</span>);
                    <span class="kw">for</span> (<span class="dt">int</span> x = <span class="dv">0</span>; x &lt;= r; x++)
                        <span class="kw">for</span> (<span class="dt">int</span> l = <span class="dv">0</span>; l &lt;= <span class="dv">1</span>; l++)
                            <span class="kw">for</span> (<span class="dt">int</span> m = <span class="dv">0</span>; m &lt;= <span class="dv">1</span>; m++) {
                                <span class="dt">int</span> mo = (j + mod[len - i - <span class="dv">1</span>] * x) % <span class="dv">13</span>;
                                <span class="kw">if</span> (x == <span class="dv">3</span> &amp;&amp; l == <span class="dv">0</span> &amp;&amp; m == <span class="dv">1</span>) {
                                    dp[i + <span class="dv">1</span>][mo][(k == <span class="dv">1</span> &amp;&amp; x == r) ? \
                                    <span class="dv">1</span> : <span class="dv">0</span>][<span class="dv">1</span>][<span class="dv">0</span>] += dp[i][j][k][<span class="dv">0</span>][<span class="dv">1</span>];
                                    <span class="kw">continue</span>;
                                }
                                dp[i + <span class="dv">1</span>][mo]\
                                [(k == <span class="dv">1</span> &amp;&amp; x == r) ? <span class="dv">1</span> : <span class="dv">0</span>]\
                                [l][x == <span class="dv">1</span> ? <span class="dv">1</span> : <span class="dv">0</span>] +=
                                        dp[i][j][k][l][m];
                            }
                }

        cout &lt;&lt; dp[len][<span class="dv">0</span>][<span class="dv">1</span>][<span class="dv">1</span>][<span class="dv">0</span>] + dp[len][<span class="dv">0</span>][<span class="dv">1</span>][<span class="dv">1</span>][<span class="dv">1</span>] \
        + dp[len][<span class="dv">0</span>][<span class="dv">0</span>][<span class="dv">1</span>][<span class="dv">0</span>] + dp[len][<span class="dv">0</span>][<span class="dv">0</span>][<span class="dv">1</span>][<span class="dv">1</span>] &lt;&lt; endl;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h4 id="记忆化搜索"><span class="header-section-number">7.1.2.3</span> 记忆化搜索</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/*</span>
<span class="co"> * HDU 3652 B-number</span>
<span class="co"> * 含有数字13和能够被13整除的数的个数</span>
<span class="co"> * dp[i][j][k][z]：i:处理的数位，j:该数对13取模以后的值，k:是否已经包含13,z结尾的数</span>
<span class="co"> */</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="dt">int</span> dp[<span class="dv">12</span>][<span class="dv">15</span>][<span class="dv">2</span>][<span class="dv">10</span>];
<span class="dt">int</span> bit[<span class="dv">12</span>];
<span class="dt">int</span> dfs(<span class="dt">int</span> pos,<span class="dt">int</span> num,<span class="dt">bool</span> t,<span class="dt">int</span> e,<span class="dt">bool</span> flag)
{
    <span class="kw">if</span>(pos==<span class="dv">-1</span>)<span class="kw">return</span> t&amp;&amp;(num==<span class="dv">0</span>);
    <span class="kw">if</span>(!flag &amp;&amp; dp[pos][num][t][e]!=<span class="dv">-1</span>)
        <span class="kw">return</span> dp[pos][num][t][e];
    <span class="dt">int</span> end=flag?bit[pos]:<span class="dv">9</span>;
    <span class="dt">int</span> ans=<span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;=end;i++)
        ans+=dfs(pos<span class="dv">-1</span>,(num*<span class="dv">10</span>+i)%<span class="dv">13</span>,t||(e==<span class="dv">1</span>&amp;&amp;i==<span class="dv">3</span>),i,flag&amp;&amp;(i==end));
    <span class="kw">if</span>(!flag)dp[pos][num][t][e]=ans;
    <span class="kw">return</span> ans;
}
<span class="dt">int</span> calc(<span class="dt">int</span> n)
{
    <span class="dt">int</span> pos=<span class="dv">0</span>;
    <span class="kw">while</span>(n)
    {
        bit[pos++]=n%<span class="dv">10</span>;
        n/=<span class="dv">10</span>;
    }
    <span class="kw">return</span> dfs(pos<span class="dv">-1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>);
}
<span class="dt">int</span> main()
{
    <span class="co">//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span>
    <span class="co">//freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span>
    <span class="dt">int</span> n;
    memset(dp,<span class="dv">-1</span>,<span class="kw">sizeof</span>(dp));
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;n)==<span class="dv">1</span>)
    {
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>,calc(n));
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="斜率优化"><span class="header-section-number">7.2</span> 斜率优化</h2>
<h3 id="问题描述-2"><span class="header-section-number">7.2.1</span> 问题描述</h3>
<p>将方程<span class="math inline">\(dp[i] = \min or \max \left ( f_1(j)*g(i)+f_2(j) \right )+c\)</span>中形如若干条直线的极值的部分用单调栈维护。从而将复杂度从<span class="math inline">\(O(n^2)\)</span>降至<span class="math inline">\(O(n)\)</span>。</p>
<h3 id="代码-13"><span class="header-section-number">7.2.2</span> 代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;

<span class="dt">const</span> <span class="dt">int</span> MAXN = <span class="dv">500005</span>;

ll dp[MAXN];
ll sum[MAXN];
ll que[MAXN];
<span class="dt">int</span> l, r;
<span class="dt">int</span> n, m;

<span class="co">/*----------------辅助函数----------------*/</span>

<span class="co">// 获取直线交点横坐标通常用 x = (c2 - c1) / (a2 - a1) (c为截距，a为自变量的系数)</span>
<span class="kw">inline</span> ll getDown(<span class="dt">int</span> i, <span class="dt">int</span> j) { <span class="co">// 获取交点横坐标分母部分</span>
    <span class="kw">return</span> <span class="dv">-2</span> * (sum[i] - sum[j]);
}

<span class="kw">inline</span> ll getUp(<span class="dt">int</span> i, <span class="dt">int</span> j) { <span class="co">// 获取交点横坐标分子部分</span>
    <span class="kw">return</span> sum[i] * sum[i] + dp[i] - sum[j] * sum[j] - dp[j];
}

<span class="kw">inline</span> ll getNum(<span class="dt">int</span> i, <span class="dt">int</span> j) { <span class="co">// 获取DP值（直接求方程）</span>
    <span class="kw">if</span> (i &lt; j) swap(i, j);
    ll tmp = sum[i] - sum[j];
    <span class="kw">return</span> tmp * tmp + m + dp[j];
}
<span class="co">/*----------------辅助函数----------------*/</span>

<span class="dt">int</span> main() {
    <span class="kw">while</span> (~scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m)) {
        <span class="co">/*----------------输入----------------*/</span>
        <span class="dt">int</span> tmp;
        sum[<span class="dv">0</span>] = <span class="dv">0</span>;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;tmp);
            sum[i] = sum[i - <span class="dv">1</span>] + tmp;
        }
        <span class="co">/*----------------输入----------------*/</span>
        
        <span class="co">// 初始化队列、DP</span>
        l = r = <span class="dv">0</span>;
        que[r++] = <span class="dv">0</span>;
        dp[<span class="dv">0</span>] = <span class="dv">0</span>;

        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {
            <span class="co">// 去除队首无法得到最优解的元素（即交点在i的左侧）</span>
            <span class="kw">while</span> (r - l &gt; <span class="dv">1</span> &amp;&amp; getNum(i, que[l]) &gt;= getNum(i, que[l + <span class="dv">1</span>])) {
                l++;
            }
            <span class="co">// 状态转移</span>
            dp[i] = getNum(i, que[l]);

            <span class="co">/*----------------单调栈----------------*/</span>
            <span class="kw">while</span> (r - l &gt; <span class="dv">1</span> &amp;&amp; 
                    getUp(i, que[r - <span class="dv">1</span>]) * getDown(que[r - <span class="dv">1</span>], que[r - <span class="dv">2</span>]) &gt;= 
                    getUp(que[r - <span class="dv">1</span>], que[r - <span class="dv">2</span>]) * getDown(i, que[r - <span class="dv">1</span>])) {
                r--;
            }
            que[r++] = i;
            <span class="co">/*----------------单调栈----------------*/</span>
        }
        printf(<span class="st">&quot;</span><span class="ch">%lld\n</span><span class="st">&quot;</span>, dp[n]);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="四边形不等式优化"><span class="header-section-number">7.3</span> 四边形不等式优化</h2>
<h3 id="原理"><span class="header-section-number">7.3.1</span> 原理</h3>
<p>利用单调性优化枚举次数，降低一维复杂度。</p>
<p>基本形式：</p>
<p><span class="math display">\[
dp(i, j) = \min (dp(i,k)+dp(k+1, j)) + w(i, j)
\]</span></p>
<p><span class="math display">\[
dp(i, j) = \min (dp(i,k)+w(i,k)+dp(k+1, j)+w(k+1,j))
\]</span></p>
<p><span class="math display">\[
dp(i, j) = \min(dp(i,k) + w(k+1, j))
\]</span></p>
<p>只要证明<span class="math inline">\(w(i, j+1) + w(i+1, j) \leqslant w(i, j) + w(i+1, j+ 1)\)</span>且<span class="math inline">\(w(i,j) \leqslant w(i&#39;,j&#39;) \ i&#39; \leqslant i \leqslant j \leqslant j&#39;\)</span>即可使用四边形不等式优化：<br />
上述基本形式中<span class="math inline">\(dp(i, j)\)</span>取最小值时的<span class="math inline">\(k(i,j)\)</span>满足性质<span class="math inline">\(k(i,j-1) \leqslant k(i,j) \leqslant k(i, j+1)\)</span>。根据此性质枚举<span class="math inline">\(k\)</span>能够降低一维的复杂度。</p>
<p>在实际应用场景中，可以将矩阵<span class="math inline">\(k(i,j)\)</span>打印出来，观察其是否具有单调性。</p>
<h3 id="代码-14"><span class="header-section-number">7.3.2</span> 代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 初始化</span>
dp[<span class="dv">1</span>][<span class="dv">0</span>] = <span class="dv">0</span>;
<span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>; i&lt;=n; i++){
    dp[<span class="dv">1</span>][i] = cost(<span class="dv">1</span>, i);
}

<span class="co">// dp</span>
<span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>; i&lt;=m<span class="dv">+1</span>; i++){
    K[i][n<span class="dv">+1</span>] = n;
    <span class="kw">for</span>(<span class="dt">int</span> j=n; j&gt;=i; j--){
        dp[i][j] = <span class="fl">1e9</span>;

        <span class="co">// 寻找最优决策点，并记录</span>
        <span class="kw">for</span>(<span class="dt">int</span> k = K[i<span class="dv">-1</span>][j]; k&lt;= K[i][j<span class="dv">+1</span>]; k++){
            <span class="kw">if</span>(dp[i<span class="dv">-1</span>][k]+cost(k<span class="dv">+1</span>, j) &lt;= dp[i][j]){
                dp[i][j] = dp[i<span class="dv">-1</span>][k]+cost(k<span class="dv">+1</span>, j);
                K[i][j] = k;
            }
        }
    }
}

printf(<span class="st">&quot;</span><span class="ch">%lld\n</span><span class="st">&quot;</span>, dp[m<span class="dv">+1</span>][n]);</code></pre></div>
<h2 id="插头dp"><span class="header-section-number">7.4</span> 插头DP</h2>
<h3 id="示例代码"><span class="header-section-number">7.4.1</span> 示例代码</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="dt">long</span> <span class="dt">long</span> work()
{
    memset(dp,<span class="dv">0</span>,<span class="kw">sizeof</span>(dp));
    dp[<span class="dv">0</span>][<span class="dv">0</span>][<span class="dv">0</span>]=<span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++)
    {
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;m;j++)
        {
            <span class="kw">if</span>(mp[i][j])
            {
                <span class="kw">for</span>(<span class="dt">int</span> k=<span class="dv">0</span>;k&lt;=mask;k++)
                {
                    <span class="kw">if</span>(dp[i][j][k]==<span class="dv">0</span>)<span class="kw">continue</span>;
                    <span class="dt">int</span> tmp=k&amp;(<span class="dv">3</span>&lt;&lt;j);
                    <span class="kw">if</span>(<span class="dv">0</span>&lt;tmp&amp;&amp;tmp&lt;(<span class="dv">3</span>&lt;&lt;j))
                        dp[i][j<span class="dv">+1</span>][k]+=dp[i][j][k];
                    dp[i][j<span class="dv">+1</span>][k^(<span class="dv">3</span>&lt;&lt;j)]+=dp[i][j][k];
                }
            }
            <span class="kw">else</span>
            {
                <span class="kw">for</span>(<span class="dt">int</span> k=<span class="dv">0</span>;k&lt;=mask;k++)
                {
                    <span class="kw">if</span>(dp[i][j][k]==<span class="dv">0</span>)<span class="kw">continue</span>;
                    <span class="kw">if</span>(k&amp;(<span class="dv">3</span>&lt;&lt;j))<span class="kw">continue</span>;
                    dp[i][j<span class="dv">+1</span>][k]+=dp[i][j][k];
                }
            }
        }
        <span class="kw">for</span>(<span class="dt">int</span> k=mask&gt;&gt;<span class="dv">1</span>;k&gt;=<span class="dv">0</span>;k--)dp[i<span class="dv">+1</span>][<span class="dv">0</span>][k&lt;&lt;<span class="dv">1</span>]=dp[i][m][k];<span class="co">//处理换行</span>
    }
    <span class="kw">return</span> dp[n][<span class="dv">0</span>][<span class="dv">0</span>];
}</code></pre></div>
<h1 id="一些套路题"><span class="header-section-number">8</span> 一些套路题</h1>
<h2 id="区间第k小"><span class="header-section-number">8.1</span> 区间第k小</h2>
<h3 id="静态不修改可持久化线段树树上二分"><span class="header-section-number">8.1.1</span> 静态不修改(可持久化线段树+树上二分)</h3>
<h4 id="题目"><span class="header-section-number">8.1.1.1</span> 题目</h4>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2665">HDU 2665 Kth number</a><br />
数组下标从1开始,k从1开始<br />
复杂度<span class="math inline">\(\Theta \left ( nlog \left ( n \right ) \right )\)</span></p>
<h4 id="代码-15"><span class="header-section-number">8.1.1.2</span> 代码</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MAXN 111111</span><span class="co">//数组大小</span>
<span class="ot">#define MAXM 6666666</span><span class="co">//MAXN*log(MAXN)</span>

<span class="kw">struct</span> Tree{
    <span class="dt">int</span> num;
    <span class="dt">int</span> lson;
    <span class="dt">int</span> rson;
}tree[MAXM];<span class="co">//线段树</span>
<span class="dt">int</span> top;

<span class="dt">void</span> treeInit()
{
    tree[<span class="dv">0</span>].num=tree[<span class="dv">0</span>].lson=tree[<span class="dv">0</span>].rson=<span class="dv">0</span>;<span class="co">//用0节点表示NULL,便于处理</span>
    top=<span class="dv">1</span>;
}

<span class="dt">int</span> treeAdd(<span class="dt">int</span> ori,<span class="dt">int</span> left,<span class="dt">int</span> right,<span class="dt">int</span> x,<span class="dt">int</span> a)
{<span class="co">//在ori[left,right]树上x位置加a,并返回新的根</span>
    <span class="dt">int</span> nown=top++;
    tree[nown]=tree[ori];
    tree[nown].num+=a;
    <span class="kw">if</span>(left&lt;right)
    {
        <span class="dt">int</span> mid=(left+right)&gt;&gt;<span class="dv">1</span>;
        <span class="kw">if</span>(x&lt;=mid)tree[nown].lson=treeAdd(tree[nown].lson,left,mid,x,a);
        <span class="kw">else</span> tree[nown].rson=treeAdd(tree[nown].rson,mid<span class="dv">+1</span>,right,x,a);
    }
    <span class="kw">return</span> nown;
}

<span class="dt">int</span> treeFind(<span class="dt">int</span> nown,<span class="dt">int</span> left,<span class="dt">int</span> right,<span class="dt">int</span> l,<span class="dt">int</span> r)<span class="co">//查询区间[l,r]</span>
{
    <span class="kw">if</span>(nown==<span class="dv">0</span>)<span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">if</span>(l&lt;=left&amp;&amp;right&lt;=r)<span class="kw">return</span> tree[nown].num;
    <span class="dt">int</span> mid=(left+right)&gt;&gt;<span class="dv">1</span>;
    <span class="dt">int</span> ans=<span class="dv">0</span>;
    <span class="kw">if</span>(l&lt;=mid)ans+=treeFind(tree[nown].lson,left,mid,l,r);
    <span class="kw">if</span>(r&gt;mid)ans+=treeFind(tree[nown].rson,mid<span class="dv">+1</span>,right,l,r);
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> root[MAXN];<span class="co">//第i棵线段树的根,下标从1开始</span>
<span class="dt">int</span> hehe[MAXN],nn;

<span class="kw">inline</span> <span class="dt">int</span> khash(<span class="dt">int</span> x)
{
    <span class="kw">return</span> lower_bound(hehe,hehe+nn,x)-hehe;
}

<span class="dt">void</span> treeBuild(<span class="dt">int</span> arr[],<span class="dt">int</span> n)
{
    treeInit();
    root[<span class="dv">0</span>]=<span class="dv">0</span>;
    nn=<span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)
        hehe[nn++]=arr[i];
    sort(hehe,hehe+nn);
    nn=unique(hehe,hehe+n)-hehe;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)
        root[i]=treeAdd(root[i<span class="dv">-1</span>],<span class="dv">0</span>,nn,khash(arr[i]),<span class="dv">1</span>);
}

<span class="dt">int</span> findKth(<span class="dt">int</span> lr,<span class="dt">int</span> rr,<span class="dt">int</span> left,<span class="dt">int</span> right,<span class="dt">int</span> k)
{<span class="co">//左边树为lr,右边树为rr,区间[left,right]中的第k大,k从1开始</span>
    <span class="kw">if</span>(left==right)<span class="kw">return</span> left;
    <span class="dt">int</span> mid=(left+right)&gt;&gt;<span class="dv">1</span>;
    <span class="dt">int</span> tmp=tree[tree[rr].lson].num-tree[tree[lr].lson].num;
    <span class="kw">if</span>(tmp&gt;=k)<span class="kw">return</span> findKth(tree[lr].lson,tree[rr].lson,left,mid,k);
    <span class="kw">return</span> findKth(tree[lr].rson,tree[rr].rson,mid<span class="dv">+1</span>,right,k-tmp);
}

<span class="dt">int</span> n,m;
<span class="dt">int</span> kkke[MAXN];

<span class="dt">int</span> main()
{
    <span class="dt">int</span> t,l,r,k;
    kread(t);
    <span class="kw">while</span>(t--)
    {
        kread(n,m);
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)
            kread(kkke[i]);
        treeBuild(kkke,n);
        <span class="kw">while</span>(m--)
        {
            kread(l,r,k);
            printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>,hehe[findKth(root[l<span class="dv">-1</span>],root[r],<span class="dv">0</span>,nn,k)]);
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h3 id="动态可修改树状数组套线段树"><span class="header-section-number">8.1.2</span> 动态可修改(树状数组套线段树)</h3>
<h4 id="题目-1"><span class="header-section-number">8.1.2.1</span> 题目</h4>
<p><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1112">ZOJ 2112 Dynamic Rankings</a><br />
数组长度n=50000,询问次数m=10000<br />
此题空间卡得很死,如果直接全部插入空间复杂度为<span class="math inline">\(\Theta \left ( \left ( m+n \right ) log^{2}\left ( n \right ) \right )\)</span><br />
所以最开始建树使用线段树合并<span class="math inline">\(\Theta \left ( nlog\left ( n \right ) \right )\)</span>,然后修改时插入<span class="math inline">\(\Theta \left ( mlog^{2}\left ( n \right ) \right )\)</span><br />
查询时间复杂度<span class="math inline">\(\Theta \left ( nlog^{3}\left ( n \right ) \right )\)</span>,若树上二分可少一个<span class="math inline">\(log\left ( n \right )\)</span></p>
<h4 id="代码省略头文件和读入优化"><span class="header-section-number">8.1.2.2</span> 代码(省略头文件和读入优化)</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MAXN 50010</span><span class="co">//数组长度</span>
<span class="ot">#define MAXM 10010</span><span class="co">//询问次数</span>
<span class="ot">#define MAXMM 2666666</span><span class="co">//MAXM*log(MAXX)*log(MAXX)</span>
<span class="ot">#define MINX 0</span><span class="co">//最小数</span>
<span class="ot">#define MAXX nn</span><span class="co">//最大数</span>

<span class="kw">struct</span> Tree{
    <span class="dt">int</span> num;
    <span class="dt">int</span> lson;
    <span class="dt">int</span> rson;
}tree[MAXMM];<span class="co">//线段树</span>
<span class="dt">int</span> top;

<span class="dt">int</span> root[MAXN];<span class="co">//树状数组(存线段树的根)</span>

<span class="dt">int</span> n;
<span class="dt">int</span> arr[MAXN];<span class="co">//原数组</span>
<span class="dt">int</span> nn;<span class="co">//离散化后数的数量</span>
<span class="dt">int</span> kkke[MAXN+MAXM];<span class="co">//离散化用</span>

<span class="kw">inline</span> <span class="dt">int</span> lowbit(<span class="dt">int</span> x)
{
    <span class="kw">return</span> x&amp;-x;
}

<span class="kw">inline</span> <span class="dt">void</span> treeInit()<span class="co">//初始化</span>
{
    top=<span class="dv">0</span>;
    memset(root,<span class="dv">-1</span>,<span class="kw">sizeof</span>(root));
}

<span class="kw">inline</span> <span class="dt">void</span> treeAdd2(<span class="dt">int</span>&amp; nown,<span class="dt">int</span> left,<span class="dt">int</span> right,<span class="dt">int</span> x,<span class="dt">int</span> c)
{
    <span class="kw">if</span>(nown==<span class="dv">-1</span>)
    {
        tree[top].lson=tree[top].rson=<span class="dv">-1</span>;
        tree[top].num=c;
    }
    <span class="kw">else</span>
    {
        tree[top].lson=tree[nown].lson;
        tree[top].rson=tree[nown].rson;
        tree[top].num=tree[nown].num+c;
    }
    nown=top++;
    <span class="kw">if</span>(left&lt;right)
    {
        <span class="dt">int</span> mid=(left+right)&gt;&gt;<span class="dv">1</span>;
        <span class="kw">if</span>(x&lt;=mid)treeAdd2(tree[nown].lson,left,mid,x,c);
        <span class="kw">else</span> treeAdd2(tree[nown].rson,mid<span class="dv">+1</span>,right,x,c);
    }
}

<span class="kw">inline</span> <span class="dt">void</span> treeAdd(<span class="dt">int</span> x,<span class="dt">int</span> y,<span class="dt">int</span> c)<span class="co">//时空复杂度log(MAXX)*log(MAXX)</span>
{
    <span class="kw">for</span>(<span class="dt">int</span> i=x;i&lt;=n;i+=lowbit(i))
        treeAdd2(root[i],MINX,MAXX,y,c);
}

<span class="kw">inline</span> <span class="dt">int</span> treeFind2(<span class="dt">int</span> nown,<span class="dt">int</span> left,<span class="dt">int</span> right,<span class="dt">int</span> l,<span class="dt">int</span> r)
{
    <span class="kw">if</span>(nown==<span class="dv">-1</span>)<span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">if</span>(l&lt;=left&amp;&amp;right&lt;=r)<span class="kw">return</span> tree[nown].num;
    <span class="dt">int</span> mid=(left+right)&gt;&gt;<span class="dv">1</span>;
    <span class="dt">int</span> ans=<span class="dv">0</span>;
    <span class="kw">if</span>(l&lt;=mid)ans+=treeFind2(tree[nown].lson,left,mid,l,r);
    <span class="kw">if</span>(r&gt;mid)ans+=treeFind2(tree[nown].rson,mid<span class="dv">+1</span>,right,l,r);
    <span class="kw">return</span> ans;
}

<span class="kw">inline</span> <span class="dt">int</span> treeFind(<span class="dt">int</span> x,<span class="dt">int</span> y1,<span class="dt">int</span> y2)
{
    <span class="dt">int</span> ans=<span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=x;i;i^=lowbit(i))
        ans+=treeFind2(root[i],MINX,MAXX,y1,y2);
    <span class="kw">return</span> ans;
}

<span class="kw">inline</span> <span class="dt">int</span> treeMerge(<span class="dt">int</span> a,<span class="dt">int</span> b)<span class="co">//合并a,b两线段树</span>
{
    <span class="kw">if</span>(a==<span class="dv">-1</span>)<span class="kw">return</span> b;
    <span class="kw">if</span>(b==<span class="dv">-1</span>)<span class="kw">return</span> a;
    <span class="dt">int</span> nown=top++;
    tree[nown].num=tree[a].num+tree[b].num;
    tree[nown].lson=treeMerge(tree[a].lson,tree[b].lson);
    tree[nown].rson=treeMerge(tree[a].rson,tree[b].rson);
    <span class="kw">return</span> nown;
}

<span class="kw">inline</span> <span class="dt">void</span> treeBuild()<span class="co">//通过共用节点合并建树n*log(n)</span>
{
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)treeAdd2(root[i],MINX,MAXX,arr[i],<span class="dv">1</span>);
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)
    {
        <span class="dt">int</span> j=i+lowbit(i);
        <span class="kw">if</span>(j&lt;=n)root[j]=treeMerge(root[i],root[j]);
    }
}

<span class="kw">inline</span> <span class="dt">int</span> findKth(<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> k)<span class="co">//找[l,r]第k小,1&lt;=k&lt;=l+r</span>
{
    <span class="dt">int</span> left=MINX,right=MAXX,mid;
    <span class="kw">while</span>(left&lt;right)
    {
        mid=(left+right)&gt;&gt;<span class="dv">1</span>;
        <span class="dt">int</span> ans=treeFind(r,MINX,mid)-treeFind(l<span class="dv">-1</span>,MINX,mid);
        <span class="kw">if</span>(ans&lt;k)left=mid<span class="dv">+1</span>;
        <span class="kw">else</span> right=mid;
    }
    <span class="kw">return</span> left;
}

<span class="kw">inline</span> <span class="dt">void</span> arrChange(<span class="dt">int</span> a,<span class="dt">int</span> b)<span class="co">//a位置变为b</span>
{
    treeAdd(a,arr[a],<span class="dv">-1</span>);
    treeAdd(a,b,<span class="dv">1</span>);
    arr[a]=b;
}

<span class="dt">char</span> s[MAXM][<span class="dv">2</span>];
<span class="dt">int</span> a[MAXM];
<span class="dt">int</span> b[MAXM];
<span class="dt">int</span> c[MAXM];

<span class="dt">int</span> main()
{
    <span class="dt">int</span> t;
    <span class="dt">int</span> m;
    kread(t);
    <span class="kw">while</span>(t--)
    {
        treeInit();
        nn=<span class="dv">0</span>;
        kread(n,m);
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)
        {
            kread(arr[i]);
            kkke[nn++]=arr[i];
        }
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;m;i++)
        {
            scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>,s[i]);
            <span class="kw">if</span>(s[i][<span class="dv">0</span>]==<span class="st">&#39;Q&#39;</span>)
            {
                kread(a[i],b[i],c[i]);
                <span class="kw">if</span>(a[i]&gt;b[i])swap(a[i],b[i]);
            }
            <span class="kw">else</span>
            {
                kread(a[i],b[i]);
                kkke[nn++]=b[i];
            }
        }
        sort(kkke,kkke+nn);
        nn=unique(kkke,kkke+nn)-kkke;
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)arr[i]=lower_bound(kkke,kkke+nn,arr[i])-kkke;
        treeBuild();
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;m;i++)
        {
            <span class="kw">if</span>(s[i][<span class="dv">0</span>]==<span class="st">&#39;Q&#39;</span>)
            {
                printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>,kkke[findKth(a[i],b[i],c[i])]);
            }
            <span class="kw">else</span>
            {
                arrChange(a[i],lower_bound(kkke,kkke+nn,b[i])-kkke);
            }
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h3 id="动态可修改整体二分"><span class="header-section-number">8.1.3</span> 动态可修改(整体二分)</h3>
<p>题目同上 复杂度<span class="math inline">\(\Theta \left( nlog^2 \left( n \right) \right)\)</span></p>
<h4 id="代码-16"><span class="header-section-number">8.1.3.1</span> 代码</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MAXN 66666</span>

<span class="dt">int</span> tree[MAXN];<span class="co">//树状数组 </span>

<span class="dt">int</span> lowbit(<span class="dt">int</span> a)
{
    <span class="kw">return</span> a&amp;-a;
}

<span class="dt">void</span> tree_add(<span class="dt">int</span> a,<span class="dt">int</span> b)
{
    <span class="kw">for</span>(<span class="dt">int</span> i=a;i&lt;MAXN;i+=lowbit(i))tree[i]+=b;
}

<span class="dt">int</span> tree_find(<span class="dt">int</span> a)
{
    <span class="dt">int</span> ans=<span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=a;i;i-=lowbit(i))ans+=tree[i];
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> kkke[MAXN],nk;<span class="co">//离散化用</span>

<span class="dt">int</span> khash(<span class="dt">int</span> x)
{
    <span class="kw">return</span> lower_bound(kkke,kkke+nk,x)-kkke;
}

<span class="dt">int</span> n,m;
<span class="dt">int</span> arr[MAXN];<span class="co">//原数组</span>
<span class="kw">struct</span> Query{
    <span class="dt">int</span> a,b,k,id;
    <span class="co">//id&gt;=0 : 查询[a,b]中第k小,是第id个询问</span>
    <span class="co">//id==-1 : a位置+1 位置上变为b</span>
    <span class="co">//id==-2 : a位置-1 位置上原是b</span>
}query[MAXN],q1[MAXN],q2[MAXN];
<span class="dt">int</span> ID;<span class="co">//询问数</span>
<span class="dt">int</span> mm;<span class="co">//修改拆为删除和添加后的总操作数</span>
<span class="dt">int</span> ans[MAXN];<span class="co">//储存答案</span>

<span class="dt">char</span> S[<span class="dv">22</span>];

<span class="dt">void</span> work(<span class="dt">int</span> head,<span class="dt">int</span> tail,<span class="dt">int</span> left,<span class="dt">int</span> right)
{
    <span class="kw">if</span>(head&gt;tail)<span class="kw">return</span>;
    <span class="kw">if</span>(left&gt;=right)
    {
        <span class="kw">for</span>(<span class="dt">int</span> i=head;i&lt;=tail;i++)
            <span class="kw">if</span>(query[i].id&gt;=<span class="dv">0</span>)
                ans[query[i].id]=left;
        <span class="kw">return</span>;
    }
    <span class="dt">int</span> mid=(left+right)&gt;&gt;<span class="dv">1</span>;
    <span class="dt">int</span> n1=<span class="dv">0</span>,n2=<span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=head;i&lt;=tail;i++)
    {
        <span class="kw">if</span>(query[i].id&lt;<span class="dv">0</span>)
        {
            <span class="kw">if</span>(query[i].b&lt;=mid)
            {
                tree_add(query[i].a,query[i].id==<span class="dv">-1</span>?<span class="dv">1</span>:<span class="dv">-1</span>);
                q1[n1++]=query[i];
            }
            <span class="kw">else</span> q2[n2++]=query[i];
        }
        <span class="kw">else</span>
        {
            <span class="dt">int</span> tmp=tree_find(query[i].b)-tree_find(query[i].a<span class="dv">-1</span>);
            <span class="kw">if</span>(tmp&gt;=query[i].k)q1[n1++]=query[i];
            <span class="kw">else</span>
            {
                query[i].k-=tmp;
                q2[n2++]=query[i];
            }
        }
    }

    <span class="kw">for</span>(<span class="dt">int</span> i=head;i&lt;=tail;i++)<span class="co">//还原</span>
        <span class="kw">if</span>(query[i].id&lt;<span class="dv">0</span>&amp;&amp;query[i].b&lt;=mid)
            tree_add(query[i].a,query[i].id==<span class="dv">-1</span>?<span class="dv">-1</span>:<span class="dv">1</span>);

    <span class="dt">int</span> nn=head;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n1;i++)
        query[nn++]=q1[i];
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n2;i++)
        query[nn++]=q2[i];
    work(head,head+n1<span class="dv">-1</span>,left,mid);
    work(head+n1,tail,mid<span class="dv">+1</span>,right);
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> t;
    kread(t);
    <span class="kw">while</span>(t--)
    {
        memset(tree,<span class="dv">0</span>,<span class="kw">sizeof</span>(tree));
        kread(n,m);
        ID=mm=nk=<span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)
        {
            kread(arr[i]);

            query[mm].a=i;
            query[mm].b=arr[i];
            query[mm++].id=<span class="dv">-1</span>;

            kkke[nk++]=arr[i];
        }
        <span class="dt">int</span> a,b;
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;m;i++)
        {
            scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>,S);
            <span class="kw">if</span>(S[<span class="dv">0</span>]==<span class="st">&#39;Q&#39;</span>)
            {
                kread(query[mm].a,query[mm].b,query[mm].k);
                query[mm++].id=ID++;
            }
            <span class="kw">else</span>
            {
                kread(a,b);
                query[mm].a=a;
                query[mm].b=b;
                query[mm++].id=<span class="dv">-1</span>;

                query[mm].a=a;
                query[mm].b=arr[a];
                query[mm++].id=<span class="dv">-2</span>;

                kkke[nk++]=arr[a]=b;
            }
        }
        sort(kkke,kkke+nk);
        nk=unique(kkke,kkke+nk)-kkke;
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;mm;i++)
            <span class="kw">if</span>(query[i].id&lt;<span class="dv">0</span>)
                query[i].b=khash(query[i].b);
        work(<span class="dv">0</span>,mm<span class="dv">-1</span>,<span class="dv">0</span>,nk<span class="dv">-1</span>);
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;ID;i++)
            printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>,kkke[ans[i]]);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h1 id="stl"><span class="header-section-number">9</span> STL</h1>
<h2 id="求合并交集并集差集"><span class="header-section-number">9.1</span> 求合并,交集,并集，差集</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> _InIt1,<span class="kw">class</span> _InIt2,<span class="kw">class</span> _OutIt&gt;
inline_OutIt set_intersection(       <span class="co">//参数格式</span>
  _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest)
<span class="co">//传进去的两个容器必须是有序的</span>

merge()        <span class="co">//合并</span>
set_intersection()        <span class="co">//交集        A∩B</span>
set_union()                 <span class="co">//并集         A∪B</span>
set_difference()           <span class="co">//差集          A-B</span>
set_symmetric_difference() <span class="co">//并集减去交集  (A-B)∪(B-A)=A∪B - A∩B</span>

用法:
merge(a.begin(),a.end(),b.begin(),b.end(),inserter(c,c.begin()));</code></pre></div>
<h2 id="二分查找"><span class="header-section-number">9.2</span> 二分查找</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">lower_bound()     <span class="co">//第一个大于等于</span>
upper_bound()    <span class="co">//第一个大于</span>
用法:
lower_bound(a.begin(),a.end(),x); <span class="co">//返回一个迭代器</span>
lower_bound(a,a+n,x) <span class="co">//返回找到元素的指针</span></code></pre></div>
<h2 id="随机排列"><span class="header-section-number">9.3</span> 随机排列</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> RandomAccessIterator&gt;
   <span class="dt">void</span> random_shuffle(
      RandomAccessIterator _First, <span class="co">//指向序列首元素的迭代器</span>
      RandomAccessIterator _Last  <span class="co">//指向序列最后一个元素的下一个位置的迭代器</span>
   );</code></pre></div>
<h2 id="字符串操作"><span class="header-section-number">9.4</span> 字符串操作</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">strstr(a,b)<span class="co">//在a中找b</span></code></pre></div>
<h2 id="读入优化"><span class="header-section-number">9.5</span> 读入优化</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cctype&gt;</span>

<span class="kw">template</span>&lt;<span class="kw">class</span> TN&gt;
<span class="kw">inline</span> <span class="dt">void</span> kread(TN &amp;x)
{
    x=<span class="dv">0</span>;
    <span class="dt">char</span> c;
    <span class="dt">bool</span> flag=<span class="kw">false</span>;
    <span class="kw">while</span>(!isdigit(c=getchar()))
        <span class="kw">if</span>(c==<span class="st">&#39;-&#39;</span>)
            flag=<span class="kw">true</span>;
    <span class="kw">do</span>{
        x=x*<span class="dv">10</span>+c<span class="dv">-48</span>;
    }<span class="kw">while</span>(isdigit(c=getchar()));
    <span class="kw">if</span>(flag)x=-x;
}

<span class="kw">template</span>&lt;<span class="kw">class</span> TN,<span class="kw">class</span>... ARGS&gt;
<span class="kw">inline</span> <span class="dt">void</span> kread(TN &amp;first,ARGS&amp; ... args)
{
    kread(first);
    kread(args...);
}</code></pre></div>
<h2 id="哈希表unordered_set-unordered_map"><span class="header-section-number">9.6</span> 哈希表unordered_set &amp; unordered_map</h2>
<h3 id="声明"><span class="header-section-number">9.6.1</span> 声明</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">class</span> Key,  
    <span class="kw">class</span> Hash = hash&lt;Key&gt;,  
    <span class="kw">class</span> Pred = equal_to&lt;Key&gt;,  
    <span class="kw">class</span> Alloc = allocator&lt;Key&gt;  
&gt;<span class="kw">class</span> unordered_set;  </code></pre></div>
<h3 id="特例化hash类"><span class="header-section-number">9.6.2</span> 特例化hash类</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> TN&gt;
<span class="kw">inline</span> <span class="dt">void</span> hash_combine(size_t&amp; seed, <span class="dt">const</span> TN &amp;v)
{
    seed ^= hash&lt;TN&gt;()(v) + <span class="bn">0x9e3779b9</span> + (seed&lt;&lt;<span class="dv">6</span>) + (seed&gt;&gt;<span class="dv">2</span>);
}

<span class="co">//以pair&lt;int,int&gt;为例</span>
<span class="kw">namespace</span> std{
        <span class="kw">template</span>&lt;&gt;
            <span class="kw">struct</span> hash&lt;pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt;&gt;{
                <span class="kw">typedef</span> pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; type;
                <span class="kw">explicit</span> hash(){};
                size_t <span class="kw">operator</span>()(<span class="dt">const</span> type &amp;p)<span class="dt">const</span>
                {
                    size_t seed=<span class="dv">0</span>;
                    hash_combine(seed,p.first);
                    hash_combine(seed,p.second);
                    <span class="kw">return</span> seed;
                }
            };
}</code></pre></div>
<h2 id="pbds"><span class="header-section-number">9.7</span> pbds</h2>
<h3 id="优先队列"><span class="header-section-number">9.7.1</span> 优先队列</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;ext/pb_ds/priority_queue.hpp&gt;</span>
<span class="kw">typedef</span> __gnu_pbds::priority_queue&lt;<span class="dt">int</span> ,less&lt;<span class="dt">int</span>&gt;
                        ,__gnu_pbds::pairing_heap_tag&gt;
                        Heap;
<span class="co">//thin_heap_tag 斐波那契堆</span>
<span class="co">//pairing_heap_tag 配对堆</span></code></pre></div>
<h2 id="boost"><span class="header-section-number">9.8</span> boost</h2>
<h3 id="dynamic_bitset"><span class="header-section-number">9.8.1</span> dynamic_bitset</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;boost/dynamic_bitset.hpp&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> boost;
<span class="co">//可以像vector一样用push_back,resize改变长度</span></code></pre></div>
<h3 id="平衡树"><span class="header-section-number">9.8.2</span> 平衡树</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;ext/pb_ds/assoc_container.hpp&gt;</span>
<span class="kw">typedef</span> __gnu_pbds::tree&lt;<span class="dt">int</span>,__gnu_pbds::null_type, less&lt;<span class="dt">int</span>&gt;,
                    __gnu_pbds::rb_tree_tag
                    , __gnu_pbds::tree_order_statistics_node_update&gt;
                    Tree;
<span class="co">//rb_tree_tag 红黑树</span>
<span class="co">//splay_tag splay树</span></code></pre></div>
<h1 id="java"><span class="header-section-number">10</span> Java</h1>
<h2 id="ab-problem"><span class="header-section-number">10.1</span> a+b problem</h2>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">import java.util.Scanner;</span>
<span class="kw">public</span> <span class="kw">class</span> Main{
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(String args[]){
        Scanner cin = <span class="kw">new</span> Scanner(System.<span class="fu">in</span>);
        <span class="dt">int</span> a, b;
        <span class="kw">while</span> (cin.<span class="fu">hasNext</span>()){
            a = cin.<span class="fu">nextInt</span>(); b = cin.<span class="fu">nextInt</span>();
            System.<span class="fu">out</span>.<span class="fu">println</span>(a + b);
        }
    }
}</code></pre></div>
<h2 id="biginteger"><span class="header-section-number">10.2</span> BigInteger</h2>
<h3 id="构造函数"><span class="header-section-number">10.2.1</span> 构造函数</h3>
<p>BigInteger(String val, int radix)<br />
Translates the String representation of a BigInteger in the specified radix into a BigInteger.</p>
<h3 id="方法"><span class="header-section-number">10.2.2</span> 方法</h3>
<table>
<colgroup>
<col width="12%" />
<col width="28%" />
<col width="59%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">返回值</th>
<th align="left">函数</th>
<th align="left">简介</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">BigInteger</td>
<td align="left">abs()</td>
<td align="left">Returns a BigInteger whose value is the absolute value of this BigInteger.</td>
</tr>
<tr class="even">
<td align="left">BigInteger</td>
<td align="left">add(BigInteger val)</td>
<td align="left">Returns a BigInteger whose value is (this + val).</td>
</tr>
<tr class="odd">
<td align="left">BigInteger</td>
<td align="left">and(BigInteger val)</td>
<td align="left">Returns a BigInteger whose value is (this &amp; val).</td>
</tr>
<tr class="even">
<td align="left">BigInteger</td>
<td align="left">andNot(BigInteger val)</td>
<td align="left">Returns a BigInteger whose value is (this &amp; ~val).</td>
</tr>
<tr class="odd">
<td align="left">int</td>
<td align="left">compareTo(BigInteger val)</td>
<td align="left">Compares this BigInteger with the specified BigInteger.</td>
</tr>
<tr class="even">
<td align="left">BigInteger</td>
<td align="left">divide(BigInteger val)</td>
<td align="left">Returns a BigInteger whose value is (this / val).</td>
</tr>
<tr class="odd">
<td align="left">BigInteger[]</td>
<td align="left">divideAndRemainder (BigInteger val)</td>
<td align="left">Returns an array of two BigIntegers containing (this / val) followed by (this % val).</td>
</tr>
<tr class="even">
<td align="left">double</td>
<td align="left">doubleValue()</td>
<td align="left">Converts this BigInteger to a double.</td>
</tr>
<tr class="odd">
<td align="left">boolean</td>
<td align="left">equals(Object x)</td>
<td align="left">Compares this BigInteger with the specified Object for equality.</td>
</tr>
<tr class="even">
<td align="left">BigInteger</td>
<td align="left">gcd(BigInteger val)</td>
<td align="left">Returns a BigInteger whose value is the greatest common divisor of abs(this) and abs(val).</td>
</tr>
<tr class="odd">
<td align="left">BigInteger</td>
<td align="left">max(BigInteger val)</td>
<td align="left">Returns the maximum of this BigInteger and val.</td>
</tr>
<tr class="even">
<td align="left">BigInteger</td>
<td align="left">min(BigInteger val)</td>
<td align="left">Returns the minimum of this BigInteger and val.</td>
</tr>
<tr class="odd">
<td align="left">BigInteger</td>
<td align="left">mod(BigInteger m)</td>
<td align="left">Returns a BigInteger whose value is (this mod m).</td>
</tr>
<tr class="even">
<td align="left">BigInteger</td>
<td align="left">modInverse(BigInteger m)</td>
<td align="left">Returns a BigInteger whose value is (this ^ -1 mod m).</td>
</tr>
<tr class="odd">
<td align="left">BigInteger</td>
<td align="left">modPow(BigInteger exponent, BigInteger m)</td>
<td align="left">Returns a BigInteger whose value is (this ^ exponent mod m).</td>
</tr>
<tr class="even">
<td align="left">BigInteger</td>
<td align="left">multiply(BigInteger val)</td>
<td align="left">Returns a BigInteger whose value is (this * val).</td>
</tr>
<tr class="odd">
<td align="left">BigInteger</td>
<td align="left">negate()</td>
<td align="left">Returns a BigInteger whose value is (-this).</td>
</tr>
<tr class="even">
<td align="left">BigInteger</td>
<td align="left">or(BigInteger val)</td>
<td align="left">Returns a BigInteger whose value is (this | val).</td>
</tr>
<tr class="odd">
<td align="left">BigInteger</td>
<td align="left">pow(int exponent)</td>
<td align="left">Returns a BigInteger whose value is (this ^ exponent).</td>
</tr>
<tr class="even">
<td align="left">BigInteger</td>
<td align="left">remainder(BigInteger val)</td>
<td align="left">Returns a BigInteger whose value is (this % val).</td>
</tr>
<tr class="odd">
<td align="left">BigInteger</td>
<td align="left">shiftLeft(int n)</td>
<td align="left">Returns a BigInteger whose value is (this &lt;&lt; n).</td>
</tr>
<tr class="even">
<td align="left">BigInteger</td>
<td align="left">shiftRight(int n)</td>
<td align="left">Returns a BigInteger whose value is (this &gt;&gt; n).</td>
</tr>
<tr class="odd">
<td align="left">BigInteger</td>
<td align="left">subtract(BigInteger val)</td>
<td align="left">Returns a BigInteger whose value is (this - val).</td>
</tr>
<tr class="even">
<td align="left">String</td>
<td align="left">toString()</td>
<td align="left">Returns the decimal String representation of this BigInteger.</td>
</tr>
<tr class="odd">
<td align="left">String</td>
<td align="left">toString(int radix)</td>
<td align="left">Returns the String representation of this BigInteger in the given radix.</td>
</tr>
<tr class="even">
<td align="left">static BigInteger</td>
<td align="left">valueOf(long val)</td>
<td align="left">Returns a BigInteger whose value is equal to that of the specified long.</td>
</tr>
<tr class="odd">
<td align="left">BigInteger</td>
<td align="left">xor(BigInteger val)</td>
<td align="left">Returns a BigInteger whose value is (this ^ val).</td>
</tr>
</tbody>
</table>
<h2 id="bigdecimal"><span class="header-section-number">10.3</span> BigDecimal</h2>
<h3 id="舍入方式"><span class="header-section-number">10.3.1</span> 舍入方式</h3>
<p>以下在roundingMode参数填入<br />
ROUND_CEILING向正无穷方向舍入<br />
ROUND_DOWN向零方向舍入<br />
ROUND_FLOOR向负无穷方向舍入<br />
ROUND_HALF_DOWN<br />
向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向下舍入, 例如1.55 保留一位小数结果为1.5</p>
<p>ROUND_HALF_EVEN<br />
向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，如果保留位数是奇数，使用ROUND_HALF_UP ，如果是偶数，使用ROUND_HALF_DOWN</p>
<p>ROUND_HALF_UP<br />
向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向上舍入, 1.55保留一位小数结果为1.6</p>
<p>ROUND_UNNECESSARY 计算结果是精确的，不需要舍入模式</p>
<h3 id="方法-1"><span class="header-section-number">10.3.2</span> 方法</h3>
<table>
<thead>
<tr class="header">
<th align="left">返回值</th>
<th align="left">函数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">BigDecimal</td>
<td align="left">divide(BigDecimal divisor, int roundingMode)</td>
</tr>
<tr class="even">
<td align="left">BigDecimal</td>
<td align="left">divide(BigDecimal divisor, int scale, int roundingMode)</td>
</tr>
<tr class="odd">
<td align="left">BigDecimal</td>
<td align="left">setScale(int newScale)</td>
</tr>
<tr class="even">
<td align="left">BigDecimal</td>
<td align="left">setScale(int newScale, int roundingMode)</td>
</tr>
</tbody>
</table>
                </article>
<center>
<div class=no-qrcode-layer> 
	<div> 
		<span class=copyright-text>
			<span>&#169;2017&nbsp;flyuz&nbsp;
			</span>
			<span>陕ICP备17020241号-1&nbsp;
			</span>
		</span> 
	</div> 
</div> 
</center>
            </div>
        </div>
    <script src="./src/jquery-1.10.2.min.js"></script>
    <script src="./src/jquery.ztree.all-3.5.min.js"></script>
    <script src="./src/jquery.ztree_toc.min.js"></script>
    <script type="text/javascript">
        $(document).ready(function(){
            $('#tree').ztree_toc({
                is_auto_number:false,
                documment_selector:'.markdown-body',
                is_expand_all: true
            });
        });
    </script>
    </body>
</html>
